<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Splay-Tree on 蛋餅的競程隨筆</title><link>https://omeletwithoutegg.github.io/tags/splay-tree/</link><description>Recent content in Splay-Tree on 蛋餅的競程隨筆</description><generator>Hugo</generator><language>en-us</language><copyright>Omelet</copyright><lastBuildDate>Fri, 23 Jul 2021 18:16:13 +0800</lastBuildDate><atom:link href="https://omeletwithoutegg.github.io/tags/splay-tree/index.xml" rel="self" type="application/rss+xml"/><item><title>PBDS Split Join Is Slow</title><link>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</link><pubDate>Fri, 23 Jul 2021 18:16:13 +0800</pubDate><guid>https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/</guid><description>&lt;h1 id="幫-pbds-上香">幫 pbds 上香&lt;/h1>
&lt;p>如題。&lt;/p>
&lt;p>先說結論：&lt;br>
官網的 &lt;a href="https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/tree_based_containers.html">document&lt;/a> 寫說 split 跟 join 時間是「poly-logarithm」，但是其實目前為止 GNU 的 pbds 預設的 split 是 $\mathcal{O}(N)$ 的，請看&lt;a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81806">這篇文章&lt;/a>。&lt;br>
不過有一些方法可以讓複雜度變回一次 &lt;code>split&lt;/code> $\Theta(\log N)$，但是有一點麻煩。&lt;/p></description></item><item><title>TIOJ-2124</title><link>https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/</link><pubDate>Sat, 22 Feb 2020 20:04:25 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/</guid><description>&lt;h1 id="殿壬看蝴蝶">殿壬看蝴蝶&lt;/h1>
&lt;p>&lt;a href="https://tioj.ck.tp.edu.tw/problems/2124">https://tioj.ck.tp.edu.tw/problems/2124&lt;/a>&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>太長了，略&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>看到第五種操作就會想用平衡樹去寫這題&lt;br>
然後仔細看看就會發現第八種操作其實和其他操作都沒什麼關係，只有第三、四種操作會改變以蝴蝶編號為順序的區間和&lt;br>
所以呢對蝴蝶的編號開一個線段樹、對樹的編號開個Splay就能AC了&lt;br>
Splay只需要實現查一個節點在中序是第個、查中序第k個節點是什麼，還有剪切區間&lt;br>
至於區間和就隨便維護吧XD，code如下，我不知道該對裸題做甚麼解釋&lt;/p></description></item><item><title>TIOJ-1950</title><link>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/</link><pubDate>Fri, 13 Dec 2019 23:26:11 +0000</pubDate><guid>https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/</guid><description>&lt;h1 id="小向的試煉-2-3轉rotate">小向的試煉 2-3：轉！(Rotate!)&lt;/h1>
&lt;p>&lt;a href="https://tioj.ck.tp.edu.tw/problems/1950">https://tioj.ck.tp.edu.tw/problems/1950&lt;/a>&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>給定長度$N$的排列，問「以交換任意兩個數字的方式排序這個序列需要多少次數」&lt;br>
另外有$M$次修改，每次修改會交換數字$i$和數字$j$的位置，請輸出$M+1$行代表一開始和每次修改過後的答案&lt;/p></description></item></channel></rss>